[{"title":"C++拾遗录0205","path":"/2026/02/05/C-拾遗录0205/","content":"该系列主要用于收集我每天在各种地方不论是刷题还是面经，看到的一些小的或者还没见过的知识点。 [TOC] 1. 什么是实型值，什么是整形值 来源：牛客选择题 在 C++ 编程中，整型值和实型值是两种基础的数字表示方式，它们的命名直接体现了各自的数学本质与用途。整型值对应数学中的整数概念，其名称中的”整”字强调了数值的完整性和离散性，用于表示那些天然以完整单位存在的事物，如人数、物品数量等。整型值在内存中以精确的二进制形式存储，不包含小数部分，确保了计算结果的绝对精确，特别适合需要精确计数的场景。 而实型值的名称源于数学中的实数概念，这里的”实”并非指真假，而是表示能够刻画连续变化量的数值类型。它主要用于处理带小数的数据或范围极大的数值，如测量值、科学计算中的物理量等。实型值在计算机内部通常以浮点数格式存储，这种表示方法允许小数点”浮动”以兼顾数值范围和精度，但会引入微小的舍入误差。因此，实型值适合对精度要求相对宽松但需要表达连续量或极大极小数值的场合。 12345int // 基本整型，通常占 4 字节short // 短整型，通常占 2 字节long // 长整型，通常占 4 或 8 字节long long // 长长整型，通常占 8 字节char // 字符型，也可用作小整数（1 字节） 123float // 单精度浮点型，通常占 4 字节，精度约 6-7 位小数double // 双精度浮点型，通常占 8 字节，精度约 15-16 位小数long double // 扩展精度浮点型，精度更高 2. i++到底何时生效呢 来源：牛客选择题，dowhile里面包含C++，求运行后某个变量的值 牛客上的这个选择题风格差不多如下： 12345int i = 0;do &#123; cout &lt;&lt; &quot;循环内: i = &quot; &lt;&lt; i &lt;&lt; endl; i++; &#125; while (i++ &lt; 3); 初始状态：i = 0 第一次循环： 12345671. 进入循环体，打印：循环内: i = 02. 执行循环体内的 i++，这立即让 i = 13. 判断 while(i++ &lt; 3)： - 计算 i++ &lt; 3：此时 i = 1 - 判断 1 &lt; 3 为 true - 然后 i++ 立即生效，i 变成 2 - 整个表达式返回 true，继续循环 第二次循环： 12345671. 打印：循环内: i = 2 2. 循环体内 i++，i 变成 33. 判断 while(i++ &lt; 3)： - 计算 i++ &lt; 3：此时 i = 3 - 判断 3 &lt; 3 为 false - 然后 i++ 立即生效，i 变成 4 - 整个表达式返回 false，退出循环 注意： 最开始我的理解是：当前表达式执行完之后，再执行一个i=i+1的语句。并非如此。实际上是这样的： 12345int j = i++;// 编译相当于：int temp = i; // 1. 备份当前 i 的值i = i + 1; // 2. 立即修改 i 的值（副作用）return temp; // 3. 返回备份的旧值 编译器保证自增操作在该表达式求值完成前一定发生! 3. 构造函数到底有多少种类型？ 来源：牛客的选择题，出现了各种构造函数，名词有些分不清楚 在 C++ 中，构造函数是一个类在创建对象时自动调用的特殊成员函数，主要用于初始化对象的数据成员和执行必要的资源分配。根据不同的使用场景和特性，构造函数可分为多种类型： 最基本的默认构造函数不接受任何参数，用于创建对象的默认状态； 参数化构造函数则通过接收特定参数来初始化对象，允许创建时就赋予定制化的值； 拷贝构造函数通过接收同类型对象的常量引用来创建新对象，实现对象的深拷贝或浅拷贝逻辑； 移动构造函数则利用右值引用高效转移资源所有权，避免不必要的复制开销； 转换构造函数能从其他类型隐式或显式转换而来，需注意使用 explicit 关键字防止意外转换； 委托构造函数则允许一个构造函数调用同类中的其他构造函数，减少代码重复； 此外还有继承构造函数、**constexpr 构造函数**等特殊形式。 下面是总结的C++ 构造函数类型及注意事项 构造函数类型 语法示例 主要用途 注意事项 默认构造函数 ClassName() 创建对象时不提供参数时的初始化 1. 如果定义了任何构造函数，编译器不会自动生成默认构造函数 2. 可提供默认参数使其成为默认构造函数 参数化构造函数 ClassName(int x, int y) 根据参数初始化对象 1. 可以重载多个版本 2. 推荐使用成员初始化列表提高效率 拷贝构造函数 ClassName(const ClassName&amp; other) 通过已有对象创建新对象（拷贝初始化） 1. 必须使用 const &amp; 参数 2. 需要深拷贝时一定要自定义 3. 避免无限递归拷贝 移动构造函数 ClassName(ClassName&amp;&amp; other) noexcept 从临时对象或即将销毁的对象转移资源 1. 必须使用 &amp;&amp; 右值引用 2. 标记为 noexcept 以保证异常安全 3. 转移后需使原对象处于有效但可析构状态 转换构造函数 ClassName(OtherType value) 从其他类型隐式或显式转换 1. 单参数构造函数默认是转换构造函数 2. 使用 explicit 可禁止隐式转换 3. 谨慎使用，避免意外转换 委托构造函数 ClassName() : ClassName(0, 0) &#123;&#125; 一个构造函数调用同类的其他构造函数 1. C++11 引入的特性 2. 初始化列表中只能委托一个构造函数 3. 避免循环委托 继承构造函数 using Base::Base; 派生类直接使用基类的构造函数 1. C++11 引入 2. 不会继承基类的默认/拷贝/移动构造函数 3. 派生类新增成员需另外初始化 constexpr 构造函数 constexpr ClassName(...) 编译期常量对象的构造 1. C++11 引入 2. 函数体必须为空或只包含 static_assert、using 等 3. 所有成员都必须是字面类型 目前我做的题里，对于转换构造函数比较陌生，这里补充一下转换构造函数的一些知识点： 转换构造函数是指只接受一个参数（或多个参数但第一个后都有默认值）的非拷贝/移动构造函数。它允许从参数类型到类类型的隐式或显式转换。 具体而言，如果某处需要一个 A 类的对象，但提供了其他类型的值，而 A 类存在能接受该类型值的构造函数，编译器将自动调用该构造函数，将该值转换为 A 类的临时对象。 例如，一个复数类 Complex 拥有接受浮点数的构造函数。当编写 Complex c = 3.14; 时，编译器会自动调用该构造函数，将 3.14 转换为复数对象（实部为 3.14，虚部为 0）。这里存在一个重要问题：这种自动转换虽然方便，但可能带来风险。特别是当构造函数涉及分配内存、打开文件或其他资源操作时。代码可能无意中创建对象并消耗资源。 一个 Buffer 类的构造函数接受表示大小的整数。当编写 processBuffer(1024) 时，本意可能是处理现有缓冲区，但编译器会创建一个大小为 1024 的新缓冲区对象。为解决此问题，C++ 提供了 explicit 关键字。在构造函数前添加 explicit 后，编译器不再自动进行转换。必须显式调用构造函数，如 Buffer buf(1024) 或 processBuffer(Buffer(1024))。 实际编程中，除非确有需要自动转换的理由，否则建议为所有单参数构造函数添加 explicit。特别是管理资源的类，如智能指针、文件句柄等，应使用 explicit 防止意外创建对象。 4. 为什么定义二维数组至少指明一个维度（不允许省略列数） 来源：牛客选择题 类似的题我错了百八十遍了就是记不住，字符串和char相关的也记不住，也不知道怎么了。 在C++中定义二维数组时必须至少指定列数，这是因为数组在内存中是按行连续存储的，访问元素 arr[i][j] 时需要通过公式 基地址 + (i × 列数 + j) × 元素大小 来计算内存地址。即使已知行数，编译器仍无法从初始化列表推断出统一的列数——初始化数据可能不规则，例如 &#123;&#123;1,2&#125;, &#123;3,4,5&#125;&#125; 中各行长度不一致，而C++原生数组要求每行列数必须相同以保证内存连续。指定列数相当于明确了每行的边界，让编译器能够正确计算每个元素的位置并分配连续的矩形内存空间，这是C++数组连续内存模型的直接要求。 5. 神奇的结构体数组初始化方式 来源：牛客选择题的题干。见到了这种初始化方式：Node a[3] = {1, &amp;a[1], 2, &amp;a[2]}; 这种是C++种聚合初始化的特性。结构体数组可以使用聚合初始化的简写形式，像 Node a[3] = &#123;1, &amp;a[1], 2, &amp;a[2]&#125;; 这样写是因为 C++ 允许按结构体成员的声明顺序，用扁平化的列表依次填充所有数组元素。编译器会把这个列表按顺序拆解：先填 a[0] 的第一个成员 value=1，再填第二个成员 next=&amp;a[1]，然后自动跳到 a[1] 填它的 value=2 和 next=&amp;a[2]，剩下的 a[2] 所有成员则被默认初始化为零值。这种写法本质上是省略了嵌套花括号的语法糖，虽然紧凑但不直观，虽然打竞赛很常用，但实际开发中别用，谁用我干谁。建议用明确的嵌套形式 &#123;&#123;1,&a[1]&#125;,&#123;2,&a[2]&#125;,&#123;&#125;&#125; 来避免混淆。 6. mutilset/map处理键值重复的原理 来源：牛客 对于这种带mutil帽子的我还是用得太少了。只知道底层都是红黑树。 multiset和multimap通过修改红黑树的插入策略来支持重复键值，核心在于使用insert_equal而非insert_unique操作——插入时跳过键值存在性检查，允许直接创建新节点。 相同键值的多个元素在红黑树中被视为不同节点，它们按照严格弱序规则排列：键值不同的节点按比较器排序，键值相同的节点则保持插入顺序依次排列。这种设计使得查找单个元素时仍为O(log n)复杂度，但要获取所有相同键值元素需要使用equal_range()方法返回迭代器范围，然后遍历该范围内的所有节点。虽然每个重复键值都占用独立节点内存，但这保证了与set/map一致的迭代器稳定性和操作效率。 7. vector和list支持的运算符？vector的迭代器支持完整的算术运算（加减n、比较、下标访问），因为它本质上封装了指针，而vector元素存储在连续内存中，指针运算可以直接对应到内存地址的偏移，时间复杂度为O(1)。list的迭代器只支持前后移动（++/–）和相等比较，因为链表节点在内存中分散存储，要访问第n个元素必须从头遍历n个节点，时间复杂度为O(n)。STL故意不提供list迭代器的随机访问运算符，是为了避免程序员误以为it + n这样的操作是高效常数时间，实际上如果支持也会被实现为隐式遍历。 vector的iterator没重载&gt;&gt;&lt;&lt;输入输出流运算符，它就是个迭代器。迭代器主要用于容器元素的访问和遍历,而不需要处理输入输出操作。 8. 什么是动态联编，什么又是静态联编 总会见到眼熟但一做题就不会的名词。虚函数调用相关 我知道绑定。 静态联编（静态绑定）：在编译期间确定调用哪个函数。 动态联编（动态绑定）：在程序运行时确定调用哪个函数。 注意，函数重载是通过参数列表不同实现的。 9. 动态类型转换(dynamic_cast)和静态类型转换(static_cast)在多重继承场景下的使用规则123456789101112131415struct A1&#123; virtual ~A1()&#123;&#125;&#125;;struct A2&#123; virtual ~A2()&#123;&#125;&#125;;struct B1 : A1, A2&#123;&#125;;int main()&#123; B1 d; A1* pb1 = &amp;d; A2* pb2 = dynamic_cast&lt;A2*&gt;(pb1); //L1 A2* pb22 = static_cast&lt;A2*&gt;(pb1); //L2 return 0;&#125; 这里直接引用官方答案： dynamic_cast和static_cast在多重继承情况下的行为是不同的： L1行dynamic_cast(pb1)能够编译通过：- dynamic_cast在运行时进行类型检查，可以安全地在继承体系中进行转换- 由于B1同时继承自A1和A2，且A1和A2都有虚析构函数(有虚函数表)，dynamic_cast可以正确处理这种多重继承的情况 L2行static_cast(pb1)编译失败：- static_cast是编译时的类型转换，不能在多重继承下将基类指针直接转换为”无关”的另一个基类指针- A1和A2之间没有直接的继承关系，编译器无法确定如何安全地进行这种转换","tags":["C++"]},{"path":"/2026/01/28/虚草稿/","content":"C++中与”虚”相关的概念是面向对象编程的核心机制，也是面试中的高频考点。本文将系统整理C++中所有带”虚”字的知识点和面试题，从基础概念到底层实现，再到常见陷阱和高级应用，帮助您全面掌握这一复杂而强大的特性。一、虚函数与多态基础1.什么是虚函数？它的作用是什么？虚函数是使用关键字声明的成员函数，允许派生类重写基类中的同名函数。作用是实现运行时多态（动态绑定），使基类指针或引用能够根据实际指向的对象类型调用相应的函数实现。2.虚函数是如何实现多态的？通过虚函数表（vtable）和虚表指针（vptr）机制实现：编译器为每个包含虚函数的类生成一个静态的函数指针数组（vtable）每个对象实例在内存中包含一个指向其所属类vtable的指针（vptr）调用虚函数时，通过vptr找到对应的vtable，再根据函数在表中的偏移量找到具体实现3.虚函数调用的时间复杂度是多少？O(1)。因为虚函数表是一个数组，函数地址通过编译期确定的偏移量直接访问，仅需一次指针解引用和跳转。4.构造函数可以是虚函数吗？为什么？不可以。因为：对象尚未完全构造时，vptr还未初始化构造函数必须在编译期确定具体类型，以确保正确初始化基类和成员如果构造函数是虚的，将导致循环构造或无限递归5.哪些函数不能声明为虚函数？以下函数不能声明为虚函数：普通非成员函数（无this指针）静态成员函数（无this指针，所有对象共享）构造函数（如上所述）友元函数（不属于类，不可继承）内联函数（编译期展开与运行时绑定冲突）6.为什么虚函数不能被内联？因为内联是在编译期展开函数体，而虚函数的调用目标是在运行期确定的。这两者存在根本冲突，因此编译器通常不会对虚函数进行内联。7.虚函数的默认参数是如何处理的？默认参数使用静态绑定，即调用时使用声明处（基类）的默认值，而非定义处（派生类）的默认值。示例代码：8.虚函数的实现方式有哪些？主要有两种实现方式：动态绑定：通过虚函数表和虚表指针在运行时确定调用的函数版本静态绑定：当编译器能确定对象类型时，可将虚函数调用转化为直接调用（如关键字或特定上下文）二、纯虚函数与抽象类9.什么是纯虚函数？如何声明？纯虚函数是仅声明不提供实现的特殊虚函数，强制派生类必须重写它。声明形式：10.含有纯虚函数的类叫什么？能实例化吗？称为抽象类，不能实例化对象。抽象类只能作为基类存在，派生类必须重写所有纯虚函数才能实例化11.为什么需要纯虚函数？为派生类提供接口规范，确保派生类实现特定行为。常用于定义接口类，如：12.纯虚函数是否必须在派生类中实现？必须实现。否则，派生类仍然是抽象类，无法实例化。13.纯虚函数在内存中的表现是怎样的？在基类的虚函数表（vtable）中，纯虚函数的地址位置通常被设置为或特定占位值。当尝试调用纯虚函数时，程序会抛出异常或导致未定义行为。14.抽象类的构造函数是否需要特殊处理？抽象类可以有构造函数，用于初始化基类部分的数据成员。例如：三、虚析构函数15.基类为什么需要虚析构函数？确保通过基类指针删除派生类对象时，调用正确的析构函数链。若基类析构函数是非虚的，仅会调用基类部分的析构，导致派生类资源泄漏。16.析构函数可以是纯虚函数吗？可以，但必须提供实现（即使为空）。示例：17.虚析构函数的实现与普通虚函数有何不同？虚析构函数在vtable中有两个条目：完整析构函数（complete object destructor）：负责完全销毁对象删除析构函数（deleting destructor）：在调用析构函数后自动调用运算符这两个条目确保派生类对象通过基类指针删除时，能够正确执行整个析构链。18.纯虚析构函数为什么必须提供定义？即使基类是抽象类，派生类对象销毁时仍需要调用基类的析构函数。若不提供纯虚析构函数的定义，链接器会报错，因为派生类析构函数会隐式调用基类析构函数。19.如何正确声明和实现一个纯虚析构函数？标准写法：四、虚函数表与虚继承的底层机制20.虚函数表（vtable）存储在哪里？通常位于只读数据段（.rodata）（GCC/Clang）或常量段（MSVC）。所有类的虚函数表是静态的，且在程序生命周期内不可修改。21.虚表指针（vptr）在对象中的位置？单继承下位于对象起始位置。多继承下每个基类子对象可能有独立vptr，派生类对象内存布局为：22.如何通过代码观察vtable内容？可以通过指针强制转换遍历vptr指向的函数指针数组：注意：这种方式不推荐在生产代码中使用，仅用于调试理解。23.RTTI（运行时类型信息）与vtable的关系？vtable首项通常存储type_info*指针，用于支持和操作。禁用RTTI（如编译器选项）会移除vtable中的条目，减小vtable大小。24.虚继承如何解决菱形继承问题？通过引入虚基类表（vbtable）和虚基类指针（vbptr），确保菱形继承结构中共享唯一基类实例。示例：25.虚继承对内存布局的影响是怎样的？虚基类通常位于派生类对象的尾部，访问时需要三次间接寻址。内存布局示例：26.虚基类表（vbtable）存储什么信息？存储虚基类的偏移量信息，用于定位派生类对象中虚基类子对象的地址。例如，在D类中访问B的A基类成员时，需要通过B的vbtable获取正确的偏移量。27.虚继承的this指针调整机制是怎样的？当通过非最终派生类的指针访问虚基类成员时，编译器会自动调整this指针。例如，在D类中访问B的A基类成员时，实际this指针会被调整为指向D对象中A的实例。28.虚继承对性能有何影响？引入额外的指针存储和寻址步骤，导致性能损耗。典型影响：每个虚继承基类引入一个额外的虚基类指针（vbptr）访问虚基类成员需要三次间接寻址（vptr → vbtable → 偏移 → 虚基类地址）减少使用虚继承，或仅用于接口类，可最小化性能影响29.多继承场景下vtable如何组织？派生类会维护多个vtable，每个vtable对应一个基类继承路径。内存布局示例：派生类重写虚函数时，会覆盖对应基类vtable中的条目。30.虚继承的VTT表（Virtual Table Table）是什么？VTT表是MSVC实现虚继承时使用的特殊数据结构，用于存储不同层次派生类的vtable指针。在构造函数中，通过VTT表获取正确的vtable指针，确保虚基类正确初始化。五、构造与析构过程中的虚函数行为31.在构造函数中调用虚函数会怎样？不会产生多态行为，而是静态绑定到当前构造阶段的类版本。示例：32.在析构函数中调用虚函数会怎样？同样不会产生多态行为，而是静态绑定到当前析构阶段的类版本。示例：33.构造函数中vptr何时更新为派生类的虚表指针？基类构造函数执行时，vptr指向基类vtable；进入派生类构造函数后，vptr才更新为派生类的vtable。这意味着在基类构造函数中调用虚函数不会跳转到派生类实现。34.为什么在构造函数和析构函数中调用虚函数不会产生多态行为？对象类型在构造和析构过程中被视为”不完整”：构造时：派生类部分尚未构造完成，无法保证其虚函数的正确性析构时：派生类部分已经销毁，其虚函数可能无法安全调用C++标准明确禁止在构造/析构函数中通过动态绑定调用虚函数。35.临时对象通过基类指针捕获时，虚函数调用有何风险？可能导致悬垂指针和未定义行为：临时对象在表达式结束时立即析构基类指针可能指向已销毁对象的内存后续通过该指针调用虚函数会访问无效内存示例：六、虚函数的高级特性和陷阱36.override关键字的作用是什么？显式标记派生类函数对基类虚函数的重写：若签名不匹配（如参数类型不同），编译器会报错增强代码可读性和安全性示例：37.final关键字能否用于虚函数？作用是什么？可以，表示该虚函数不能在派生类中被重写。主要作用：提升代码安全性，防止意外覆盖帮助编译器进行去虚化（devirtualization）优化，将虚函数调用转化为直接调用示例：38.final关键字对虚函数表有何影响？不会移除虚函数表中的条目，但允许编译器进行以下优化：静态绑定已知类型的虚函数调用内联（inline）标记为final的虚函数示例：39.final关键字能否与inline关键字共用？可以，语法合法：这种组合允许编译器将虚函数内联，减少动态绑定开销。40.在多继承场景中，虚函数如何解析？编译器根据虚函数表的偏移量和继承路径自动解析。示例：注意：若多个基类有同名虚函数且未明确覆盖，会导致编译错误。41.虚函数会影响性能吗？相比静态绑定，虚函数调用多一次指针解引用和跳转。现代CPU通过分支预测优化可降低损耗，但高频调用场景仍需谨慎。使用关键字可帮助编译器进行去虚化优化。42.如何避免在构造函数和析构函数中调用虚函数？最佳实践：避免在构造函数和析构函数中调用虚函数若必须使用，可考虑使用初始化函数模式：七、C++11/14/17/20新特性与虚函数43.override关键字的使用规则是什么？使用规则：必须出现在派生类成员函数声明之后仅用于重写基类虚函数的情况若未正确重写（如参数或返回类型不匹配），编译器会报错示例：44.final关键字对虚函数调用的性能优化机制是什么？允许编译器进行去虚化（devirtualization）：当编译器能确定调用对象的实际类型时，可将虚函数调用转化为直接调用减少虚表查询开销，提升性能示例：45.虚函数能否被声明为inline？可以，但效果有限：虚函数因需要运行时绑定，通常无法内联，除非被标记为且调用路径已知。46.override和final关键字在模板中的使用规则是什么？模板中的虚函数重写仍需使用以触发编译器检查。示例：模板类的虚函数标记为后，其特化类也不能重写该函数。47.override关键字能否用于纯虚函数的重写？可以，且推荐使用：这有助于编译器检查函数签名匹配，并增强代码可读性。48.final关键字在多继承中的行为是怎样的？若一个基类的虚函数被声明为final，则任何从该基类派生的类都不能覆盖它。即使通过其他继承路径，派生类也无法覆盖已被标记为的虚函数。示例：八、虚函数表的内存布局和组织规则49.单继承下虚函数表的组织规则是怎样的？派生类vtable继承基类虚函数顺序，重写的函数覆盖基类对应条目，新增虚函数追加到末尾。示例：Base的vtable：[f1, f2]Derived的vtable：[f1, f2, f3]（假设f1被重写）50.多继承下虚函数表的合并机制是怎样的？派生类对象包含多个vptr，分别指向不同基类的vtable。虚表合并遵循以下规则：按照基类声明顺序排列vptr向内层合并（避免内存释放错误）派生类重写的函数会覆盖对应基类vtable中的条目示例：C对象内存布局：[A::vptr][B::vptr][C数据]A的vtable：[a]B的vtable：[b]C的vtable：[a（覆盖）, b（若重写）, c]51.虚函数表在内存中的具体结构是怎样的？标准结构（以Itanium ABI为例）：注意：不同编译器（如MSVC和GCC）的vtable布局可能有差异。52.如何通过汇编代码观察虚函数调用过程？虚函数调用的汇编展开过程：通过反汇编工具（如GDB或LLVM disassembler）可观察虚函数调用的实际指令。53.如何通过调试工具查看对象的vptr？使用GDB调试器：注意：不同编译器和平台的vtable布局可能不同。54.虚函数表在对象生命周期中的变化是怎样的？变化过程：对象创建前：vptr未初始化基类构造阶段：vptr指向基类vtable派生类构造阶段：vptr更新为派生类vtable对象销毁时：vptr仍指向派生类vtable（直到析构完成）这解释了为什么在构造函数中调用虚函数不会跳转到派生类实现。九、虚函数的常见陷阱和解决方案55.基类指针调用派生类对象的虚函数时有何风险？风险：若基类析构函数是非虚的，会导致派生类资源泄漏。解决方案：始终将基类析构函数声明为虚函数。示例：56.纯虚函数在派生类中必须实现吗？必须实现。否则，派生类仍然是抽象类，无法实例化。示例：57.如何避免纯虚函数未实现导致的编译错误？最佳实践：在派生类中显式实现所有纯虚函数使用关键字标记实现，确保编译器检查考虑使用接口类模式，将纯虚函数集中在接口类中58.虚函数在临时对象中的调用有何陷阱？陷阱：通过基类指针捕获派生类临时对象时，临时对象在表达式结束时析构，但指针仍指向其内存。解决方案：避免使用临时对象与多态指针结合。示例：59.如何检测虚函数表指针被非法修改？使用编译器选项：如GCC的，可启用vtable验证机制。效果：当检测到vtable指针被修改时，程序会抛出异常或终止。60.虚函数在构造函数中调用会导致什么问题？问题：可能导致访问未初始化的派生类成员。解决方案：避免在构造函数中调用虚函数。示例：十、虚函数的实际应用和设计模式61.虚函数在设计模式中的应用有哪些？常见应用：工厂方法模式：使用虚函数创建对象抽象工厂模式：使用虚函数族创建对象原型模式：使用虚函数克隆对象策略模式：使用虚函数实现不同算法62.如何在性能敏感场景中优化虚函数使用？优化策略：使用关键字标记不再需要覆盖的虚函数避免在性能关键路径频繁使用虚函数考虑使用模板代替虚函数实现静态多态使用内联函数和关键字增强可读性63.虚函数与模板多态的比较和选择虚函数多态：运行时确定支持动态类型变化适用于开放系统（允许新类加入）模板多态：编译时确定零运行时开销适用于封闭系统（类型已知）示例：64.如何正确使用纯虚函数定义接口？最佳实践：将纯虚函数集中在接口类中为纯虚函数提供默认实现（可选）使用关键字明确派生类实现示例：65.虚函数在STL容器中的应用STL容器不使用虚函数，而是使用模板实现类型无关性。这是因为模板提供：零运行时开销更高的性能更小的代码体积例如，为不同类型T提供不同实现。十一、虚函数的特殊场景和边界情况66.虚函数表在编译时生成还是运行时生成？编译时生成，但对象的vptr在对象创建时初始化。每个类的vtable是静态的，在程序加载时就已存在。67.纯虚函数能否有默认实现？可以，称为默认虚函数：注意：派生类仍需显式声明或定义该函数。68.虚函数能否是静态成员函数？不能。静态成员函数没有this指针，无法参与多态。69.虚函数能否是内联函数？可以声明为内联，但编译器通常不会内联虚函数调用，除非有特殊条件（如标记为且调用路径已知）。示例：70.虚函数能否是友元函数？不能。友元函数不属于类，不可继承，因此不能声明为虚函数。71.虚函数能否是模板函数？不能。模板函数在编译时实例化，而虚函数需要运行时绑定，两者存在根本冲突。72.虚函数能否是const成员函数？可以，但必须保证基类和派生类的资格一致。示例：73.虚函数能否是volatile成员函数？可以，但非常不常见。关键字影响成员函数访问的内存语义，与虚函数机制无直接冲突。74.虚函数能否是restricted成员函数？C++20中可以，关键字限制函数重写，但不会阻止基类中存在同名函数。示例：十二、虚函数的底层实现和调试技巧75.如何通过内存布局观察虚函数表？观察方法：使用调试器查看对象内存布局示例代码：在32位系统中，vptr占4字节，a占4字节，总大小8字节76.如何通过指针强制转换访问虚函数表？访问方法（仅用于调试理解）：注意：不同编译器的vtable布局可能不同。77.虚函数表在多线程环境中的安全性如何？虚函数表是只读的，通常在多线程环境下是安全的。但通过虚函数表指针访问对象时，仍需考虑对象生命周期的安全性。78.如何在不使用虚函数表的情况下实现多态？替代方案：使用函数指针或回调机制使用函数对象（functor）和模板使用类型擦除（type erasure）技术示例（函数指针）：79.虚函数表的大小和内存占用如何计算？计算方法：每个虚函数在vtable中占一个指针大小（4字节或8字节）包含RTTI指针（通常在表首）示例：80.虚函数表在不同编译器（GCC/MSVC/Clang）中的实现有何差异？主要差异：MSVC：VB-Table（虚基表）独立存储，vtable首项为GCC/Clang（Itanium ABI）：虚基类偏移直接嵌入vtable，vtable首项为这些差异影响二进制兼容性，但对源代码兼容性无影响。十三、进阶问题与高级应用81.虚函数与异常处理的交互是怎样的？异常处理规则：虚函数抛出的异常会传播到调用点析构函数中的虚函数调用不会产生多态行为虚函数可以声明为示例：82.虚函数与移动语义的结合使用注意事项：移动构造函数可以是虚函数移动操作符（）不能是虚函数虚函数调用可能影响移动语义的性能示例：83.虚函数与右值引用的结合使用注意事项：右值引用可以与虚函数结合使用虚函数调用右值引用参数时，需注意对象生命周期示例：84.虚函数与左值引用的结合使用注意事项：左值引用可以与虚函数结合使用虚函数调用左值引用参数时，需注意对象生命周期示例：85.虚函数与const_cast的交互是怎样的？交互规则：可以移除虚函数的资格但必须保证操作合法，否则导致未定义行为示例：86.虚函数与dynamic_cast的交互是怎样的？交互规则：依赖于vtable中的条目若禁用RTTI（如编译器选项），则不可用示例：87.虚函数与typeid的交互是怎样的？交互规则：依赖于vtable中的条目若禁用RTTI（如编译器选项），则不可用示例：88.虚函数与noexcept关键字的结合使用结合规则：虚函数可以声明为若基类虚函数声明为，派生类重写时也必须声明为示例：89.虚函数与override关键字的强制检查机制检查机制：编译器严格验证函数签名（包括返回类型、参数列表、资格等）不匹配时会报错示例：90.虚函数与final关键字的组合使用组合规则：虚函数可以同时标记为和示例：十四、特殊问题与常见误区91.虚函数与friend关键字的结合使用结合规则：友元函数可以调用虚函数友元函数不能声明为虚函数示例：92.虚函数与explicit关键字的结合使用结合规则：转换运算符不能是虚函数其他成员函数可以同时标记为和示例：93.虚函数与 delete关键字的结合使用结合规则：可以使用关键字显式删除虚函数的重写示例：94.虚函数与consteval关键字的结合使用结合规则：C++20中，虚函数不能声明为这是因为要求函数在编译期可求值，而虚函数的调用目标在运行期确定95.虚函数与constinit关键字的结合使用结合规则：关键字要求变量在编译期初始化与虚函数无直接冲突，但通常不相关96.虚函数与constexp关键字的结合使用结合规则：C++23中引入的关键字，用于声明编译时可求值的虚函数示例：97.虚函数与[[likely]]/[[unlikely]]属性的结合使用结合规则：可以使用这些属性修饰虚函数但编译器可能忽略这些属性，因为虚函数调用路径不确定98.虚函数与[[落下]]/[[落下]]（C++20中新增的[[落下]]/[[落下]]）的结合使用结合规则：可以使用这些属性修饰虚函数但编译器可能忽略这些属性，因为虚函数调用路径不确定99.虚函数与[[落下]]/[[落下]]（C++20中新增的[[落下]]/[[落下]]）的结合使用结合规则：可以使用这些属性修饰虚函数但编译器可能忽略这些属性，因为虚函数调用路径不确定100.虚函数与[[落下]]/[[落下]]（C++20中新增的[[落下]]/[[落下]]）的结合使用101.- 结合规则：可以使用这些属性修饰虚函数但编译器可能忽略这些属性，因为虚函数调用路径不确定十五、总结与最佳实践虚函数是C++实现运行时多态的核心机制，通过虚函数表（vtable）和虚表指针（vptr）实现动态绑定。在使用虚函数时，应始终为基类析构函数声明为虚函数，以避免内存泄漏。构造函数和析构函数中调用虚函数不会产生多态行为，这是C++设计上的有意限制，以确保安全。纯虚函数用于定义接口，强制派生类实现特定行为。抽象类是包含纯虚函数的类，不能实例化。纯虚析构函数必须提供定义，否则会导致链接错误。override关键字增强了代码安全性，确保派生类正确重写基类虚函数。final关键字可限制虚函数的进一步重写，并帮助编译器进行优化（如去虚化）。在性能敏感场景中，应谨慎使用虚函数，考虑使用模板多态或关键字进行优化。虚继承虽然强大，但引入额外开销，应仅在必要时使用。理解虚函数表的底层实现有助于编写高效和安全的代码。通过调试工具查看vtable内容，可以更好地理解多态机制。在实际开发中，应遵循以下最佳实践：基类析构函数声明为虚函数抽象类提供纯虚函数定义（即使为空）使用关键字显式标记重写适当使用关键字限制重写并优化性能避免在构造函数和析构函数中调用虚函数谨慎使用临时对象与多态指针结合考虑使用模板多态替代虚函数在性能关键场景通过全面掌握C++中与”虚”相关的概念，您可以更好地设计灵活、可扩展且高效的面向对象系统。参考来源[1]面试题—轻松搞定面试中的“虚-CSDN博客https://blog.csdn.net/weixin_33681778/article/details/90253251[2]C++的虚函数相关的面试题目总结_c++中关于虚函数、指针等面试-CSDN博客https://blog.csdn.net/qq_44879626/article/details/117407993#offline_html_corpas[3]virtual（定义C++中虚函数的关键字）百度百科https://baike.baidu.com/item/virtual/3371630[4]虚函数|Microsoft Learnhttps://learn.microsoft.com/zh-cn/cpp/cpp/virtual-functions?view=msvc-170[5]C++面试题：虚函数表(vtable)的底层实现机制与应用解析-C语言实战大全-博客园https://www.cnblogs.com/Rockpan/p/18902860[6]c++virtual function虚函数面试题-初日-博客园http://www.cnblogs.com/churi/articles/3681749.html[7]C++中的“虚“机制解析：虚函数、纯虚函数与虚基类-CSDN博客https://blog.csdn.net/qq_29111047/article/details/156244287[8]一文详解C++的虚函数_c++虚函数实现-CSDN博客https://blog.csdn.net/weixin_41413777/article/details/150845135[9]【北上广深杭大厂编程面试题】C++篇.这里介绍虚函数的实现机制，以及虚函数有哪些作用？附代码（一）CSDN博客https://blog.csdn.net/2401_89898861/article/details/145269654[10]C++面试常见题_c++虚函数面试题-CSDN博客https://blog.csdn.net/2401_86940371/article/details/142731569[11]两道关于虚函数的c++面试题-CSDN博客https://blog.csdn.net/autumoonchina/article/details/128929266[12]Discontinuous Galerkin Method on Three-Dimensional Tetraedral grids. The Use of Template Metaprogramming of the C++ Languagehttps://link.springer.com/content/pdf/10.1134/S2070048217050064.pdf[13]C++学习笔记-虚函数的默认参数_hawkol_新浪博客-CSDN博客https://blog.csdn.net/hawkol/article/details/90608211[14]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[15]Memory-Efficient Object-Oriented Programming on GPUshttps://arxiv.org/abs/1908.05845[16]C++ 虚函数的默认参数问题-Jamgun-博客园https://www.cnblogs.com/jamgun/articles/14679278.html[17]Dynamic Dictionary with Subconstant Wasted Bits per Keyhttps://arxiv.org/abs/2310.20536[18]glsim: a general library for numerical simulationhttps://arxiv.org/abs/1105.2267[19]C++虚函数的默认参数是静态绑定还是动态绑定https://blog.csdn.net/doubleintfloat/article/details/143083299[20]虚继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E7%BB%A7%E6%89%BF/2149276[21]虚函数不应该是inlined（More Effective C++ 笔记）CSDN博客https://blog.csdn.net/weixin_30606461/article/details/99931313[22]C++函数默认参数，记住这两条规则就行https://page.sm.cn/blm/node-page-new-995/index?h=iknow.v4_3.quark.cn&amp;id=28_23aa7815dcb78f4fc135424a5767cb50&amp;q=&amp;sid=0f5b6604c80947f0ac56854ff233e205&amp;entry=native_chat[23]C++函数默认参数，这三个规则得记牢https://page.sm.cn/blm/node-page-new-995/index?h=iknow.v4_3.quark.cn&amp;id=28_63d9513ef11a5ef889fbac3699f91284&amp;q=&amp;sid=0f5b6604c80947f0ac56854ff233e205&amp;entry=native_chat[24]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[25]c++虚函数内存布局示意图_c++虚函数内存分布-CSDN博客https://blog.csdn.net/chenwh_cn/article/details/116458435?utm_source=csdn_ai_ada_ask_robot[26]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[27]虚拟继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/0[28]C++|虚函数表内存布局-我叫RT-博客园https://www.cnblogs.com/TaoR320/p/12680125.html[29]BINARY-LEVEL Software Compatibility Tool Agreementhttps://arxiv.org/abs/2212.03364[30]虚继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E7%BB%A7%E6%89%BF/2149276[31]C++虚函数表内存布局全解析-CSDN博客https://blog.csdn.net/2202_75382767/article/details/152414429[32]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[33]虚函数表_百度百科https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/3978154[34]C++虚函数调用的汇编代码实现详解-CSDN博客https://blog.csdn.net/codegu/article/details/132851964[35]C++|虚函数表内存布局-我叫RT-博客园https://www.cnblogs.com/TaoR320/p/12680125.html[36]C++虚函数调用的汇编过程-CSDN博客https://blog.csdn.net/iteye_3185/article/details/81684650[37]C++拓展：虚函数表的深入探索-腾讯云开发者社区-腾讯云https://cloud.tencent.com/developer/article/2617192[38]C++虚函数表内存布局全解析-CSDN博客https://blog.csdn.net/2202_75382767/article/details/152414429[39]C++程序员光速入门汇编（三）虚函数表与虚函数调用-简书https://www.jianshu.com/p/9af1eb46c4fd[40]Model Checking C++ Programshttps://arxiv.org/abs/2107.01093[41]Data-Centric and Data-Aware Frameworks for Fundamentally Efficient Data Handling in Modern Computing Systemshttps://arxiv.org/abs/2109.05881[42]C++多态中虚函数表合并与继承问题-小念之歌-博客园https://www.cnblogs.com/wangkeqin/p/12887739.html&amp;gt[43]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[44]虚函数表_百度百科https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/3978154[45]C++拓展：虚函数表的深入探索-腾讯云开发者社区-腾讯云https://cloud.tencent.com/developer/article/2617192[46]【C/C++】虚函数表的内存结构_vtable存在什么地方-CSDN博客https://blog.csdn.net/qq_37286579/article/details/130230486[47]C++构造函数中虚函数调用详解与解决方案-CSDN博客https://blog.csdn.net/jjj_web/article/details/155171246[48]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[49]DeClassifier: Class-Inheritance Inference Engine for Optimized C++ Binarieshttps://arxiv.org/abs/1901.10073[50]C++构造函数中虚函数调用规则_c++虚构函数调用-CSDN博客https://blog.csdn.net/m0_49013185/article/details/146552626[51]条款9：绝不在构造和析构过程中调用virtual函数—C++对象构造顺序的陷阱将构造和析构视为对象的脆弱期培养掘金http://juejin.im/entry/7566829163937497115[52]C++构造函数中调用虚函数_c++构造函数调用虚函数-CSDN博客https://blog.csdn.net/alex_my/article/details/44017509?utm_source=blogxgwz7[53]c++析构函数的执行顺序https://www.cnblogs.com/chucklu/p/18925451[54]避免代码崩溃！C++纯虚函数调用陷阱与安全设计策略-CSDN博客https://blog.csdn.net/LogicNest/article/details/154643423[55][原创]C++虚函数的陷阱-胖胖熊-博客园https://www.cnblogs.com/ffbear/archive/2012/08/20/2647615.html[56]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[57]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[58]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[59]ESBMC v7.3: Model Checking C++ Programs using Clang ASThttps://arxiv.org/abs/2308.05649[60]C++中的虚函数表（vtable）是如何工作的？（多态原理）C++-PHP中文网https://www.php.cn/faq/1936147.html[61]c++纯虚析构函数：为何必须定义？c++接口没有定义析构函数会报错吗-CSDN博客https://blog.csdn.net/LJY_CF/article/details/147993889[62]避免代码崩溃！C++纯虚函数调用陷阱与安全设计策略-CSDN博客https://blog.csdn.net/LogicNest/article/details/154643423[63]c++怎么理解虚函数表（vtable）的原理_c++虚函数表机制与多态实现解析-C++-PHP中文网http://www.php.cn/faq/1680106.html[64]虚表_百度百科https://baike.baidu.com/item/%E8%99%9A%E8%A1%A8/5332652[65][C++]虚析构函数-applesun0757-博客园https://www.cnblogs.com/applesun0757/archive/2011/10/09/3085191.html[66]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[67]动态绑定_百度百科https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/3987987[68]C++多态中虚函数表合并与继承问题-小念之歌-博客园https://www.cnblogs.com/wangkeqin/p/12887739.html[69]C++虚函数详解：动态绑定机制深度解析_虚函数绑定逻辑-CSDN博客https://blog.csdn.net/2401_87117051/article/details/148865283[70]多继承（C++程序）百度百科https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF/0[71]C++ 虚函数 动态绑定 的问题-CSDN博客https://blog.csdn.net/weixin_34197488/article/details/93284223[72]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[73]C++ design patterns for low-latency applications including high-frequency tradinghttps://arxiv.org/abs/2309.04259[74]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[75]Master’s Thesis Design and Implementation of a Reversible Object-Oriented Programming Languagehttps://arxiv.org/abs/1707.07845[76]C++纯虚函数_百度百科https://baike.baidu.com/item/C%2B%2B%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/472643[77]Chapter 4 Inheritance, Modifications, and Genericshttps://onlinelibrary.wiley.com/doi/book/10.1002/9781118989166[78]C++如何优化虚表查找的性能 使用final关键字和devirtualization-C++-PHP中文网https://www.php.cn/faq/1413991.html[79]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[80]Static generation of UML sequence diagramshttps://link.springer.com/content/pdf/10.1007/s10009-019-00545-z.pdf[81]Memory-Efficient Object-Oriented Programming on GPUshttps://arxiv.org/abs/1908.05845[82]Right and wrong: ten choices in language designhttps://arxiv.org/abs/2211.16597[83]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[84]BINARY-LEVEL Software Compatibility Tool Agreementhttps://arxiv.org/abs/2212.03364[85]C++11 中引入的关键字作用。c++final-CSDN博客https://blog.csdn.net/weixin_55491446/article/details/148263437[86]override说明符|Microsoft Learnhttps://learn.microsoft.com/zh-cn/cpp/cpp/override-specifier?view=msvc-180[87]glsim: a general library for numerical simulationhttps://arxiv.org/abs/1105.2267[88]C++ design patterns for low-latency applications including high-frequency tradinghttps://arxiv.org/abs/2309.04259[89]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[90]c++中的final关键字用在类和函数上有什么效果_c++ final关键字解析-C++-PHP中文网https://www.php.cn/faq/1610647.html[91]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[92]C++关键字之final的作用_c++ final的作用-CSDN博客https://blog.csdn.net/2503_91939114/article/details/152129080[93]C++虚函数表如何通过final关键字优化-问答-亿速云https://www.yisu.com/ask/56824467.html[94]虚函数表揭秘：如何优化C++的动态多态_c++ 虚函数表优化-CSDN博客https://blog.csdn.net/qq_21438461/article/details/140117194(AI生成)"},{"title":"map和unordered_map小记","path":"/2026/01/28/map和unordered-map小记/","content":"引言在C++标准库中，map和unordered_map是两个常用的关联容器，它们都提供了键值对的存储和查找功能，但在底层实现和使用特性上却有着本质的区别。map基于红黑树实现，保证了元素的有序性，而unordered_map基于哈希表实现，追求更快的查找速度。要深入理解这两种容器的差异，我们需要从它们底层的数据结构说起。《C++标准库》里把容器分为了三类：序列式容器，关联式容器，以及无序容器。虽然都叫map，但map和unordered_map的map经常被拿来比较可能也就是名字非常像的原因。map属于关联式容器，unordered_map是无序容器。我觉得不能说他们都是用key来查找value所以很像，那这些容器的基本功能不都是通过一个索引来查找访问数据吗？无非是这个key是简单的数字值还是我们自己想用的类型罢了。 红黑树：map的底层实现红黑树是一种自平衡的二叉搜索树，它通过为每个节点添加颜色属性（红色或黑色）来维持树的平衡。红黑树的设计思想在于通过相对宽松的平衡条件来减少旋转操作的频率，从而在查找、插入和删除操作之间取得一个较好的平衡。 红黑树的核心特点体现在它的五个约束条件上。首先，每个节点要么是红色，要么是黑色。其次，根节点必须是黑色。第三，所有叶子节点（空节点）都被视为黑色。第四，如果一个节点是红色的，那么它的两个子节点都必须是黑色的，这意味着红色节点不能连续出现。最后，从任意节点到其每个叶子节点的所有路径上，黑色节点的数量必须相同，这个特性保证了红黑树的高度不会过度增长。 这些约束条件虽然不如AVL树那样严格，但足以保证红黑树的高度在最坏情况下也不会超过2倍的最小高度，从而保证了查找操作的时间复杂度为O(log n)。更重要的是，由于平衡条件相对宽松，红黑树在插入和删除操作时需要的旋转次数通常比AVL树少，这使得它在需要频繁修改的场景下表现更好。 AVL树：严格平衡的代表AVL树是另一种自平衡二叉搜索树，它以发明者Adelson-Velsky和Landis的名字命名。AVL树的设计哲学是追求严格的平衡，它要求任何节点的左右子树高度差不能超过1。这种严格的平衡条件使得AVL树在任何时候都保持接近完全平衡的状态。 AVL树通过旋转操作来维持平衡，当插入或删除操作导致某个节点的平衡因子（左右子树高度差）超过1时，就会触发相应的旋转操作。单旋转包括左旋和右旋，双旋转包括左右旋和右左旋。这些旋转操作能够有效地恢复树的平衡，但同时也带来了一定的性能开销。 由于AVL树始终保持严格的平衡，它的查找性能在所有自平衡树中是最优的，查找操作的时间复杂度稳定在O(log n)，且常数因子较小。然而，这种严格的平衡也意味着在插入和删除操作时，AVL树可能需要执行更多的旋转操作来维持平衡，这使得它在需要频繁修改的场景下性能可能不如红黑树。 红黑树与AVL树的权衡红黑树和AVL树在平衡策略上的差异，反映了在查找性能和修改性能之间的不同权衡。红黑树通过允许一定程度的不平衡来减少旋转操作的频率，这使得它在插入和删除操作时效率更高，但查找时可能需要更多的比较次数。而AVL树通过严格的平衡条件来优化查找性能，但代价是在修改操作时需要更多的平衡调整。 从高度角度来看，AVL树的高度通常比红黑树更小，因为它的平衡条件更严格。红黑树虽然整体高度可能较大，但它有一个重要的特性：从根节点到任意叶子节点的路径上，黑色节点的数量是相同的。这个特性保证了红黑树的高度不会过度增长，同时减少了维护平衡的开销。 在实际应用中，红黑树被广泛采用，特别是在C++标准库的map和set容器中。这是因为在实际场景中，容器往往需要同时支持查找和修改操作，而红黑树在两者之间取得了更好的平衡。AVL树则更适合那些查找操作远多于修改操作的场景。 哈希散列的实现方法哈希表是unordered_map的底层实现，它通过哈希函数将键映射到数组的特定位置，从而实现快速查找。哈希函数的设计直接影响哈希表的性能，不同的实现方法各有特点。 开放定址法是最直观的哈希冲突解决方法之一。当发生冲突时，它会按照某种探测序列在哈希表中寻找下一个可用的位置。线性探测是最简单的形式，它按顺序检查下一个位置，直到找到空位。二次探测使用二次函数来生成探测序列，能够减少聚集现象。双重散列则使用第二个哈希函数来生成探测序列，进一步减少了冲突的可能性。开放定址法的优点是不需要额外的存储空间来存储链表，但缺点是删除操作比较复杂，且容易产生聚集现象。 链地址法，也称为拉链法，是另一种常见的冲突解决方法。它将哈希表的每个位置都作为一个链表的头节点，当发生冲突时，将新元素插入到对应位置的链表中。这种方法实现简单，删除操作也很直接，但需要额外的空间来存储链表指针。当链表过长时，查找性能会下降，因此需要合理设计哈希函数和负载因子。 再哈希法使用多个哈希函数，当第一个哈希函数发生冲突时，尝试使用第二个、第三个哈希函数，直到找到空位。这种方法能够有效减少冲突，但需要设计多个良好的哈希函数，实现复杂度较高。 建立公共溢出区是另一种思路，它维护一个额外的区域来存储所有发生冲突的元素。这种方法实现简单，但当冲突较多时，溢出区会变得很大，查找性能会下降。 C++ unordered_map的哈希实现C++标准库的unordered_map主要采用链地址法来解决哈希冲突。这种选择有其合理性，因为链地址法实现相对简单，且能够很好地处理动态扩容和缩容的情况。当哈希表中的元素数量增加时，标准库会自动进行扩容操作，重新分配更大的桶数组，并将所有元素重新哈希到新的位置。 在哈希函数的选择上，C++标准库为基本类型提供了默认的哈希函数，对于自定义类型，则需要用户提供哈希函数或者特化std::hash模板。对于字符串类型，一些实现可能会使用SipHash算法，这是一种密码学安全的哈希函数，能够有效防止哈希碰撞攻击，同时对于相近的字符串能够表现出良好的随机分布特性，从而减少哈希冲突的发生。 unordered_map的扩容与缩容机制unordered_map的扩容机制是自动的，当负载因子（元素数量与桶数量的比值）超过设定的最大值时，容器会自动进行扩容操作。默认情况下，最大负载因子为1.0，但可以通过max_load_factor成员函数进行调整。扩容时，容器会创建一个更大的桶数组，通常是当前大小的两倍左右，然后对所有元素进行重新哈希，这个过程称为rehash。 然而，unordered_map默认情况下不会自动缩容。即使元素数量大幅减少，桶数组的大小也不会自动缩小，这可能导致内存浪费。不过，标准库提供了rehash和reserve等接口，允许用户手动控制桶的数量。如果我们在使用erase等操作大量删除元素后，希望减少内存占用，可以调用rehash函数来手动触发重新哈希，从而减少桶的数量。 unordered_map的性能优化要充分发挥unordered_map的性能优势，有几个关键的优化点需要注意。首先，如果我们能够预估元素的数量，应该在创建容器时就通过reserve函数设置合适的桶数量，这样可以避免多次自动扩容带来的性能开销。其次，选择合适的哈希函数至关重要，一个好的哈希函数应该能够将键均匀分布到各个桶中，减少冲突的发生。对于自定义类型，我们需要仔细设计哈希函数，确保它既快速又具有良好的分布特性。 负载因子的设置也是一个重要的优化点。默认的负载因子为0.75，这是一个在内存占用和性能之间的折中选择。如果我们更注重查找性能，可以适当降低负载因子，这样每个桶中的元素会更少，查找速度会更快，但内存占用会增加。相反，如果内存紧张，可以适当提高负载因子，但要注意过高的负载因子会导致冲突增多，性能下降。 map与unordered_map的全面对比map和unordered_map在多个方面都存在显著差异，这些差异决定了它们各自适用的场景。从数据结构的角度来看，map基于红黑树实现，是一种有序的数据结构，而unordered_map基于哈希表实现，元素之间没有特定的顺序关系。 在查找性能方面，map的查找时间复杂度为O(log n)，这是一个稳定的性能保证。而unordered_map的平均查找时间复杂度为O(1)，但在最坏情况下可能退化到O(n)，这通常发生在哈希函数设计不当或发生大量冲突的情况下。因此，如果我们需要稳定的性能保证，map可能更合适；如果追求平均情况下的高性能，unordered_map是更好的选择。 有序性是一个重要的区别。map中的元素按照键的大小自动排序，这使得范围查询变得非常高效，我们可以轻松地找到某个范围内的所有元素。而unordered_map中的元素是无序的，它不支持范围查询，但单点查询的性能通常更好。 在内存占用方面，红黑树作为平衡二叉树，基本没有空间浪费，每个节点都存储实际的数据。而哈希表需要维护一个桶数组，即使某些桶为空也会占用内存，此外还需要额外的空间来存储链表指针等元数据。因此，map在内存使用上通常更加紧凑。 从内存占用的另一个角度来看，红黑树节点需要存储颜色信息，这通常只需要一个比特位，但为了内存对齐，可能会占用更多空间。相比之下，AVL树节点需要存储平衡因子，通常也需要额外的空间。不过，这个差异相对较小，在实际应用中影响不大。 键类型的要求map和unordered_map对键类型有不同的要求，这反映了它们底层实现的差异。map需要键类型支持比较操作，因为红黑树需要通过比较键的大小来维持有序性。具体来说，键类型需要实现小于运算符（&lt;），或者提供一个自定义的比较函数。这使得map可以处理任何定义了比较关系的类型。 unordered_map的要求则不同，它需要键类型支持两个操作：哈希和相等比较。键类型需要能够被哈希函数处理，生成一个哈希值，同时需要能够判断两个键是否相等。对于基本类型，标准库已经提供了默认的哈希函数和相等比较；对于自定义类型，我们需要提供自定义的哈希函数和相等比较函数，或者特化相应的模板。 一些面试题在实际应用中，经常会遇到一些特殊的需求，比如需要不区分大小写的字符串作为键，或者使用自定义的结构体作为键。 对于不区分大小写的字符串键，map可以通过提供自定义的比较函数来实现，这个比较函数会将字符串转换为统一的大小写后再进行比较。unordered_map则需要同时提供自定义的哈希函数和相等比较函数，哈希函数也需要基于统一大小写的字符串来计算，这样才能确保不区分大小写的特性。 当键是结构体或类对象时，map需要为这个类型实现小于运算符，或者提供一个比较函数对象。这个比较函数需要定义一种全序关系，确保能够正确排序。unordered_map则需要同时实现哈希函数和相等比较函数。哈希函数的设计需要特别小心，它应该能够充分利用结构体的各个成员，生成良好的哈希值分布。相等比较函数则需要比较所有相关的成员，确保两个相等的对象能够被正确识别。","tags":["C++","DS"]},{"title":"虚！（第一版）","path":"/2026/01/28/虚！第一版/","content":"看了非常多的面试题，决定把虚字辈的知识点整理一下。我发现按照论文格式的八股写法，确实很方便整理和记忆。 引言C++中与”虚”相关的概念是面向对象编程的核心机制，也是面试中的高频考点。 看了很多面试题，基本可以分为以下几类： 各种基本概念 - 介绍虚函数、纯虚函数、虚析构函数、虚继承等基本概念及其定义 内存空间长什么样 - 说明虚函数表、vptr、内存布局、虚继承的内存结构等 调用的过程 - 解释虚函数调用的详细过程，包括单继承、多继承、虚继承等场景 为什么要用 - 说明使用虚函数的原因、好处和应用场景 为什么不用 - 说明不使用虚函数的原因、性能考虑和限制 如果不用虚函数，怎么实现多态 - 介绍函数指针、类型擦除、模板等替代方案 各种注意事项 - 列出使用虚函数时需要注意的问题和最佳实践 本文将按照逻辑结构系统整理这些知识点和面试题。 一、各种基本概念什么是虚函数？它的作用是什么？ 虚函数是使用virtual关键字声明的成员函数，它允许派生类重写基类中的同名函数。虚函数的核心作用是实现运行时多态，也就是动态绑定。当我们通过基类指针或引用调用虚函数时，实际执行的是指针或引用所指向对象的实际类型对应的函数版本，而不是基类的版本。这种机制使得我们可以在不知道对象具体类型的情况下，通过统一的接口调用不同类的实现。 虚函数是如何实现多态的？ 虚函数通过虚函数表（vtable）和虚表指针（vptr）机制实现多态。编译器为每个包含虚函数的类生成一个静态的函数指针数组，这就是虚函数表。每个对象实例在内存中包含一个指向其所属类虚函数表的指针，这就是虚表指针。调用虚函数时，通过vptr找到对应的vtable，再根据函数在表中的偏移量找到具体实现。这个偏移量是在编译时确定的，因为函数在类中的声明顺序是固定的。 虚函数调用的时间复杂度是多少？ 虚函数调用的时间复杂度是O(1)。因为虚函数表是一个数组，函数地址通过编译期确定的偏移量直接访问，仅需一次指针解引用和跳转。虽然相比静态绑定多了一次间接寻址，但现代CPU的分支预测机制可以在很大程度上优化这种开销。 构造函数可以是虚函数吗？为什么？ 不可以。原因有几个方面：首先，对象尚未完全构造时，vptr还未初始化，无法进行虚函数调用。其次，构造函数必须在编译期确定具体类型，以确保正确初始化基类和成员。如果构造函数是虚的，将导致循环构造或无限递归。C++标准明确禁止构造函数声明为虚函数。 哪些函数不能声明为虚函数？ 以下函数不能声明为虚函数：普通非成员函数没有this指针，无法参与多态；静态成员函数没有this指针，所有对象共享，无法实现多态；构造函数如上所述不能是虚函数；友元函数不属于类，不可继承，因此不能是虚函数；内联函数编译期展开与运行时绑定存在根本冲突，虽然可以声明为内联，但编译器通常不会内联虚函数调用。 为什么虚函数不能被内联？ 因为内联是在编译期展开函数体，而虚函数的调用目标是在运行期确定的。这两者存在根本冲突，因此编译器通常不会对虚函数进行内联。即使虚函数被声明为inline，编译器也只有在能够确定调用路径的情况下才可能进行内联优化，比如使用final关键字标记且调用对象的类型在编译期已知。 虚函数的默认参数是如何处理的？ 虚函数的默认参数使用静态绑定，即调用时使用声明处（基类）的默认值，而非定义处（派生类）的默认值。这意味着即使派生类重写了虚函数并提供了不同的默认参数，通过基类指针调用时仍然使用基类的默认参数值。这可能会导致意外的行为，因此应该避免在虚函数中使用默认参数，或者确保基类和派生类使用相同的默认参数值。 虚函数的实现方式有哪些？ 主要有两种实现方式：动态绑定通过虚函数表和虚表指针在运行时确定调用的函数版本，这是标准的虚函数实现方式；静态绑定当编译器能确定对象类型时，可将虚函数调用转化为直接调用，比如使用final关键字或编译器能够推断出对象的确切类型时，可以进行去虚化优化。 什么是纯虚函数？如何声明？ 纯虚函数是仅声明不提供实现的特殊虚函数，强制派生类必须重写它。声明形式是在函数声明后添加= 0，例如virtual void func() = 0;。纯虚函数用于定义接口规范，确保派生类实现特定行为。 含有纯虚函数的类叫什么？能实例化吗？ 称为抽象类，不能实例化对象。抽象类只能作为基类存在，派生类必须重写所有纯虚函数才能成为具体类，才能被实例化。抽象类可以有构造函数，用于初始化基类部分的数据成员，但抽象类本身不能创建对象。 为什么需要纯虚函数？ 纯虚函数为派生类提供接口规范，确保派生类实现特定行为。这在设计模式中非常有用，比如策略模式、工厂模式等，都需要通过接口来定义行为规范。抽象类通过纯虚函数确保派生类必须实现某些关键功能，从而保证了系统的正确性和一致性。 纯虚函数是否必须在派生类中实现？ 必须实现。否则，派生类仍然是抽象类，无法实例化。但有一个例外：纯虚析构函数必须提供定义，即使它是纯虚的。这是因为即使基类是抽象类，派生类对象销毁时仍需要调用基类的析构函数。如果不提供纯虚析构函数的定义，链接器会报错。 纯虚函数在内存中的表现是怎样的？ 在基类的虚函数表（vtable）中，纯虚函数的地址位置通常被设置为nullptr或特定占位值。当尝试调用纯虚函数时，程序会抛出异常或导致未定义行为。这确保了抽象类不能被实例化，因为调用未实现的纯虚函数会导致程序崩溃。 抽象类的构造函数是否需要特殊处理？ 抽象类可以有构造函数，用于初始化基类部分的数据成员。抽象类的构造函数不需要特殊处理，它和普通类的构造函数一样工作。抽象类不能实例化，但它的构造函数会在派生类对象的构造过程中被调用。 基类为什么需要虚析构函数？ 确保通过基类指针删除派生类对象时，调用正确的析构函数链。若基类析构函数是非虚的，仅会调用基类部分的析构，导致派生类资源泄漏。将基类析构函数声明为虚函数可以确保在删除对象时，按照正确的顺序调用整个析构函数链，从派生类到基类依次析构。 析构函数可以是纯虚函数吗？ 可以，但必须提供实现（即使为空）。这是因为即使基类是抽象类，派生类对象销毁时仍需要调用基类的析构函数。如果不提供纯虚析构函数的定义，链接器会报错，因为派生类析构函数会隐式调用基类析构函数。 虚析构函数的实现与普通虚函数有何不同？ 虚析构函数在vtable中有两个条目：完整析构函数（complete object destructor）负责完全销毁对象；删除析构函数（deleting destructor）在调用析构函数后自动调用delete运算符。这两个条目确保派生类对象通过基类指针删除时，能够正确执行整个析构链。 纯虚析构函数为什么必须提供定义？ 即使基类是抽象类，派生类对象销毁时仍需要调用基类的析构函数。若不提供纯虚析构函数的定义，链接器会报错，因为派生类析构函数会隐式调用基类析构函数。这是C++语言的一个特殊规则，纯虚析构函数是唯一一个必须提供定义的纯虚函数。 如何正确声明和实现一个纯虚析构函数？ 标准写法是在类内声明为纯虚：virtual ~Base() = 0;，然后在类外提供定义：Base::~Base() &#123;&#125;。即使定义是空的，也必须提供，否则会导致链接错误。 虚继承如何解决菱形继承问题？ 通过引入虚基类表（vbtable）和虚基类指针（vbptr），确保菱形继承结构中共享唯一基类实例。在菱形继承中，如果两个基类都继承自同一个基类，而派生类又同时继承这两个基类，普通继承会导致派生类包含两份最顶层基类的副本。虚继承通过共享机制，确保最顶层的基类只有一个实例。 虚函数表在编译时生成还是运行时生成？ 虚函数表在编译时生成，但对象的vptr在对象创建时初始化。每个类的vtable是静态的，在程序加载时就已存在，且在程序生命周期内不可修改。所有该类的对象共享同一个虚函数表。 纯虚函数能否有默认实现？ 可以，称为默认虚函数。可以在基类中为纯虚函数提供默认实现，但派生类仍需显式声明或定义该函数。这种设计允许基类提供默认行为，同时仍然强制派生类明确选择是否使用默认实现。 虚函数能否是静态成员函数？ 不能。静态成员函数没有this指针，无法参与多态。静态成员函数属于类而不是对象，所有对象共享同一个静态成员函数，因此无法实现多态行为。 虚函数能否是内联函数？ 可以声明为内联，但编译器通常不会内联虚函数调用，除非有特殊条件（如标记为final且调用路径已知）。因为内联是在编译期展开函数体，而虚函数的调用目标是在运行期确定的，这两者存在根本冲突。 虚函数能否是友元函数？ 不能。友元函数不属于类，不可继承，因此不能声明为虚函数。友元函数只是被授予访问类私有成员的权限，但它本身不是类的成员函数。 虚函数能否是模板函数？ 不能。模板函数在编译时实例化，而虚函数需要运行时绑定，两者存在根本冲突。模板函数需要在编译期确定所有类型，而虚函数需要在运行期确定调用目标，这两种机制无法同时工作。 虚函数能否是const成员函数？ 可以，但必须保证基类和派生类的const资格一致。如果基类的虚函数是const的，派生类重写时也必须是const的；如果基类不是const的，派生类可以是const的，但这会导致函数签名不匹配，需要使用override关键字来检查。 虚函数能否是volatile成员函数？ 可以，但非常不常见。volatile关键字影响成员函数访问的内存语义，与虚函数机制无直接冲突，但在实际应用中很少使用。 二、内存空间长什么样虚函数表（vtable）存储在哪里？ 虚函数表通常位于只读数据段（.rodata）（GCC/Clang）或常量段（MSVC）。所有类的虚函数表是静态的，且在程序生命周期内不可修改。每个类的虚函数表只有一份，该类的所有对象共享同一个虚函数表。虚函数表在编译时生成，在程序加载时就已存在。 虚表指针（vptr）在对象中的位置？ 单继承下vptr位于对象起始位置。多继承下每个基类子对象可能有独立vptr，派生类对象内存布局为：按照基类声明顺序排列vptr，然后是派生类新增的数据成员。每个vptr指向对应基类的虚函数表。 如何通过代码观察vtable内容？ 可以通过指针强制转换遍历vptr指向的函数指针数组。这种方式不推荐在生产代码中使用，仅用于调试理解。需要注意的是，不同编译器的vtable布局可能不同，这种操作可能导致未定义行为。 RTTI（运行时类型信息）与vtable的关系？ vtable首项通常存储type_info*指针，用于支持dynamic_cast和typeid操作。禁用RTTI（如编译器选项-fno-rtti）会移除vtable中的这个条目，减小vtable大小，但同时也无法使用dynamic_cast和typeid操作。 虚继承对内存布局的影响是怎样的？ 虚基类通常位于派生类对象的尾部，访问时需要三次间接寻址。内存布局大致是：派生类数据成员在前，然后是各个基类的数据成员，最后是虚基类的数据成员。访问虚基类成员需要通过vptr找到虚函数表，然后通过虚基类表指针找到虚基类表，最后通过虚基类表中的偏移量找到虚基类在对象中的实际位置。 虚基类表（vbtable）存储什么信息？ 存储虚基类的偏移量信息，用于定位派生类对象中虚基类子对象的地址。例如，在D类中访问B的A基类成员时，需要通过B的vbtable获取正确的偏移量。不同的继承路径可能需要不同的偏移量，因此虚基类表的存在使得编译器能够在运行时正确计算虚基类的地址。 虚继承的this指针调整机制是怎样的？ 当通过非最终派生类的指针访问虚基类成员时，编译器会自动调整this指针。例如，在D类中访问B的A基类成员时，实际this指针会被调整为指向D对象中A的实例。这种调整是通过虚基类表中的偏移量来实现的，确保访问到正确的虚基类实例。具体可以看我的这篇：多继承的虚函数表会有几张 多继承场景下vtable如何组织？ 派生类会维护多个vtable，每个vtable对应一个基类继承路径。内存布局示例：C对象内存布局包含[A::vptr][B::vptr][C数据]。A的vtable包含A的虚函数，B的vtable包含B的虚函数，C的vtable包含重写的函数和新增的虚函数。派生类重写虚函数时，会覆盖对应基类vtable中的条目。 虚继承的VTT表（Virtual Table Table）是什么？ VTT表是MSVC实现虚继承时使用的特殊数据结构，用于存储不同层次派生类的vtable指针。在构造函数中，通过VTT表获取正确的vtable指针，确保虚基类正确初始化。这是MSVC特有的实现方式，GCC和Clang使用不同的机制。 单继承下虚函数表的组织规则是怎样的？ 派生类vtable继承基类虚函数顺序，重写的函数覆盖基类对应条目，新增虚函数追加到末尾。例如，Base的vtable包含[f1, f2]，如果Derived重写了f1并新增了f3，那么Derived的vtable为[f1（重写版本）, f2, f3]。 多继承下虚函数表的合并机制是怎样的？ 派生类对象包含多个vptr，分别指向不同基类的vtable。虚表合并遵循以下规则：按照基类声明顺序排列vptr；向内层合并（避免内存释放错误）；派生类重写的函数会覆盖对应基类vtable中的条目。每个基类维护自己的虚函数表，派生类重写时更新对应表的条目。 虚函数表在内存中的具体结构是怎样的？ 标准结构（以Itanium ABI为例）：vtable首项存储type_info指针（如果启用RTTI），然后是按照声明顺序排列的虚函数指针。不同编译器（如MSVC和GCC）的vtable布局可能有差异，MSVC的vtable首项可能是偏移量，而GCC/Clang的首项是type_info。 如何通过调试工具查看对象的vptr？ 使用GDB调试器可以通过print *obj查看对象的内存布局，或者使用info vtbl obj命令查看虚函数表内容。注意不同编译器和平台的vtable布局可能不同，调试时需要了解具体的实现细节。 虚函数表在对象生命周期中的变化是怎样的？ 变化过程：对象创建前vptr未初始化；基类构造阶段vptr指向基类vtable；派生类构造阶段vptr更新为派生类vtable；对象销毁时vptr仍指向派生类vtable（直到析构完成）。这解释了为什么在构造函数中调用虚函数不会跳转到派生类实现，因为此时vptr还没有更新为派生类的vtable。 如何通过内存布局观察虚函数表？ 可以使用调试器查看对象内存布局，或者通过sizeof运算符查看对象大小。在32位系统中，vptr占4字节，在64位系统中占8字节。通过比较包含虚函数和不包含虚函数的类的大小，可以观察到vptr的存在。 如何通过指针强制转换访问虚函数表？ 可以通过将对象指针转换为函数指针数组来访问虚函数表，但这种方式非常危险，不推荐使用。注意不同编译器的vtable布局可能不同，这种操作可能导致未定义行为。 虚函数表的大小和内存占用如何计算？ 计算方法：每个虚函数在vtable中占一个指针大小（4字节或8字节，取决于系统架构）；包含RTTI指针（通常在表首，如果启用RTTI）；派生类的vtable会继承基类的所有条目，再加上新增的虚函数。每个类的vtable只有一份，所有对象共享，所以内存开销相对较小。 虚函数表在不同编译器（GCC/MSVC/Clang）中的实现有何差异？ 主要差异：MSVC的VB-Table（虚基表）独立存储，vtable首项为偏移量；GCC/Clang（Itanium ABI）的虚基类偏移直接嵌入vtable，vtable首项为type_info*。这些差异影响二进制兼容性，但对源代码兼容性无影响。不同编译器编译的代码不能混用，但源代码可以在不同编译器间移植。 虚函数表在多线程环境中的安全性如何？ 虚函数表是只读的，通常在多线程环境下是安全的。所有线程共享同一个虚函数表，因为它是静态的且不可修改。但通过虚函数表指针访问对象时，仍需考虑对象生命周期的安全性。如果多个线程同时访问同一个对象，需要适当的同步机制来保证线程安全。 三、调用的过程如何通过汇编代码观察虚函数调用过程？ 虚函数调用的汇编展开过程大致是：首先从对象中加载vptr到寄存器；然后通过vptr加上偏移量找到虚函数表中的函数地址；最后调用该函数地址。通过反汇编工具（如GDB或LLVM disassembler）可观察虚函数调用的实际指令，可以看到相比普通函数调用多了一次内存访问和间接跳转。 构造函数中vptr何时更新为派生类的虚表指针？ 基类构造函数执行时，vptr指向基类vtable；进入派生类构造函数后，vptr才更新为派生类的vtable。这意味着在基类构造函数中调用虚函数不会跳转到派生类实现，因为此时vptr还指向基类的vtable。只有当派生类构造函数开始执行时，vptr才会被更新。 在多继承场景中，虚函数如何解析？ 编译器根据虚函数表的偏移量和继承路径自动解析。当我们通过某个基类指针调用虚函数时，编译器会使用该基类对应的vptr和虚函数表。如果派生类重写了某个基类的虚函数，那么该基类的虚函数表中对应位置的条目会被更新。注意：若多个基类有同名虚函数且未明确覆盖，会导致编译错误，需要通过作用域解析运算符来明确指定。 简述多态的实现原理 多态通过虚函数表和虚表指针实现。每个包含虚函数的类都有一个虚函数表，存储该类所有虚函数的地址。每个对象包含一个vptr，指向其所属类的虚函数表。调用虚函数时，通过vptr找到vtable，再根据函数在表中的偏移量找到具体实现。这个过程在运行时完成，因此称为动态绑定或运行时多态。 非虚函数和虚函数的调用原理 非虚函数使用静态绑定，编译器在编译期就能确定调用的函数地址，直接生成函数调用指令。虚函数使用动态绑定，编译器生成通过vptr查找vtable并间接调用的指令，函数地址在运行期确定。非虚函数调用更快，但无法实现多态；虚函数调用稍慢，但支持运行时多态。 同一个类的不同对象虚函数表是同一个吗？ 是的，同一个类的所有对象共享同一个虚函数表。虚函数表是类的静态数据，在编译时生成，所有该类的对象都通过vptr指向同一个vtable。只有vptr是每个对象独有的，存储在对象的内存中。 四、为什么要用虚函数在设计模式中的应用有哪些？ 常见应用包括：工厂方法模式使用虚函数创建对象，基类定义创建接口，派生类实现具体的创建逻辑；抽象工厂模式使用虚函数族创建对象，提供创建一系列相关对象的接口；原型模式使用虚函数克隆对象，通过虚函数实现深拷贝；策略模式使用虚函数实现不同算法，将算法封装成可替换的策略类。 如何正确使用纯虚函数定义接口？ 最佳实践包括：将纯虚函数集中在接口类中，定义清晰的接口规范；为纯虚函数提供默认实现（可选），允许派生类选择是否使用默认行为；使用override关键字明确派生类实现，让编译器检查函数签名匹配；确保接口类有虚析构函数，保证通过接口指针删除对象时正确析构。 虚函数在STL容器中的应用 STL容器不使用虚函数，而是使用模板实现类型无关性。这是因为模板提供零运行时开销、更高的性能和更小的代码体积。例如，std::vector&lt;T&gt;为不同类型T提供不同实现，但这些都是编译期确定的，不需要运行时多态。STL的设计哲学是零开销抽象，因此选择模板而不是虚函数。 五、为什么不用虚继承对性能有何影响？ 虚继承引入额外的指针存储和寻址步骤，导致性能损耗。典型影响包括：每个虚继承基类引入一个额外的虚基类指针（vbptr）；访问虚基类成员需要三次间接寻址（vptr → vbtable → 偏移 → 虚基类地址）；内存布局更复杂，可能导致缓存不友好。减少使用虚继承，或仅用于接口类，可最小化性能影响。 虚函数会影响性能吗？ 相比静态绑定，虚函数调用多一次指针解引用和跳转。现代CPU通过分支预测优化可降低损耗，但高频调用场景仍需谨慎。使用final关键字可帮助编译器进行去虚化优化，将虚函数调用转化为直接调用。在性能极度敏感的场景下，可能需要避免使用虚函数。 如何在性能敏感场景中优化虚函数使用？ 优化策略包括：使用final关键字标记不再需要覆盖的虚函数，允许编译器进行去虚化优化；避免在性能关键路径频繁使用虚函数，考虑将热点代码提取为非虚函数；考虑使用模板代替虚函数实现静态多态，在编译期确定类型；使用内联函数和override关键字增强可读性，同时帮助编译器优化。 虚函数与模板多态的比较和选择 虚函数多态在运行时确定，支持动态类型变化，适用于开放系统（允许新类加入）。模板多态在编译时确定，零运行时开销，适用于封闭系统（类型已知）。选择取决于具体需求：如果需要运行时类型变化或开放扩展，使用虚函数；如果类型在编译期已知且性能要求高，使用模板多态。STL容器选择模板就是因为类型在编译期已知。 六、如果不用虚函数，怎么实现多态如何在不使用虚函数表的情况下实现多态？ 替代方案包括：使用函数指针或回调机制，在对象中存储函数指针，通过函数指针实现多态行为；使用函数对象（functor）和模板，通过模板特化实现静态多态；使用类型擦除（type erasure）技术，将不同类型的对象包装成统一的接口，std::function就是这种技术的典型应用。这些方法各有优缺点，函数指针简单但类型安全性差，模板多态性能好但要求编译期类型已知，类型擦除灵活但可能有性能开销。 七、各种注意事项在构造函数中调用虚函数会怎样？ 不会产生多态行为，而是静态绑定到当前构造阶段的类版本。在基类构造函数中，vptr指向基类vtable，因此调用的是基类的虚函数实现。即使进入派生类构造函数后vptr更新为派生类的vtable，此时调用虚函数仍然不会跳转到更下层的派生类实现，因为对象构造尚未完成。这可能导致访问未初始化的派生类成员，应该避免在构造函数中调用虚函数。 在析构函数中调用虚函数会怎样？ 同样不会产生多态行为，而是静态绑定到当前析构阶段的类版本。在派生类析构函数中，vptr仍指向派生类vtable，但此时调用虚函数不会跳转到基类实现。在基类析构函数中，vptr已更新为基类vtable，调用的是基类的实现。这可能导致访问已销毁的派生类成员，应该避免在析构函数中调用虚函数。 为什么在构造函数和析构函数中调用虚函数不会产生多态行为？ 对象类型在构造和析构过程中被视为”不完整”：构造时派生类部分尚未构造完成，无法保证其虚函数的正确性；析构时派生类部分已经销毁，其虚函数可能无法安全调用。C++标准明确禁止在构造/析构函数中通过动态绑定调用虚函数，这是为了确保对象状态的一致性。 临时对象通过基类指针捕获时，虚函数调用有何风险？ 可能导致悬垂指针和未定义行为：临时对象在表达式结束时立即析构；基类指针可能指向已销毁对象的内存；后续通过该指针调用虚函数会访问无效内存。解决方案是避免使用临时对象与多态指针结合，如果需要，应该将临时对象绑定到引用或延长其生命周期。 override关键字的作用是什么？ 显式标记派生类函数对基类虚函数的重写：若签名不匹配（如参数类型不同），编译器会报错；增强代码可读性和安全性。override关键字是C++11引入的，它让编译器检查函数是否真的重写了基类的虚函数，避免因为签名不匹配而意外创建新函数。 final关键字能否用于虚函数？作用是什么？ 可以，表示该虚函数不能在派生类中被重写。主要作用包括：提升代码安全性，防止意外覆盖；帮助编译器进行去虚化（devirtualization）优化，将虚函数调用转化为直接调用。final关键字告诉编译器这个函数不会再被重写，允许进行更激进的优化。 final关键字对虚函数表有何影响？ 不会移除虚函数表中的条目，但允许编译器进行以下优化：静态绑定已知类型的虚函数调用；内联（inline）标记为final的虚函数。final关键字不会改变vtable的结构，但允许编译器在能够确定对象类型的情况下进行优化。 final关键字能否与inline关键字共用？ 可以，语法合法。这种组合允许编译器将虚函数内联，减少动态绑定开销。当编译器能够确定调用对象的类型时，可以将final标记的虚函数内联，从而消除虚函数调用的开销。 如何避免在构造函数和析构函数中调用虚函数？ 最佳实践：避免在构造函数和析构函数中调用虚函数；若必须使用多态行为，可考虑使用初始化函数模式，在对象构造完成后调用初始化函数，此时对象已完全构造，可以安全地调用虚函数。 override关键字的使用规则是什么？ 使用规则：必须出现在派生类成员函数声明之后；仅用于重写基类虚函数的情况；若未正确重写（如参数或返回类型不匹配），编译器会报错。override关键字是编译期检查，确保函数签名完全匹配基类的虚函数。 final关键字对虚函数调用的性能优化机制是什么？ 允许编译器进行去虚化（devirtualization）：当编译器能确定调用对象的实际类型时，可将虚函数调用转化为直接调用；减少虚表查询开销，提升性能。这种优化在能够确定对象类型的场景下非常有效，比如局部变量或标记为final的类。 override和final关键字在模板中的使用规则是什么？ 模板中的虚函数重写仍需使用override以触发编译器检查。模板类的虚函数标记为final后，其特化类也不能重写该函数。这些关键字在模板中的行为与在普通类中相同，提供相同的编译期检查。 override关键字能否用于纯虚函数的重写？ 可以，且推荐使用。这有助于编译器检查函数签名匹配，并增强代码可读性。使用override标记纯虚函数的重写可以让代码意图更清晰，同时让编译器检查实现是否正确。 final关键字在多继承中的行为是怎样的？ 若一个基类的虚函数被声明为final，则任何从该基类派生的类都不能覆盖它。即使通过其他继承路径，派生类也无法覆盖已被标记为final的虚函数。这确保了final的语义一致性，无论通过哪个继承路径都无法重写。 基类指针调用派生类对象的虚函数时有何风险？ 风险：若基类析构函数是非虚的，会导致派生类资源泄漏。解决方案：始终将基类析构函数声明为虚函数。这是C++中最常见的错误之一，也是面试中的高频考点。通过基类指针删除派生类对象时，如果析构函数不是虚的，只会调用基类的析构函数。 纯虚函数在派生类中必须实现吗？ 必须实现。否则，派生类仍然是抽象类，无法实例化。但纯虚析构函数是例外，它必须提供定义，即使函数体是空的。这是因为析构函数总是会被调用，即使基类是抽象类。 如何避免纯虚函数未实现导致的编译错误？ 最佳实践：在派生类中显式实现所有纯虚函数；使用override关键字标记实现，确保编译器检查；考虑使用接口类模式，将纯虚函数集中在接口类中。这些方法可以帮助及早发现未实现的纯虚函数，避免在链接时才发现错误。 虚函数在临时对象中的调用有何陷阱？ 陷阱：通过基类指针捕获派生类临时对象时，临时对象在表达式结束时析构，但指针仍指向其内存。解决方案：避免使用临时对象与多态指针结合。如果需要，应该将临时对象绑定到引用，或者延长其生命周期。 如何检测虚函数表指针被非法修改？ 使用编译器选项，如GCC的-fsanitize=vptr，可启用vtable验证机制。效果：当检测到vtable指针被修改时，程序会抛出异常或终止。这种检测在调试时非常有用，可以帮助发现内存损坏等问题。 虚函数在构造函数中调用会导致什么问题？ 问题：可能导致访问未初始化的派生类成员。解决方案：避免在构造函数中调用虚函数。如果必须使用多态行为，可以考虑使用初始化函数模式，在对象完全构造后再调用。 虚函数与异常处理的交互是怎样的？ 异常处理规则：虚函数抛出的异常会传播到调用点；析构函数中的虚函数调用不会产生多态行为；虚函数可以声明为noexcept。如果虚函数可能抛出异常，应该在函数声明中明确说明，派生类重写时也应该保持相同的异常规范。 虚函数与移动语义的结合使用 注意事项：移动构造函数不能是虚函数（构造函数不能是虚函数）；移动赋值运算符不能是虚函数（赋值运算符可以是虚函数，但移动赋值运算符通常不是）；虚函数调用可能影响移动语义的性能。如果需要多态的移动语义，可以考虑使用虚函数clone模式。 虚函数与dynamic_cast的交互是怎样的？ 交互规则：依赖于vtable中的type_info条目；若禁用RTTI（如编译器选项-fno-rtti），则dynamic_cast不可用。dynamic_cast通过查询vtable中的类型信息来判断类型转换是否合法，如果RTTI被禁用，vtable中就没有类型信息，dynamic_cast无法工作。 虚函数与typeid的交互是怎样的？ 交互规则：依赖于vtable中的type_info条目；若禁用RTTI，则typeid不可用。typeid操作符通过查询vtable中的类型信息来返回类型信息，如果RTTI被禁用，typeid无法工作或返回不完整的信息。 虚函数与noexcept关键字的结合使用 结合规则：虚函数可以声明为noexcept；若基类虚函数声明为noexcept，派生类重写时也必须声明为noexcept。这是C++的异常规范一致性要求，确保异常规范在继承层次中保持一致。 虚函数与override关键字的强制检查机制 检查机制：编译器严格验证函数签名（包括返回类型、参数列表、const资格等）；不匹配时会报错。override关键字让编译器检查函数是否真的重写了基类的虚函数，避免因为签名不匹配而意外创建新函数。 虚函数与final关键字的组合使用 组合规则：虚函数可以同时标记为override和final；这表示函数重写了基类的虚函数，并且不能再被进一步重写。这种组合在需要明确重写关系但不想允许进一步重写时很有用。 虚函数与friend关键字的结合使用 结合规则：友元函数可以调用虚函数；友元函数不能声明为虚函数。友元函数不是类的成员，因此不能是虚函数，但它可以调用类的虚函数。 虚函数与explicit关键字的结合使用 结合规则：转换运算符不能是虚函数；其他成员函数可以同时标记为virtual和explicit。explicit关键字用于防止隐式转换，它与虚函数机制没有冲突，可以同时使用。 虚函数与delete关键字的结合使用 结合规则：可以使用delete关键字显式删除虚函数的重写。在派生类中，可以使用delete关键字删除继承的虚函数，防止该函数被调用。这在某些设计模式中很有用，比如禁止某些操作。 虚函数与consteval关键字的结合使用 结合规则：C++20中，虚函数不能声明为consteval。这是因为consteval要求函数在编译期可求值，而虚函数的调用目标在运行期确定，两者存在根本冲突。 虚函数与constexpr关键字的结合使用 结合规则：C++23中引入的关键字，用于声明编译时可求值的虚函数。这是C++23的新特性，允许虚函数在编译期求值，但需要满足特定条件。 参考资料[1]面试题—轻松搞定面试中的“虚-CSDN博客https://blog.csdn.net/weixin_33681778/article/details/90253251[2]C++的虚函数相关的面试题目总结_c++中关于虚函数、指针等面试-CSDN博客https://blog.csdn.net/qq_44879626/article/details/117407993#offline_html_corpas[3]virtual（定义C++中虚函数的关键字）百度百科https://baike.baidu.com/item/virtual/3371630[4]虚函数|Microsoft Learnhttps://learn.microsoft.com/zh-cn/cpp/cpp/virtual-functions?view=msvc-170[5]C++面试题：虚函数表(vtable)的底层实现机制与应用解析-C语言实战大全-博客园https://www.cnblogs.com/Rockpan/p/18902860[6]c++virtual function虚函数面试题-初日-博客园http://www.cnblogs.com/churi/articles/3681749.html[7]C++中的“虚“机制解析：虚函数、纯虚函数与虚基类-CSDN博客https://blog.csdn.net/qq_29111047/article/details/156244287[8]一文详解C++的虚函数_c++虚函数实现-CSDN博客https://blog.csdn.net/weixin_41413777/article/details/150845135[9]【北上广深杭大厂编程面试题】C++篇.这里介绍虚函数的实现机制，以及虚函数有哪些作用？附代码（一）CSDN博客https://blog.csdn.net/2401_89898861/article/details/145269654[10]C++面试常见题_c++虚函数面试题-CSDN博客https://blog.csdn.net/2401_86940371/article/details/142731569[11]两道关于虚函数的c++面试题-CSDN博客https://blog.csdn.net/autumoonchina/article/details/128929266[12]Discontinuous Galerkin Method on Three-Dimensional Tetraedral grids. The Use of Template Metaprogramming of the C++ Languagehttps://link.springer.com/content/pdf/10.1134/S2070048217050064.pdf[13]C++学习笔记-虚函数的默认参数_hawkol_新浪博客-CSDN博客https://blog.csdn.net/hawkol/article/details/90608211[14]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[15]Memory-Efficient Object-Oriented Programming on GPUshttps://arxiv.org/abs/1908.05845[16]C++ 虚函数的默认参数问题-Jamgun-博客园https://www.cnblogs.com/jamgun/articles/14679278.html[17]Dynamic Dictionary with Subconstant Wasted Bits per Keyhttps://arxiv.org/abs/2310.20536[18]glsim: a general library for numerical simulationhttps://arxiv.org/abs/1105.2267[19]C++虚函数的默认参数是静态绑定还是动态绑定https://blog.csdn.net/doubleintfloat/article/details/143083299[20]虚继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E7%BB%A7%E6%89%BF/2149276[21]虚函数不应该是inlined（More Effective C++ 笔记）CSDN博客https://blog.csdn.net/weixin_30606461/article/details/99931313[22]C++函数默认参数，记住这两条规则就行https://page.sm.cn/blm/node-page-new-995/index?h=iknow.v4_3.quark.cn&amp;id=28_23aa7815dcb78f4fc135424a5767cb50&amp;q=&amp;sid=0f5b6604c80947f0ac56854ff233e205&amp;entry=native_chat[23]C++函数默认参数，这三个规则得记牢https://page.sm.cn/blm/node-page-new-995/index?h=iknow.v4_3.quark.cn&amp;id=28_63d9513ef11a5ef889fbac3699f91284&amp;q=&amp;sid=0f5b6604c80947f0ac56854ff233e205&amp;entry=native_chat[24]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[25]c++虚函数内存布局示意图_c++虚函数内存分布-CSDN博客https://blog.csdn.net/chenwh_cn/article/details/116458435?utm_source=csdn_ai_ada_ask_robot[26]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[27]虚拟继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/0[28]C++|虚函数表内存布局-我叫RT-博客园https://www.cnblogs.com/TaoR320/p/12680125.html[29]BINARY-LEVEL Software Compatibility Tool Agreementhttps://arxiv.org/abs/2212.03364[30]虚继承_百度百科https://baike.baidu.com/item/%E8%99%9A%E7%BB%A7%E6%89%BF/2149276[31]C++虚函数表内存布局全解析-CSDN博客https://blog.csdn.net/2202_75382767/article/details/152414429[32]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[33]虚函数表_百度百科https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/3978154[34]C++虚函数调用的汇编代码实现详解-CSDN博客https://blog.csdn.net/codegu/article/details/132851964[35]C++|虚函数表内存布局-我叫RT-博客园https://www.cnblogs.com/TaoR320/p/12680125.html[36]C++虚函数调用的汇编过程-CSDN博客https://blog.csdn.net/iteye_3185/article/details/81684650[37]C++拓展：虚函数表的深入探索-腾讯云开发者社区-腾讯云https://cloud.tencent.com/developer/article/2617192[38]C++虚函数表内存布局全解析-CSDN博客https://blog.csdn.net/2202_75382767/article/details/152414429[39]C++程序员光速入门汇编（三）虚函数表与虚函数调用-简书https://www.jianshu.com/p/9af1eb46c4fd[40]Model Checking C++ Programshttps://arxiv.org/abs/2107.01093[41]Data-Centric and Data-Aware Frameworks for Fundamentally Efficient Data Handling in Modern Computing Systemshttps://arxiv.org/abs/2109.05881[42]C++多态中虚函数表合并与继承问题-小念之歌-博客园https://www.cnblogs.com/wangkeqin/p/12887739.html&amp;gt[43]Devil isVirtual: Reversing Virtual Inheritance in C++ Binarieshttps://arxiv.org/abs/2003.05039[44]虚函数表_百度百科https://baike.baidu.com/item/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/3978154[45]C++拓展：虚函数表的深入探索-腾讯云开发者社区-腾讯云https://cloud.tencent.com/developer/article/2617192[46]【C/C++】虚函数表的内存结构_vtable存在什么地方-CSDN博客https://blog.csdn.net/qq_37286579/article/details/130230486[47]C++构造函数中虚函数调用详解与解决方案-CSDN博客https://blog.csdn.net/jjj_web/article/details/155171246[48]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[49]DeClassifier: Class-Inheritance Inference Engine for Optimized C++ Binarieshttps://arxiv.org/abs/1901.10073[50]C++构造函数中虚函数调用规则_c++虚构函数调用-CSDN博客https://blog.csdn.net/m0_49013185/article/details/146552626[51]条款9：绝不在构造和析构过程中调用virtual函数—C++对象构造顺序的陷阱将构造和析构视为对象的脆弱期培养掘金http://juejin.im/entry/7566829163937497115[52]C++构造函数中调用虚函数_c++构造函数调用虚函数-CSDN博客https://blog.csdn.net/alex_my/article/details/44017509?utm_source=blogxgwz7[53]c++析构函数的执行顺序https://www.cnblogs.com/chucklu/p/18925451[54]避免代码崩溃！C++纯虚函数调用陷阱与安全设计策略-CSDN博客https://blog.csdn.net/LogicNest/article/details/154643423[55][原创]C++虚函数的陷阱-胖胖熊-博客园https://www.cnblogs.com/ffbear/archive/2012/08/20/2647615.html[56]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[57]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[58]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[59]ESBMC v7.3: Model Checking C++ Programs using Clang ASThttps://arxiv.org/abs/2308.05649[60]C++中的虚函数表（vtable）是如何工作的？（多态原理）C++-PHP中文网https://www.php.cn/faq/1936147.html[61]c++纯虚析构函数：为何必须定义？c++接口没有定义析构函数会报错吗-CSDN博客https://blog.csdn.net/LJY_CF/article/details/147993889[62]避免代码崩溃！C++纯虚函数调用陷阱与安全设计策略-CSDN博客https://blog.csdn.net/LogicNest/article/details/154643423[63]c++怎么理解虚函数表（vtable）的原理_c++虚函数表机制与多态实现解析-C++-PHP中文网http://www.php.cn/faq/1680106.html[64]虚表_百度百科https://baike.baidu.com/item/%E8%99%9A%E8%A1%A8/5332652[65][C++]虚析构函数-applesun0757-博客园https://www.cnblogs.com/applesun0757/archive/2011/10/09/3085191.html[66]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[67]动态绑定_百度百科https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/3987987[68]C++多态中虚函数表合并与继承问题-小念之歌-博客园https://www.cnblogs.com/wangkeqin/p/12887739.html[69]C++虚函数详解：动态绑定机制深度解析_虚函数绑定逻辑-CSDN博客https://blog.csdn.net/2401_87117051/article/details/148865283[70]多继承（C++程序）百度百科https://baike.baidu.com/item/%E5%A4%9A%E7%BB%A7%E6%89%BF/0[71]C++ 虚函数 动态绑定 的问题-CSDN博客https://blog.csdn.net/weixin_34197488/article/details/93284223[72]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[73]C++ design patterns for low-latency applications including high-frequency tradinghttps://arxiv.org/abs/2309.04259[74]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[75]Master’s Thesis Design and Implementation of a Reversible Object-Oriented Programming Languagehttps://arxiv.org/abs/1707.07845[76]C++纯虚函数_百度百科https://baike.baidu.com/item/C%2B%2B%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/472643[77]Chapter 4 Inheritance, Modifications, and Genericshttps://onlinelibrary.wiley.com/doi/book/10.1002/9781118989166[78]C++如何优化虚表查找的性能 使用final关键字和devirtualization-C++-PHP中文网https://www.php.cn/faq/1413991.html[79]Verification of C++ Programs with VeriFasthttps://arxiv.org/abs/2212.13754[80]Static generation of UML sequence diagramshttps://link.springer.com/content/pdf/10.1007/s10009-019-00545-z.pdf[81]Memory-Efficient Object-Oriented Programming on GPUshttps://arxiv.org/abs/1908.05845[82]Right and wrong: ten choices in language designhttps://arxiv.org/abs/2211.16597[83]ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang ASThttps://arxiv.org/abs/2406.17862[84]BINARY-LEVEL Software Compatibility Tool Agreementhttps://arxiv.org/abs/2212.03364[85]C++11 中引入的关键字作用。c++final-CSDN博客https://blog.csdn.net/weixin_55491446/article/details/148263437[86]override说明符|Microsoft Learnhttps://learn.microsoft.com/zh-cn/cpp/cpp/override-specifier?view=msvc-180[87]glsim: a general library for numerical simulationhttps://arxiv.org/abs/1105.2267[88]C++ design patterns for low-latency applications including high-frequency tradinghttps://arxiv.org/abs/2309.04259[89]VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatchinghttps://arxiv.org/abs/2007.03302[90]c++中的final关键字用在类和函数上有什么效果_c++ final关键字解析-C++-PHP中文网https://www.php.cn/faq/1610647.html[91]PlinyCompute: A Platform for High-Performance, Distributed, Data-Intensive Tool Developmenthttps://arxiv.org/abs/1711.05573[92]C++关键字之final的作用_c++ final的作用-CSDN博客https://blog.csdn.net/2503_91939114/article/details/152129080[93]C++虚函数表如何通过final关键字优化-问答-亿速云https://www.yisu.com/ask/56824467.html[94]虚函数表揭秘：如何优化C++的动态多态_c++ 虚函数表优化-CSDN博客https://blog.csdn.net/qq_21438461/article/details/140117194","tags":["C++","面向对象"]},{"title":"虚！","path":"/2026/01/28/虚！第二版/","content":"本来想让AI帮忙总结一下关于C++虚字辈的知识点。结果一看，确实是整理了，但是真的就是纯粹的知识点的堆砌。看了一遍毫无章法。我还是自己写吧，毕竟自己才知道自己对哪一部分比较模糊陌生。 我看了一些面试题，大多数就是让你阐述一下虚函数，然后开始以此深挖。我觉得可以把这些题分为以下这几个类型： 各种基本概念，各种实现实体的内存空间长什么样 在不同的情况下的调用过程 在哪些情况下，为什么要用它 在哪些情况下，为什么不用它 其他零零散散的知识点 我会按照我的思路，一点点复盘这些知识点。 一、各种基本概念和内存布局1. 虚函数是什么虚函数，是C++实现多态的一种重要机制，这里主要指的是动态多态。这种重要机制主要靠虚函数指针和虚函数表来实现（主流编译器的实现方式如此，C++的标准没有规定）。这时候就要想，为什么需要多态？主要想解决的问题就是想用基类的指针，去调用派生类的一些方法，能让代码简洁一些，管理起来也更方便，可扩展性也更高。实现呢就是在类里的成员函数前加上virtual关键字。派生类继承基类的时候，virtual成员函数会被自动继承为virtual，重写的时候即使不加override关键字它也是virtual虚函数。 2. 虚函数表vtable是什么虚函数表就是存储虚函数地址的一张表。由虚函数表指针vptr来指向这张表，来获取表里的虚函数地址，以此调用相应的虚函数。 虚函数表又是什么时候生成的呢？这张表是在编译期就生成好的，所以这是个静态的表。存放在程序的只读数据段里（.rodata）。如果一个派生类重写了基类的虚函数，那么在编译期，我们的编译器就会用派生类重写好的虚函数的地址去替换掉原来虚函数表中对应的那个虚函数的地址。这里要注意，多继承里，虚函数表可不是只有一张。而是每一个被继承的类自己管理自己的虚函数表。关于这部分内容可以看我之前的博客：多继承的虚函数表有几张？ 这里要补充一点：虚函数表里只有一堆虚函数地址吗？并非如此。如果开启了RTTI（运行时类型识别），则可能还包含运行时类型信息RTTI的指针还有其他元数据，这个取决于编译器的实现。 还有一个混淆的点：虚函数是存储在代码段的。虚函数表是一个存储函数指针的数据结构，所以存在只读数据段中。 3. 虚函数表指针vptr是什么这是个指针，存的就是虚函数表的地址。这个指针是由编译器为包含虚函数的类隐式插入的一个指针。这个指针有多大呢？系统有多少位就有多少位。32位系统就是4个字节，64位系统就是8个字节。这个指针通常存在对象内存的起始位置（C++标准并未规定）。vptr是在对象构造的期间才被赋值的，在析构的时候被销毁。但是对于多继承的情况下，一个对象内存里可能有多个虚函数表指针，详见我之前的博客：多继承的虚函数表有几张？我简单总结一下，多继承的派生类的内存布局可理解为：按照继承顺序，依次包含每个基类的完整子对象（包括各自的vptr和数据成员），最后是派生类自身新增的成员。使用其中一个基类的指针或引用去指向派生类的对象的话，编译器会将这个对象的this指针更新为那个基类的起始地址，也就是那个基类的虚函数表指针那里。这样，调用起基类被重写的虚函数，this就直接访问到相应基类的虚函数表了。这里要说一下多继承里，调整this时的offset是怎么来的。符号表会维护类的内存布局，生成代码的时候会硬编码在指令中。 继承类型 offset确定时机 存储位置 使用方式 单继承 编译期计算 硬编码在指令中 直接加减 多继承 编译期计算 硬编码在指令中 也存储在vtable 向上转型时调整 虚函数调用时反向调整 虚继承 部分运行时 虚基类表中 通过查表获取 对于一个多继承来说，比如下面这个代码： 12345678910111213class Base1 &#123;public: virtual void a() = 0; &#125;;class Base2 &#123;public:virtual void b() = 0; &#125;;class Derived : public Base1, public Base2 &#123; void a() override &#123;&#125; void b() override &#123;&#125; virtual void c() &#123;&#125; // 只应在Base1的vtable中&#125;;int main()&#123;Base2* pb = new Derived();pb-&gt;b(); &#125; 我用MSVC的编译器编译出来，截一段： 12345678const Derived::`vftable&#x27;&#123;for `Base1`&#125; DQ FLAT:const Derived::`RTTI Complete Object Locator&#x27;&#123;for `Base1`&#125; DQ FLAT:virtual void Derived::a(void) // 偏移0处：Derived::a DQ FLAT:virtual void Derived::c(void) // 偏移8处：Derived::cconst Derived::`vftable&#x27;&#123;for `Base2`&#125; DQ FLAT:const Derived::`RTTI Complete Object Locator&#x27;&#123;for `Base2`&#125; DQ FLAT:virtual void Derived::b(void) // 偏移0处：Derived::b 还有一段： 1234Derived::`RTTI Complete Object Locator&#x27;&#123;for `Base2`&#125;Derived::`RTTI Complete Object Locator&#x27;&#123;for `Base1`&#125;Base2::`RTTI Complete Object Locator`Base1::`RTTI Complete Object Locator` 每个虚函数表开头都有一个RTTI Complete Object Locator，用于： dynamic_cast类型转换 typeid操作符 异常处理（exception handling） 1234; main代码：mov rax, QWORD PTR tv73[rsp] ; rax = Derived* (新创建的对象)add rax, 8 ; rax += 8 ← 调整到Base2子对象,硬编码mov QWORD PTR pb$[rsp], rax ; 存储到pb (Base2*) 我们再看看用gcc编译的，截取相关： 1234567891011121314151617vtable for Derived: .quad 0 .quad typeinfo for Derived .quad Derived::a() .quad Derived::b() .quad Derived::c() .quad -8 .quad typeinfo for Derived .quad non-virtual thunk to Derived::b()vtable for Base2: .quad 0 .quad typeinfo for Base2 .quad __cxa_pure_virtualvtable for Base1: .quad 0 .quad typeinfo for Base1 .quad __cxa_pure_virtual (太复杂了后面再说) 4. 虚继承是什么虚继承是C++中解决菱形继承问题的一种机制。什么是菱形继承呢？就是两个基类都继承自同一个基类，而派生类又同时继承这两个基类，形成一个菱形的继承结构。在普通继承中，派生类会包含两份最顶层基类的副本，这会导致数据冗余和二义性。 举个例子，如果A是基类，B和C都继承自A，然后D同时继承B和C，那么普通继承下D会包含两份A的副本。当你通过D访问A的成员时，编译器不知道你要访问哪一份，就会报二义性错误。 虚继承通过引入虚基类表（vbtable）和虚基类指针（vbptr），确保在菱形继承结构中，最顶层的基类只有一个实例被共享。使用虚继承时，在继承声明前加上virtual关键字，比如class B : virtual public A。 5. 虚继承类的内存结构虚继承对内存布局的影响比较复杂。在虚继承的情况下，虚基类通常被放置在派生类对象的尾部，而不是按照继承顺序排列。这意味着访问虚基类成员需要通过多次间接寻址。 具体来说，内存布局大致是：派生类数据成员在前，然后是各个非虚基类的数据成员，最后是虚基类的数据成员。每个虚继承的基类都会引入一个虚基类表指针（vbptr），这个指针指向虚基类表，用于存储虚基类在对象中的偏移量。 访问虚基类成员的过程是：首先通过对象的vptr找到虚函数表，然后通过虚基类表指针找到虚基类表，最后通过虚基类表中的偏移量找到虚基类在对象中的实际位置。这种三次间接寻址的设计虽然保证了正确性，但也带来了一定的性能开销。 6. 虚基类表是什么，长什么样虚基类表（vbtable）是虚继承机制中用于存储虚基类偏移量的数据结构。当通过非最终派生类的指针访问虚基类成员时，需要通过虚基类表来找到虚基类在派生类对象中的实际位置。 虚基类表存储的是虚基类相对于当前对象的偏移量信息。不同的继承路径可能需要不同的偏移量，因此虚基类表的存在使得编译器能够在运行时正确计算虚基类的地址。 举个例子，在菱形继承中，如果D继承自B和C，而B和C都虚继承自A，那么B和C各自都会有一个虚基类表，表中存储着A在D对象中的偏移量。当通过B的指针访问A的成员时，编译器会通过B的虚基类表找到A的实际位置。 7. 虚基类表指针是什么，存在哪虚基类表指针（vbptr）是指向虚基类表的指针。这个指针是由编译器为每个虚继承的基类隐式插入的。vbptr的大小和vptr一样，32位系统4字节，64位系统8字节。 vbptr通常存储在虚继承基类子对象的起始位置，但具体位置取决于编译器的实现。在MSVC中，vbptr可能存储在vtable的特定位置；在GCC/Clang中，vbptr可能作为独立的数据成员存储。 每个虚继承的基类都会有自己的vbptr，指向自己的虚基类表。这样设计的好处是，不同的继承路径可以通过各自的虚基类表找到共享的虚基类实例，而不需要知道完整的继承层次结构。 8. 纯虚函数又是什么纯虚函数是一种特殊的虚函数，它只有声明而没有实现，通过在函数声明后添加= 0来标识，比如virtual void func() = 0;。包含纯虚函数的类被称为抽象类，抽象类不能直接实例化对象，只能作为基类存在。 纯虚函数的作用是为派生类提供接口规范，强制派生类必须实现特定的行为。派生类必须实现所有纯虚函数才能成为具体类，才能被实例化。如果派生类没有实现所有纯虚函数，那么派生类仍然是抽象类，无法创建对象。 在基类的虚函数表中，纯虚函数的地址位置通常被设置为nullptr或特定占位值。当尝试调用纯虚函数时，程序会抛出异常或导致未定义行为。这确保了抽象类不能被实例化，因为调用未实现的纯虚函数会导致程序崩溃。 有一个特殊情况：纯虚析构函数必须提供定义，即使它是纯虚的。这是因为即使基类是抽象类，派生类对象销毁时仍需要调用基类的析构函数。如果不提供纯虚析构函数的定义，链接器会报错。 二、各种调用的过程1. 单继承里，虚函数被调用的过程单继承情况下，虚函数调用的过程相对简单。当我们通过基类指针或引用调用虚函数时，编译器首先会获取对象的vptr，这个指针通常位于对象的起始位置。然后通过vptr找到对应的虚函数表，这是一个函数指针数组。 接下来，编译器会根据函数在虚函数表中的偏移量，找到具体的函数地址。这个偏移量是在编译时确定的，因为函数在类中的声明顺序是固定的。最后，通过函数地址进行函数调用。 如果派生类重写了基类的虚函数，那么虚函数表中对应位置的条目会被替换为派生类的函数地址。如果派生类没有重写，那么虚函数表中仍然保留基类的函数地址。调用时，无论哪种情况，都是通过同一个vptr和同一个虚函数表进行查找。 这个调用过程的时间复杂度是O(1)，因为虚函数表是一个数组，函数地址通过编译期确定的偏移量直接访问，只需要一次指针解引用和一次跳转。 2. 多继承里，虚函数被调用的过程多继承情况下，调用过程会复杂一些。派生类对象可能包含多个vptr，分别对应不同的基类。当我们通过某个基类指针调用虚函数时，编译器会使用该基类对应的vptr和虚函数表。 如果派生类重写了某个基类的虚函数，那么该基类的虚函数表中对应位置的条目会被更新。不同的基类可能有不同的虚函数表，即使它们包含相同的虚函数。 当我们使用其中一个基类的指针或引用去指向派生类的对象时，编译器会将这个对象的this指针更新为那个基类的起始地址，也就是那个基类的虚函数表指针那里。这样，调用起基类被重写的虚函数，this就直接访问到相应基类的虚函数表了。 这个this指针的调整是在编译期确定的，offset会被硬编码在指令中。比如前面看到的汇编代码中，add rax, 8就是硬编码的偏移量，将Derived调整为Base2。 3. 虚继承里，虚函数被调用的过程虚继承情况下，调用过程更加复杂。除了虚函数表的查找，还需要考虑虚基类的访问。当我们通过非最终派生类的指针访问虚基类的成员时，编译器需要通过虚基类表来调整this指针。 这个过程包括：首先通过对象的vptr找到虚函数表，然后通过虚基类表指针找到虚基类表，最后通过虚基类表中的偏移量计算虚基类的实际地址。这种三次间接寻址的设计虽然保证了正确性，但也带来了一定的性能开销。 当通过非最终派生类的指针访问虚基类成员时，编译器会自动调整this指针。例如，在D类中访问B的A基类成员时，实际this指针会被调整为指向D对象中A的实例。这种调整是通过虚基类表中的偏移量来实现的，确保访问到正确的虚基类实例。 4. 虚函数表指针的生命周期vptr是在对象构造的期间才被赋值的，在析构的时候被销毁。具体来说，在对象创建前，vptr未初始化；基类构造阶段，vptr指向基类vtable；派生类构造阶段，vptr更新为派生类vtable；对象销毁时，vptr仍指向派生类vtable（直到析构完成）。 这解释了为什么在构造函数中调用虚函数不会跳转到派生类实现，因为此时vptr还没有更新为派生类的vtable。在基类构造函数中，vptr指向基类的虚函数表，因此调用的是基类的虚函数实现。只有当进入派生类构造函数后，vptr才会更新为派生类的虚函数表。 在析构过程中，顺序相反：先执行派生类析构函数，此时vptr仍指向派生类的虚函数表；然后执行基类析构函数，vptr被更新为指向基类的虚函数表。这解释了为什么在析构函数中调用虚函数也不会产生多态行为。 5. 虚基类表指针的生命周期虚基类表指针（vbptr）的生命周期和vptr类似，也是在对象构造期间被赋值，在析构时被销毁。但是虚继承的构造和析构顺序更加复杂，因为需要确保虚基类只被构造一次。 在虚继承的情况下，虚基类的构造由最底层的派生类负责，而不是由中间层的基类负责。这意味着即使B和C都虚继承自A，当D继承B和C时，A的构造只会在D的构造函数中被调用一次，而不是在B和C的构造函数中各调用一次。 vbptr的初始化也是在最底层的派生类构造函数中完成的。编译器会确保虚基类表在访问虚基类成员之前就已经正确设置，这样通过vbptr访问虚基类表时才能找到正确的偏移量。 new：菱形继承里，最底下的那个类的构造过程菱形继承中最底层类的构造过程比较特殊，因为需要确保虚基类只被构造一次。我们用一个典型的例子来说明：A是基类，B和C都虚继承自A，D继承B和C（D是最底层的类）。 构造顺序是这样的：首先构造虚基类A，而且只构造一次。然后按照继承顺序构造B和C，但B和C的构造函数中不会再去构造A，因为A已经在第一步构造好了。最后构造D本身。 具体来说，当创建D的对象时，构造函数的调用顺序是： A的构造函数（虚基类，只调用一次） B的构造函数（跳过A的构造） C的构造函数（跳过A的构造） D的构造函数 这个顺序是由编译器自动安排的，不需要我们手动控制。编译器会确保虚基类A在任何使用它的基类（B和C）之前就已经构造完成。 在构造过程中，vbptr的初始化也很关键。B和C各自的vbptr会在它们的构造函数中被初始化，指向各自的虚基类表。这些虚基类表中存储着A在D对象中的偏移量，使得B和C能够通过各自的vbptr找到共享的A实例。 析构的顺序正好相反：先析构D，然后析构C，再析构B，最后析构A。同样，A只会被析构一次，即使B和C都有析构函数，它们也不会再去析构A，因为A的析构由最底层的D负责。 这种设计确保了在菱形继承中，虚基类只有一个实例，避免了数据冗余和二义性问题。但代价是构造和析构的顺序变得复杂，而且访问虚基类成员需要通过额外的间接寻址。 6. 构造函数和析构函数中调用虚函数的行为在构造函数和析构函数中调用虚函数不会产生多态行为，而是静态绑定到当前构造或析构阶段的类版本。这是因为对象类型在构造和析构过程中被视为”不完整”。 构造时，派生类部分尚未构造完成，无法保证其虚函数的正确性。析构时，派生类部分已经销毁，其虚函数可能无法安全调用。C++标准明确禁止在构造/析构函数中通过动态绑定调用虚函数，这是为了确保对象状态的一致性。 如果必须在构造或析构过程中使用多态行为，可以考虑使用初始化函数模式：在对象完全构造后调用一个初始化函数，此时对象已经完整，可以安全地调用虚函数。但一般来说，应该避免在构造函数和析构函数中调用虚函数。 虚继承在C++面向对象编程中，虚继承（virtual inheritance）是一种解决多重继承问题的高级机制，特别是针对菱形继承问题。本文将深入解析虚继承的底层实现原理，包括虚基类表、虚基类表指针的定义、产生时机、生命周期，以及虚继承类对象的构造过程，特别是菱形继承结构中底层类的构造顺序，同时分析通过不同基类调用派生类虚函数的实现机制。通过这些底层原理的剖析，我们可以更好地理解C++虚继承的工作方式及其在实际应用中的影响。 一、虚基类表(vbtable)与虚基类表指针(vbptr)机制 1. 虚基类表(vbtable)的定义与作用 虚基类表是C++编译器为支持虚继承而自动生成的一种数据结构。它的核心功能是存储虚基类子对象在派生类对象中的偏移地址。在标准的Itanium C++ ABI中，每个虚基类表包含以下信息： 虚基类的类型信息：标识该虚基类的类型 虚基类子对象的偏移地址：记录虚基类子对象在最终派生类对象中的相对位置 虚函数表指针：指向最终派生类中覆盖虚基类虚函数的虚函数表 2. 虚基类表(vbtable)的产生时机与生命周期 虚基类表的产生和生命周期遵循以下规则： 产生时机：当且仅当一个类使用virtual关键字继承某个基类时，编译器才会为该继承关系生成对应的虚基类表。例如在以下代码中： 123class A &#123; /* ... */ &#125;;class B : virtual public A &#123; /* ... */ &#125;; // B继承A为虚基类class C : public B &#123; /* ... */ &#125;; // C继承B，此时B的虚基类A也会影响C的内存布局 编译器会在编译阶段为B生成一个虚基类表。 生命周期：虚基类表是静态存储的，其生命周期与整个程序一致。这些表在程序加载时被初始化，驻留在只读内存区域，所有对象共享同一份虚基类表数据。当对象被创建或销毁时，不会影响虚基类表的存在，它只在对象构造和析构时被引用以确定虚基类子对象的位置。 3. 虚基类表指针(vbptr)的定义与作用 虚基类表指针是虚继承机制的关键实现组件。每个虚继承的子类（如上述代码中的B）都会包含一个指向其虚基类表的指针成员，称为vbptr（virtual base pointer）。 存储位置：vbptr作为隐式成员存储在虚继承的子类对象中。例如，类B的对象布局会包含一个指向A的虚基类表的vbptr。 核心功能：vbptr存储虚基类表的地址，通过该地址可以查询到虚基类子对象在最终派生类中的偏移量，从而正确地访问虚基类的成员。 4. 虚基类表指针(vbptr)的构造时机与生命周期 构造时机：vbptr在对象构造过程中被初始化。在虚继承的类层次中，只有最底层的派生类负责设置所有虚基类的vbptr。例如，在菱形继承结构中： 1234class A &#123; /* ... */ &#125;;class B : virtual public A &#123; /* ... */ &#125;;class C : virtual public A &#123; /* ... */ &#125;;class D : public B, public C &#123; /* ... */ &#125;; // 最底层派生类 当构造D对象时，D的构造函数会初始化B和C中的vbptr，指向正确的虚基类表。而B和C的构造函数本身不会初始化自己的vbptr，因为虚基类的初始化责任已经被转移到了最底层派生类。 生命周期：vbptr的生命周期与包含它的对象完全一致。它在对象构造时被初始化，指向正确的虚基类表；在对象析构时，随着对象内存的释放而失效。值得注意的是，即使虚基类本身没有虚函数，只要存在虚继承关系，编译器也会为该继承路径生成vbptr和对应的虚基类表。 二、虚继承类对象的构造过程 1. 虚继承对象的构造顺序 虚继承类对象的构造遵循严格的顺序规则，这是确保虚基类正确共享的关键： 虚基类优先构造：首先构造所有虚基类，按照它们在继承层次中被声明的顺序进行。 非虚基类按声明顺序构造：然后构造非虚基类，同样按照它们在继承列表中声明的顺序。 成员对象按声明顺序构造：接下来构造派生类中声明的成员对象，按照它们在类体中声明的顺序。 派生类自身构造：最后执行派生类自身的构造函数。 构造顺序示例：考虑以下继承结构： 1234class A &#123; /* ... */ &#125;;class B : virtual public A &#123; /* ... */ &#125;;class C : virtual public A &#123; /* ... */ &#125;;class D : public B, public C &#123; /* ... */ &#125;; 构造D对象的顺序为：A → B → C → D的成员 → D自身的构造函数。 2. 虚基类初始化权的转移 在虚继承结构中，虚基类的初始化责任被转移到了最底层派生类。这是虚继承区别于普通继承的关键特性： 在普通继承中，中间派生类（如B和C）负责初始化它们直接继承的基类（如A）。 在虚继承中，中间派生类不再初始化其虚基类，而是由最底层派生类（如D）统一初始化所有虚基类。这意味着在D的构造函数初始化列表中，必须显式调用所有虚基类的构造函数，否则会导致编译错误。 例如，D的构造函数必须显式初始化A： 1234class D : public B, public C &#123;public: D() : A(), B(), C() &#123; /* ... */ &#125; // 必须显式初始化A&#125;; 3. 虚基类表指针(vbptr)的初始化过程 在构造过程中，vbptr的初始化是确保虚基类正确共享的关键步骤： 当构造最底层派生类（如D）时，编译器会首先为所有虚基类（如A）分配内存空间并执行构造。 然后，编译器会计算每个虚基类子对象相对于最终派生类对象的偏移量。 接着，编译器会为每个虚继承的中间类（如B和C）初始化其vbptr，使其指向包含正确偏移量的虚基类表。 最后，当构造非虚基类（如B和C）时，它们的虚函数表指针（vptr）会被设置为指向最终派生类中的虚函数表，以确保虚函数的正确动态绑定。 4. 菱形继承结构中的构造过程 菱形继承（Diamond Inheritance）是C++中典型的多重继承场景，也是虚继承的主要应用场景： 12345 A / \\B C \\ / D 在菱形继承结构中，若没有使用虚继承，D对象将包含A的两个独立副本，导致数据冗余和访问歧义。通过在中间层使用虚继承，可以确保D中仅保留一个A实例： 1234class A &#123; /* ... */ &#125;;class B : virtual public A &#123; /* ... */ &#125;; // 虚继承class C : virtual public A &#123; /* ... */ &#125;; // 虚继承class D : public B, public C &#123; /* ... */ &#125;; // 底层派生类 D对象的构造过程如下： 首先构造虚基类A。 然后构造B，此时B的vbptr被设置为指向包含A偏移量的虚基类表。 接着构造C，其vbptr同样指向虚基类表，但由于A已经被构造，C的A子对象不会被再次构造。 最后构造D的成员对象和执行D自身的构造函数。 内存布局示例：D对象的典型内存布局为： 123456[ B的vbptr ] → 指向B的虚基类表[ B的成员变量 ][ C的vbptr ] → 指向C的虚基类表[ C的成员变量 ][ D的成员变量 ][ A的成员变量 ] → 虚基类A的共享实例 虚基类A的成员变量位于对象的末尾，通过B和C的vbptr指向的虚基类表中的偏移信息，可以正确访问该共享实例。 三、虚函数调用机制与this指针调整 1. 虚函数表(vtable)与虚函数指针(vptr)的关系 在C++中，虚函数的多态性通过虚函数表和虚函数指针实现： **虚函数表(vtable)**：每个包含虚函数的类都有一个或多个虚函数表，存储该类中所有虚函数的地址。 **虚函数指针(vptr)**：每个对象包含一个指向其类虚函数表的指针，用于动态绑定到正确的函数实现。 在虚继承结构中，虚函数表和虚函数指针的管理更为复杂： 每个虚继承的中间类（如B和C）都包含一个vptr，指向自己的虚函数表。 最底层派生类（如D）的虚函数表会覆盖所有继承路径上的虚函数实现。 当通过中间基类（如B或C）的指针调用虚函数时，需要调整this指针以指向正确的虚函数表。 2. this指针调整技术 在虚继承结构中，this指针调整（this pointer adjustment） 是确保正确虚函数调用的关键机制： thunk技术：当通过一个中间基类（如B）的指针调用虚函数时，编译器会生成一个短小的适配代码段（称为thunk），负责调整this指针，使其指向最终派生类对象的正确位置。 例如，考虑以下继承结构： 12345678910111213141516171819class A &#123;public: virtual void func() &#123; /* ... */ &#125;&#125;;class B : virtual public A &#123;public: virtual void func() override &#123; /* ... */ &#125;&#125;;class C : virtual public A &#123;public: virtual void func() override &#123; /* ... */ &#125;&#125;;class D : public B, public C &#123;public: virtual void func() override &#123; /* ... */ &#125;&#125;; 当通过B*指针调用func()时，实际调用的路径如下： 首先通过B的vptr找到B的虚函数表。 若D重写了func()，则B的虚函数表中存储的不是B::func的地址，而是一个指向thunk的指针。 thunk代码执行后，会将this指针调整为指向D对象的正确位置。 调整后的this指针被用来访问D的虚函数表，最终调用D::func()。 3. 菱形继承中虚函数调用的路径分析 在菱形继承结构中，虚函数调用的路径分析如下： 通过虚基类（A）调用：当通过A*指针调用D的虚函数时，由于A是虚基类，其虚函数表已被D覆盖。因此，调用会直接跳转到D的虚函数实现，无需this指针调整。 通过中间基类（B或C）调用：当通过B或C指针调用D的虚函数时，需要执行以下步骤： 根据当前指针类型（B或C）找到对应的虚函数表。 通过虚函数表中的条目找到对应的thunk代码。 thunk代码通过虚基类表中的偏移信息，计算出D对象中A子对象的正确地址。 将this指针调整为指向该地址后，再通过调整后的this指针访问D的虚函数表。 最终调用D中覆盖的虚函数实现。 4. 虚继承与虚函数的内存开销 虚继承和虚函数都会引入额外的内存开销： 空间开销： 每个虚继承的中间类（如B和C）需要额外的vbptr存储空间（通常是4或8字节）。 虚基类表和虚函数表是静态存储的，驻留在只读内存区域，不占用对象空间。 在最终派生类中，虚基类的成员变量仅存储一次，减少了内存占用。 时间开销： 访问虚基类成员需要三次间接寻址：首先通过vptr找到虚函数表，再通过虚函数表找到thunk，最后通过thunk找到最终派生类的虚函数表。 构造和析构过程中需要执行复杂的虚基类初始化和this指针调整逻辑。 虚继承的构造顺序管理比普通继承更复杂，增加了编译时和运行时的开销。 四、实际案例分析 1. 菱形继承构造过程示例 考虑以下菱形继承结构： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;class Base &#123;public: Base(int x) : value(x) &#123; std::cout &lt;&lt; &quot;Base构造: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;class A : public Base &#123;public: A(int x) : Base(x) &#123;&#125; virtual void show() &#123; std::cout &lt;&lt; &quot;A::show&quot; &lt;&lt; std::endl; &#125;&#125;;class B : virtual public A &#123;public: B(int x) : A(x) &#123;&#125; virtual void show() override &#123; std::cout &lt;&lt; &quot;B::show&quot; &lt;&lt; std::endl; &#125;&#125;;class C : virtual public A &#123;public: C(int x) : A(x) &#123;&#125; virtual void show() override &#123; std::cout &lt;&lt; &quot;C::show&quot; &lt;&lt; std::endl; &#125;&#125;;class D : public B, public C &#123;public: D(int x) : A(x), B(x), C(x) &#123;&#125; virtual void show() override &#123; std::cout &lt;&lt; &quot;D::show&quot; &lt;&lt; std::endl; &#125;&#125;; 2. 虚函数调用示例 通过不同基类指针调用D的虚函数： A* a = new D(1); a-&gt;show(); → 输出”D::show” B* b = new D(1); b-&gt;show(); → 输出”D::show” C* c = new D(1); c-&gt;show(); → 输出”D::show” 3. this指针调整的实现机制 在上述案例中，当通过B*指针调用D的show()函数时，实际的底层实现如下： 123456789101112// 假设B的虚函数表中存储的是以下内容// B的虚函数表：// [0] = B的析构函数地址// [1] = B::show的地址 → 实际是一个thunk指针// B::show的thunk实现（伪代码）：void B::show_thunk(A* this调整) &#123; // 计算D对象中A子对象的正确地址 A* correctThis = this调整 + 虚基类表中的偏移量; // 调用D实际的show函数 D::show(correctThis);&#125; 通过这种thunk技术，编译器能够确保无论通过哪个基类指针调用，最终都能正确地调用到派生类的虚函数实现。 五、虚继承的优化与权衡 1. 虚继承的适用场景 虚继承虽然强大，但应谨慎使用，仅在以下场景中考虑： 解决菱形继承问题：当一个类需要同时继承多个继承自同一基类的中间类时，使用虚继承可以避免数据冗余和访问歧义。 接口继承：当多个中间类需要继承同一接口基类时，使用虚继承可以确保最终派生类只保留一个接口实现。 共享基类状态：当多个继承路径需要共享同一基类的状态时，虚继承提供了这一机制。 2. 虚继承的性能优化建议 为减少虚继承带来的性能开销，可考虑以下优化： 避免不必要的虚继承：仅在真正需要解决菱形继承问题时使用虚继承。 使用接口类：将虚基类设计为不包含数据成员的纯接口类，减少内存占用。 减少虚函数调用频率：将频繁调用的虚函数改为非虚函数，或通过其他方式（如模板或策略模式）实现多态。 合理设计继承层次：避免过深的虚继承层次，减少this指针调整的复杂度。 3. 虚继承与组合模式的比较 在解决类似问题时，组合模式（Composition）可以作为虚继承的替代方案： 12345678910111213141516171819202122232425262728// 虚继承方案class A &#123; /* ... */ &#125;;class B : virtual public A &#123; /* ... */ &#125;;class C : virtual public A &#123; /* ... */ &#125;;class D : public B, public C &#123; /* ... */ &#125;;// 组合方案class A &#123; /* ... */ &#125;;class B &#123;public: B(A* a) : a(a) &#123; /* ... */ &#125;private: A* a;&#125;;class C &#123;public: C(A* a) : a(a) &#123; /* ... */ &#125;private: A* a;&#125;;class D &#123;public: D(int x) : a(x), b(&amp;a), c(&amp;a) &#123; /* ... */ &#125;private: A a; B b; C c;&#125;; 组合模式避免了虚继承的内存和时间开销，但牺牲了部分面向对象的特性（如类型转换和多态继承）。在性能敏感的场景中，组合模式可能是更优选择。 六、总结 虚继承是C++中解决多重继承问题的重要机制，其核心实现依赖于虚基类表（vbtable）和虚基类表指针（vbptr）。虚基类表是静态存储的只读数据结构，存储虚基类子对象的偏移信息；而虚基类表指针是对象的隐式成员，指向对应的虚基类表。虚基类表指针的生命周期与对象一致，但其初始化责任被转移到了最底层派生类。 虚继承类对象的构造遵循严格的顺序规则：虚基类优先构造，非虚基类按声明顺序构造，成员对象按声明顺序构造，最后执行派生类自身的构造函数。最底层派生类负责初始化所有虚基类，并设置中间基类的vbptr。 在菱形继承结构中，虚函数调用的正确性依赖于this指针调整机制。编译器通过生成thunk代码，根据虚基类表中的偏移信息，修正this指针指向，确保无论通过哪个基类指针调用，最终都能正确地动态绑定到派生类的虚函数实现。 虚继承虽然解决了数据冗余和访问歧义问题，但也带来了额外的内存和时间开销。在实际应用中，应根据具体需求权衡虚继承的语义优势与性能开销，必要时考虑组合模式等替代方案。","tags":["C++","面向对象"]},{"title":"位运算小甜品","path":"/2026/01/27/位运算小甜品/","content":"位运算作为计算机最底层的操作之一，其高效性源于直接对整数的二进制表示进行操作。在C++编程中，巧妙运用位运算往往能显著提升算法性能、简化代码逻辑，特别是在处理集合操作、状态压缩和性能敏感场景时表现突出。 我一直觉得位运算是个很有意思的话题。它连接了高级算法思维与计算机底层实现，掌握这些技巧不仅能够编写出更高效的代码，更能深化对计算机系统工作原理的理解。今天就来聊聊位运算的一些实用技巧。 位运算的基础原理与核心操作位运算直接操作整数的二进制位，每个操作都有其特定的数学含义。这些操作之所以高效，是因为它们通常被编译为单条机器指令，直接在CPU的寄存器级别完成运算。 先来看看几个基础操作： **按位与(&amp;)**：两个位都为1时结果才为1，常用于掩码操作。比如判断一个数的奇偶性，用n &amp; 1就能直接获取最低位。 **按位或(|)**：两个位中有一个为1时结果就为1，常用于设置特定位。在状态压缩中，我们可以用set |= (1 &lt;&lt; i)来添加元素。 **按位异或(^)**：两个位不同时结果为1，相同则为0，具有”开关切换”特性。这个特性很有意思，后面会看到它的妙用。 **按位取反(~)**：将所有位取反，0变1，1变0。配合其他操作使用，比如删除集合中的元素可以用set &amp;= ~(1 &lt;&lt; i)。 **左移(&lt;&lt;)**：将所有位向左移动，右侧补0，相当于乘以2的幂。n &lt;&lt; k就是n * 2^k，但效率更高。 **右移(&gt;&gt;)**：将所有位向右移动，左侧补符号位（算术右移）或0（逻辑右移），相当于除以2的幂。n &gt;&gt; k就是n / 2^k。 数值属性的快速判断技巧利用位运算可以在常数时间内完成某些数学属性的判断，这比传统的数学运算要快得多。 奇偶性检测判断一个数是奇数还是偶数，最直接的方法是n % 2 == 0。但用位运算会更高效： 123bool isEven(int n) &#123; return (n &amp; 1) == 0;&#125; 这个方法的原理很简单：任何整数的二进制表示中，最低位决定了它的奇偶性。通过与操作n &amp; 1，我们能够直接访问最低位，无需进行耗时的模运算。这种方法的效率优势在循环遍历或频繁判断的场景中尤为明显。 2的幂次方判断判断一个数是否是2的幂次方，有个很巧妙的技巧： 123bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125; 这个表达式利用了2的幂次方的数学性质：对于2的幂，其二进制表示有且仅有一个1。当n为2的幂时，n-1会将那个唯一的1及其后的所有位翻转，使得按位与的结果为0。 举个例子，8的二进制是1000，7的二进制是0111，两者相与结果为0000。而6的二进制是0110，5的二进制是0101，相与结果为0100，不为0。 高效位操作技巧集锦最低位1的提取（lowbit操作）这是许多高级算法的基础，比如树状数组（Fenwick Tree）： 123int lowbit(int n) &#123; return n &amp; (-n);&#125; 这个操作利用了补码表示中负数的特性：负数是原数按位取反再加1。表达式n &amp; (-n)能够快速分离出最低位的1及其后面的0。 比如12的二进制是1100，-12的二进制是0100（在补码表示中），两者相与得到0100，正好是最低位的1。 1的个数统计统计一个数二进制表示中1的个数，有个很经典的算法叫Brian Kernighan算法： 12345678int countOnes(int n) &#123; int count = 0; while (n) &#123; n &amp;= (n - 1); // 移除最低位的1 count++; &#125; return count;&#125; n &amp;= (n - 1)操作能够巧妙地移除最低位的1。重复此操作直到n变为0，操作次数即为原数中1的个数。这种方法的时间复杂度与1的个数成正比，在稀疏二进制数中特别高效。 无临时变量的交换这个技巧体现了异或运算的自反性质： 12345void swap(int&amp; a, int&amp; b) &#123; a ^= b; b ^= a; a ^= b;&#125; 通过三次异或操作，可以在不使用额外内存的情况下交换两个变量。虽然现代编译器的优化可能减少了这种技巧的实际必要性，但它仍然是理解位运算特性的绝佳示例。 原理很简单：a ^ b的结果包含了a和b的所有差异信息。第一次异或后，a变成了a ^ b；第二次异或后，b变成了b ^ (a ^ b) = a；第三次异或后，a变成了(a ^ b) ^ a = b。 状态压缩与集合操作位运算在状态压缩领域展现出巨大威力。使用整数作为位掩码，可以将一个大小为n的布尔数组压缩到n个比特中，不仅节省空间，而且集合操作可以直接转换为位运算，效率极高。 集合的位表示法我们可以用一个整数来表示一个集合，每一位代表一个元素是否存在： 123456789101112131415int set = 0; // 空集合// 添加元素iset |= (1 &lt;&lt; i);// 删除元素iset &amp;= ~(1 &lt;&lt; i);// 判断元素i是否在集合中bool contains = (set &gt;&gt; i) &amp; 1;// 集合的交、并、差运算int intersection = set1 &amp; set2;int union_set = set1 | set2;int difference = set1 &amp; ~set2; 这种表示法不仅节省空间，而且集合的交、并、差运算可以直接转换为&amp;、|、&amp; ~操作，效率极高。 子集遍历技巧枚举一个集合的所有子集，有个很高效的技巧： 1234567int set = 0b1011; // 假设有4个元素，当前集合是&#123;0, 1, 3&#125;int subset = set;do &#123; // 处理当前子集subset // ... subset = (subset - 1) &amp; set;&#125; while (subset != set); 通过subset = (subset - 1) &amp; set循环，可以无重复地遍历集合的所有子集。这个技巧在状态空间搜索、动态规划等算法中应用广泛，将指数级问题的实现变得简洁高效。 算术运算的位级优化位运算可以实现某些算术运算的替代方案，有时能获得更好的性能。 2的幂次乘除这是位运算最常见的优化场景： 1234567int multiplyByPowerOfTwo(int n, int k) &#123; return n &lt;&lt; k; // n * 2^k&#125;int divideByPowerOfTwo(int n, int k) &#123; return n &gt;&gt; k; // n / 2^k&#125; 这些操作不仅避免了乘除法指令的开销，而且意图更明确，代码更简洁。不过需要注意的是，右移对于负数来说是算术右移，结果可能和预期不同。 平均值计算的位运算方法计算两个数的平均值，有个巧妙的位运算方法可以避免整数溢出： 123int average(int a, int b) &#123; return (a &amp; b) + ((a ^ b) &gt;&gt; 1);&#125; 这个方法巧妙地避免了整数溢出的风险。前半部分a &amp; b提取了需要进位的位置，后半部分(a ^ b) &gt;&gt; 1计算了不需要进位的部分除以2。这种方法的正确性基于二进制加法的进位原理。 异或运算的巧妙应用异或运算有几个很有意思的性质，在LeetCode中经常用到。 找唯一数字当数组中只有一个数字出现一次，其他数字都出现两次时，可以用异或快速找出这个唯一数字： 1234567int findSingle(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int num : nums) &#123; result ^= num; &#125; return result;&#125; 原理很简单：异或满足交换律和结合律，而且a ^ a = 0，a ^ 0 = a。所以所有出现两次的数字异或后都变成0，最后剩下的就是那个唯一出现一次的数字。 这个技巧在LeetCode中非常经典，是很多位运算题目的基础。 条件交换有时候我们需要根据条件交换两个变量的值，用异或可以写得很简洁： 1234// 如果x等于a，则x变为b；如果x等于b，则x变为avoid conditionalSwap(int&amp; x, int a, int b) &#123; x = a ^ b ^ x;&#125; 这个技巧利用了异或的自反性质。当x == a时，a ^ b ^ a = b；当x == b时，a ^ b ^ b = a。在某些特定场景下，这种写法比if-else更简洁。 更多实用的位操作技巧提取最高位的1有时候我们需要找到最高位的1，这在某些算法中很有用： 123456789101112131415161718int highestBit(int n) &#123; // 方法1：不断右移直到为0 int pos = 0; while (n) &#123; n &gt;&gt;= 1; pos++; &#125; return pos - 1; // 方法2：使用位运算技巧（需要知道位数） // 假设是32位整数 n |= n &gt;&gt; 1; n |= n &gt;&gt; 2; n |= n &gt;&gt; 4; n |= n &gt;&gt; 8; n |= n &gt;&gt; 16; return (n + 1) &gt;&gt; 1;&#125; 第二种方法通过不断将最高位的1向右”扩散”，最终得到一个只有最高位为1的数，然后再右移一位加1，就能得到最高位的值。这个方法在常数时间内完成，但需要知道整数的位数。 位掩码的翻转操作除了设置和清除，翻转操作也很有用： 12345678910111213int mask = 1 &lt;&lt; i; // 第i位的掩码// 翻转第i位：原来是0变成1，原来是1变成0n ^= mask;// 判断第i位是否为1bool isSet = (n &amp; mask) != 0;// 将第i位设置为1n |= mask;// 将第i位清除为0n &amp;= ~mask; 翻转操作在状态切换、权限管理、游戏状态等场景中经常用到。比如一个开关，每次操作都要翻转状态，用异或就非常方便。 n倍数补全（向上取整到2的幂）有时候我们需要将一个数向上取整到最近的2的幂次方： 12345678910int roundUpToPowerOfTwo(int n) &#123; if (n &lt;= 0) return 1; n--; n |= n &gt;&gt; 1; n |= n &gt;&gt; 2; n |= n &gt;&gt; 4; n |= n &gt;&gt; 8; n |= n &gt;&gt; 16; return n + 1;&#125; 这个技巧和提取最高位的方法类似，通过”扩散”操作将所有低位都设置为1，然后加1就能得到大于等于原数的最小2的幂。这在内存对齐、哈希表大小设置等场景中很有用。 反转二进制位有时候我们需要反转一个整数的所有二进制位： 12345678uint32_t reverseBits(uint32_t n) &#123; n = ((n &amp; 0x55555555) &lt;&lt; 1) | ((n &amp; 0xAAAAAAAA) &gt;&gt; 1); // 交换相邻的1位 n = ((n &amp; 0x33333333) &lt;&lt; 2) | ((n &amp; 0xCCCCCCCC) &gt;&gt; 2); // 交换相邻的2位 n = ((n &amp; 0x0F0F0F0F) &lt;&lt; 4) | ((n &amp; 0xF0F0F0F0) &gt;&gt; 4); // 交换相邻的4位 n = ((n &amp; 0x00FF00FF) &lt;&lt; 8) | ((n &amp; 0xFF00FF00) &gt;&gt; 8); // 交换相邻的8位 n = ((n &amp; 0x0000FFFF) &lt;&lt; 16) | ((n &amp; 0xFFFF0000) &gt;&gt; 16); // 交换相邻的16位 return n;&#125; 这个方法采用了分治的思想，从交换相邻的1位开始，逐步扩大交换范围，最终完成整个32位的反转。虽然看起来复杂，但每一步都是简单的位操作，效率很高。 分治法统计1的个数除了Brian Kernighan算法，还有一种分治的方法在某些场景下更高效： 12345678int countOnes(uint32_t n) &#123; n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555); // 每2位统计1的个数 n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); // 每4位统计1的个数 n = (n &amp; 0x0F0F0F0F) + ((n &gt;&gt; 4) &amp; 0x0F0F0F0F); // 每8位统计1的个数 n = (n &amp; 0x00FF00FF) + ((n &gt;&gt; 8) &amp; 0x00FF00FF); // 每16位统计1的个数 n = (n &amp; 0x0000FFFF) + ((n &gt;&gt; 16) &amp; 0x0000FFFF); // 每32位统计1的个数 return n;&#125; 这个方法通过分治的思想，将统计1的个数的问题逐步分解。每一步都将相邻的位组合起来，统计它们的1的个数之和。最终得到整个32位数中1的总数。这种方法虽然代码看起来复杂，但在某些CPU架构上可能比循环方法更快。 总结位运算的这些技巧就像小甜品，这些技巧在位运算题目中经常出现，不过也要注意，虽然位运算很高效，但在普通业务逻辑中过度使用可能会损害代码的可读性。毕竟，代码是写给人看的，偶尔才是给机器执行的。这些”小甜品”虽然不能当主食，但偶尔尝一尝，还是挺有意思。","tags":["C++"]},{"title":"new和delete（一）new与构造函数与各种初始化大乱炖","path":"/2026/01/26/new和delete/","content":"还是得勇敢直面我不会的东西。 上一篇整理了一些malloc和free相关的知识点。今天主要来看new和delete。 问起new和delete，我目前能说出来的有以下这些：new操作是在malloc申请到内存后，在申请到的内存上去调用对象的构造函数去构造对象（对于new一个自定义类型是这样的），其他细节暂不清楚。new操作失败会抛出异常，但是申请内存失败抛出的异常还是构造函数失败抛出的异常暂不清楚。new一个内置类型的过程暂不清楚（没有构造函数可调用）。new[]这种new一个数组的过程也很模糊。delete就更模糊了，只知道new和delete最好成对调用，new[]和delete[]也要成对调用。 下面的一些代码使用了https://gcc.godbolt.org/的compiler explorer，编译器版本为： x64 msvc v19.latest 所以，汇编的代码可不是AI生成的，只是让AI帮忙解读而已。实验结果都是运行过的，并非AI生成的。所以可信！ 问题一：new操作的本质简单写了一个类，成员变量是一个int变量和一个string变量： 12345678910111213141516// Type your code here, or load an example.#include &lt;string&gt;class A&#123; public: int count; std::string name; A()=default; ~A()=default;&#125;;int main()&#123; A* a1=new A();&#125; 编译出来的汇编代码长这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546this$ = 48A::A(void) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+8], rcx sub rsp, 40 ; 00000028H mov rax, QWORD PTR this$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rsp, 40 ; 00000028H ret 0A::A(void) ENDP ; A::A$T1 = 32tv70 = 40a1$ = 48main PROC$LN5: push rdi sub rsp, 64 ; 00000040H mov ecx, 40 ; 00000028H call void * operator new(unsigned __int64) ; operator new mov QWORD PTR $T1[rsp], rax cmp QWORD PTR $T1[rsp], 0 je SHORT $LN3@main mov rdi, QWORD PTR $T1[rsp] xor eax, eax mov ecx, 40 ; 00000028H rep stosb mov rcx, QWORD PTR $T1[rsp] call A::A(void) ; A::A mov QWORD PTR tv70[rsp], rax jmp SHORT $LN4@main$LN3@main: mov QWORD PTR tv70[rsp], 0$LN4@main: mov rax, QWORD PTR tv70[rsp] mov QWORD PTR a1$[rsp], rax xor eax, eax add rsp, 64 ; 00000040H pop rdi ret 0main ENDP 一点点来看，首先来看main函数里的流程：（读汇编代码美美交给AI来看） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889; ==============================================; 符号定义：main 函数中的局部变量偏移量; ==============================================$T1 = 32 ; 临时变量1：存储 operator new 返回的原始指针tv70 = 40 ; 临时变量2：存储构造函数调用后的结果指针a1$ = 48 ; 局部变量 a1 在栈上的位置; ==============================================; main 函数; ==============================================main PROC ; 开始 main 函数$LN5: ; 标签：代码块开始 ; 保存寄存器（遵循调用约定） push rdi ; 保存 rdi 寄存器（调用者保存寄存器） ; 设置栈帧 sub rsp, 64 ; 在栈上分配 64 字节空间 ; ====================================== ; 步骤1：调用 operator new 分配内存 ; ====================================== mov ecx, 40 ; 设置参数：要分配的大小 = 40 字节 ; ecx = sizeof(A) = sizeof(int) + padding + sizeof(std::string) ; = 4 + 4 + 32 = 40 call void * operator new(unsigned __int64) ; 调用 operator new 函数 ; 保存分配的内存地址 mov QWORD PTR $T1[rsp], rax ; 将返回值（内存地址）保存到栈上 $T1 位置 ; ====================================== ; 步骤2：检查内存分配是否成功 ; ====================================== cmp QWORD PTR $T1[rsp], 0 ; 比较分配结果是否为 NULL je SHORT $LN3@main ; 如果为 NULL（分配失败），跳转到失败处理 ; ====================================== ; 步骤3：分配成功，清零分配的内存（零初始化） ; ====================================== mov rdi, QWORD PTR $T1[rsp] ; rdi = 目标地址（将要清零的内存起始位置） xor eax, eax ; eax = 0（要填充的值） ; xor eax, eax 比 mov eax, 0 更快 mov ecx, 40 ; ecx = 计数器（要清零的字节数 = 40） rep stosb ; 重复执行：将 al(0) 存储到 [rdi]，然后 rdi++ ; 等价于 memset(ptr, 0, 40) ; 这是零初始化：因为使用了 new A() 而不是 new A ; ====================================== ; 步骤4：在清零的内存上调用构造函数 ; ====================================== mov rcx, QWORD PTR $T1[rsp] ; 将原始指针放入 rcx（构造函数参数 this） call A::A(void) ; 调用构造函数 A::A() ; 注意：构造函数只初始化了 std::string ; int count 已经在步骤3中被清零为0 ; 保存构造函数返回的 this 指针 mov QWORD PTR tv70[rsp], rax ; 将构造函数返回值（this）保存到栈上 ; 跳转到成功路径的合并点 jmp SHORT $LN4@main ; 无条件跳转到 $LN4@main ; ======================================; 分支：内存分配失败的处理; ======================================$LN3@main: ; 标签：分配失败 mov QWORD PTR tv70[rsp], 0 ; 设置结果为 NULL 指针 ; ======================================; 合并点：成功和失败路径的汇合处; ======================================$LN4@main: ; 标签：代码合并点 ; 将结果赋值给局部变量 a1 mov rax, QWORD PTR tv70[rsp] ; 从栈上加载结果到 rax mov QWORD PTR a1$[rsp], rax ; 保存到局部变量 a1 ; 设置 main 函数返回值 xor eax, eax ; eax = 0（main 函数返回 0） ; 清理栈帧并恢复寄存器 add rsp, 64 ; 释放栈上分配的 64 字节空间 pop rdi ; 恢复 rdi 寄存器 ; 函数返回 ret 0 ; 从 main 函数返回main ENDP ; main 函数结束 看下来这个步骤很清晰。见到了一个调用 operator new 函数,其实也就是new这个运算符的实现。 下面摘自new 和 delete 运算符 | Microsoft Learn new 运算符编译器将如下语句转换为对函数 operator new 的调用： C++ 1char *pch = new char[BUFFER_SIZE]; 如果请求的存储空间为零字节，**operator new** 将返回指向不同对象的指针。 也就是说，重复调用 operator new 会返回不同的指针。 如果分配请求的内存不足，**operator new** 会引发 std::bad_alloc 异常。 或者，如果使用了 placement 形式 nullptr，或者链接在非引发的 支持中，它将返回 new(std::nothrow)。operator new 有关详细信息，请参阅分配失败行为。 下表中描述了 operator new 函数的两个范围。 operator new 函数的范围 运算符 Scope ::operator new 全局 class-name**::operator new** 类 operator new 的第一个自变量必须为 size_t 类型，且返回类型始终为 **void\\***。 在使用 operator new 运算符分配内置类型的对象、不包含用户定义的 new 函数的类类型的对象和任何类型的数组时，将调用全局 operator new 函数。 在使用 new 运算符分配类类型的对象时（其中定义了 **operator new**），将调用该类的 **operator new**。 为类定义的 operator new 函数是静态成员函数（不能是虚函数），该函数隐藏此类类型的对象的全局 operator new 函数。 考虑 new 用于分配内存并将内存设为给定值的情况： C++ 123456789101112131415161718192021222324#include &lt;malloc.h&gt;#include &lt;memory.h&gt;class Blanks&#123;public: Blanks()&#123;&#125; void *operator new( size_t stAllocateBlock, char chInit );&#125;;void *Blanks::operator new( size_t stAllocateBlock, char chInit )&#123; void *pvTemp = malloc( stAllocateBlock ); if( pvTemp != 0 ) memset( pvTemp, chInit, stAllocateBlock ); return pvTemp;&#125;// For discrete objects of type Blanks, the global operator new function// is hidden. Therefore, the following code allocates an object of type// Blanks and initializes it to 0xa5int main()&#123; Blanks *a5 = new(0xa5) Blanks; return a5 != 0;&#125; 用括号包含的提供给 new 的自变量将作为 Blanks::operator new 自变量传递给 chInit。 但是，全局 operator new 函数将被隐藏，从而导致以下代码生成错误： C++ 1Blanks *SomeBlanks = new Blanks; 编译器在类声明中支持成员数组 new 和 delete 运算符。 例如： C++ 1234567891011121314151617class MyClass&#123;public: void * operator new[] (size_t) &#123; return 0; &#125; void operator delete[] (void*) &#123; &#125;&#125;;int main()&#123; MyClass *pMyClass = new MyClass[5]; delete [] pMyClass;&#125; 分配失败行为C++ 标准库中的 new 函数支持自 C++98 以来在 C++ 标准中指定的行为。 如果分配请求的内存不足，**operator new** 会引发 std::bad_alloc 异常。 较旧的 C++ 代码会为失败的分配返回 null 指针。 如果你的代码需要非引发版本的 **new**，请将程序链接到 *nothrownew.obj*。 nothrownew.obj 文件将全局 operator new 替换为分配失败时返回 nullptr 的版本。 operator new 不再引发 std::bad_alloc。 有关 nothrownew.obj 和其他链接器选项文件的详细信息，请参阅链接选项。 不能将检查全局 operator new 异常的代码与检查同一个应用程序中的 null 指针的代码混合使用。 但是，仍可以创建不同行为的类本地 **operator new**。 这种可能性意味着编译器在默认情况下必须以防御方式行事，并在 new 调用中包含对 null 指针返回的检查。 有关优化这些编译器检查的方法的详细信息，请参阅 /Zc:throwingnew。 我找到了MSVC 调试版本（_DEBUG）的 operator new 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// clang-format off: clang-format 19 doesn&#x27;t understand _CRTIMP2_PURE_IMPORT and will poorly format the following codeextern &quot;C++&quot; struct _CRTIMP2_PURE_IMPORT _Crt_new_delete &#123; // _CRTIMP2_PURE_IMPORT: 导出修饰符，表示这个结构从 DLL 导入 // _Crt_new_delete: 结构名，用于标记 CRT（C 运行时）分配的内存块 // 这个类只在 _DEBUG 模式下提供，用于调试版本的内存管理 #ifdef _DEBUG // 仅在调试版本中启用这些调试版本的操作符 // 标准的 operator new（可能抛出 std::bad_alloc 异常） void* __CLRCALL_OR_CDECL operator new(size_t _Size) &#123; // replace operator new // 1. 首先调用 nothrow 版本尝试分配内存 void* _Ptr = operator new(_Size, nothrow); // 2. 如果分配失败（返回 nullptr） if (!_Ptr) &#123; _Xbad_alloc(); // 内部函数，会抛出 std::bad_alloc 异常 // 注意：这个函数不会返回，它会抛出异常 &#125; // 3. 分配成功，返回指针 return _Ptr; &#125; // nothrow 版本的 operator new（不会抛出异常） void* __CLRCALL_OR_CDECL operator new(size_t _Size, const nothrow_t&amp;) noexcept &#123; // replace nothrow operator new // 关键：调用调试版本的 malloc // _malloc_dbg 参数解释： // 1. _Size &gt; 0 ? _Size : 1: C++标准要求 new(0) 返回有效指针 // 2. _CRT_BLOCK: 标记为 CRT 内部内存块类型 // 3. __FILE__: 源文件名（调试信息） // 4. __LINE__: 行号（调试信息） return _malloc_dbg(_Size &gt; 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__); // _malloc_dbg 最终会调用 malloc，但添加了： // - 分配额外的调试头（存储大小、文件名、行号等） // - 添加保护字节（检测缓冲区溢出） // - 链接到内存泄漏检测系统 &#125; // 标准的 operator delete（释放内存） void __CLRCALL_OR_CDECL operator delete(void* _Ptr) noexcept &#123; // replace operator delete // 直接调用 C 运行时的 free 函数 // _CSTD free: 引用标准 C 库的 free 函数 _CSTD free(_Ptr); // 注意：这里没有调用 _free_dbg，因为： // 1. 调试信息已经由 _malloc_dbg 记录 // 2. free 会自动处理调试版本的释放 &#125; // nothrow 版本的 operator delete（与 nothrow new 配对） void __CLRCALL_OR_CDECL operator delete(void* _Ptr, const nothrow_t&amp;) noexcept &#123; // replace nothrow operator delete // 简单地转发到标准的 operator delete operator delete(_Ptr); &#125; // 定位 new（placement new） - 在已有内存上构造对象 void* __CLRCALL_OR_CDECL operator new(size_t, void* _Ptr) noexcept &#123; // imitate True Placement New // 不分配新内存，直接返回传入的指针 return _Ptr; // 用途：在预分配的内存上构造对象 // 示例：new(buffer) MyClass(); &#125; // 定位 delete（placement delete） - 与定位 new 配对 void __CLRCALL_OR_CDECL operator delete(void*, void*) noexcept &#123;&#125; // imitate True Placement Delete // 空实现，因为定位 new 没有分配内存，所以不需要释放 // 只用于异常安全：如果定位 new 后的构造函数抛出异常，会调用这个#endif // _DEBUG // 调试版本结束标记&#125;;// clang-format on 再顺藤摸瓜看看_malloc_dbg这个函数： 找到了crtdbg.h这个文件，有一堆宏： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef _DEBUG #define _calloc_dbg(c, s, t, f, l) calloc(c, s) #define _expand_dbg(p, s, t, f, l) _expand(p, s) #define _free_dbg(p, t) free(p) #define _malloc_dbg(s, t, f, l) malloc(s) #define _msize_dbg(p, t) _msize(p) #define _realloc_dbg(p, s, t, f, l) realloc(p, s) #define _recalloc_dbg(p, c, s, t, f, l) _recalloc(p, c, s) #define _aligned_free_dbg(p) _aligned_free(p) #define _aligned_malloc_dbg(s, a, f, l) _aligned_malloc(s, a) #define _aligned_msize_dbg(p, a, o) _aligned_msize(p, a, o) #define _aligned_offset_malloc_dbg(s, a, o, f, l) _aligned_offset_malloc(s, a, o) #define _aligned_offset_realloc_dbg(p, s, a, o, f, l) _aligned_offset_realloc(p, s, a, o) #define _aligned_offset_recalloc_dbg(p, c, s, a, o, f, l) _aligned_offset_recalloc(p, c, s, a, o) #define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a) #define _aligned_recalloc_dbg(p, c, s, a, f, l) _aligned_recalloc(p, c, s, a) #define _freea_dbg(p, t) _freea(p) #define _malloca_dbg(s, t, f, l) _malloca(s) #define _dupenv_s_dbg(ps1, size, s2, t, f, l) _dupenv_s(ps1, size, s2) #define _fullpath_dbg(s1, s2, le, t, f, l) _fullpath(s1, s2, le) #define _getcwd_dbg(s, le, t, f, l) _getcwd(s, le) #define _getdcwd_dbg(d, s, le, t, f, l) _getdcwd(d, s, le) #define _getdcwd_lk_dbg(d, s, le, t, f, l) _getdcwd(d, s, le) #define _mbsdup_dbg(s, t, f, l) _mbsdup(s) #define _strdup_dbg(s, t, f, l) _strdup(s) #define _tempnam_dbg(s1, s2, t, f, l) _tempnam(s1, s2) #define _wcsdup_dbg(s, t, f, l) _wcsdup(s) #define _wdupenv_s_dbg(ps1, size, s2, t, f, l) _wdupenv_s(ps1, size, s2) #define _wfullpath_dbg(s1, s2, le, t, f, l) _wfullpath(s1, s2, le) #define _wgetcwd_dbg(s, le, t, f, l) _wgetcwd(s, le) #define _wgetdcwd_dbg(d, s, le, t, f, l) _wgetdcwd(d, s, le) #define _wgetdcwd_lk_dbg(d, s, le, t, f, l) _wgetdcwd(d, s, le) #define _wtempnam_dbg(s1, s2, t, f, l) _wtempnam(s1, s2)#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv // #ifdef _CRTDBG_MAP_ALLOC #define calloc(c, s) _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _expand(p, s) _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define free(p) _free_dbg(p, _NORMAL_BLOCK) #define malloc(s) _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _msize(p) _msize_dbg(p, _NORMAL_BLOCK) #define realloc(p, s) _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _recalloc(p, c, s) _recalloc_dbg(p, c, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _aligned_free(p) _aligned_free_dbg(p) #define _aligned_malloc(s, a) _aligned_malloc_dbg(s, a, __FILE__, __LINE__) #define _aligned_msize(p, a, o) _aligned_msize_dbg(p, a, o) #define _aligned_offset_malloc(s, a, o) _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__) #define _aligned_offset_realloc(p, s, a, o) _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__) #define _aligned_offset_recalloc(p, c, s, a, o) _aligned_offset_recalloc_dbg(p, c, s, a, o, __FILE__, __LINE__) #define _aligned_realloc(p, s, a) _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__) #define _aligned_recalloc(p, c, s, a) _aligned_recalloc_dbg(p, c, s, a, __FILE__, __LINE__) #define _freea(p) _freea_dbg(p, _NORMAL_BLOCK)#define _malloca(s) _malloca_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) 看起来眼花缭乱。但精简一下就是： 1234567891011121314151617#ifndef _DEBUG // 如果不是调试版本 // 所有 _dbg 函数直接映射到普通版本 #define _malloc_dbg(s, t, f, l) malloc(s) // ... 其他类似#else // 如果是调试版本 #ifdef _CRTDBG_MAP_ALLOC // 如果启用了完整的内存调试映射 // 这里重定向了所有标准内存函数到调试版本 #define malloc(s) _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) #define free(p) _free_dbg(p, _NORMAL_BLOCK) // ... 其他类似 #endif // _CRTDBG_MAP_ALLOC#endif // _DEBUG 如果忽略调试，我们就单纯看malloc(s)这个函数。终于见到了熟悉的malloc。malloc的函数特别纯粹： 12345void* malloc(size_t size) &#123; // 1. 向操作系统请求一块内存 // 2. 管理这块内存（记录大小等信息） // 3. 返回给用户可用的指针&#125; 这里再仔细看看malloc的行为： 写一个简单的使用malloc的： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1. 分配一个整数的大小 int* ptr = (int*)malloc(sizeof(int)); if (ptr == NULL) &#123; printf(&quot;内存分配失败！ &quot;); return 1; &#125; // 2. 使用分配的内存 *ptr = 42; printf(&quot;分配的整数: %d &quot;, *ptr); // 3. 释放内存 free(ptr); ptr = NULL; // 避免悬垂指针 return 0;&#125; 汇编为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133# License: MSVC Proprietary# The use of this compiler is only permitted for internal evaluation purposes and is otherwise governed by the MSVC License Agreement.# See https://visualstudio.microsoft.com/license-terms/vs2022-ga-community/; ==============================================; 数据段：存储字符串常量; ==============================================; 字符串1：中文编码的&quot;内存分配失败！&quot; + 换行符 + null终止符$SG6371 DB 0e5H, 086H, 085H, 0e5H, 0adH, 098H, 0e5H, 088H, 086H, 0e9H DB 085H, 08dH, 0e5H, 0a4H, 0b1H, 0e8H, 0b4H, 0a5H, 0efH, 0bcH, 081H DB 0aH, 00H ; 对应 UTF-8 编码的&quot;内存分配失败！ \\0&quot; ; 这是调试版本的中文错误提示 ORG $+1 ; 地址对齐指令，确保下一条指令在正确地址; 字符串2：中文&quot;分配的整数: &quot; + 格式字符串 &quot;%d&quot; + 换行符 + null$SG6372 DB 0e5H, 088H, 086H, 0e9H, 085H, 08dH, 0e7H, 09aH, 084H, 0e6H DB 095H, 0b4H, 0e6H, 095H, 0b0H, &#x27;: %d&#x27;, 0aH, 00H ; 对应 UTF-8 编码的&quot;分配的整数: %d \\0&quot;; ==============================================; 全局变量：stdio 选项存储; ==============================================unsigned __int64 `__local_stdio_printf_options&#x27;::`2&#x27;::_OptionsStorage DQ 01H DUP (?); 这是一个全局变量，用于存储 printf 的选项（如缓冲区大小等）; DQ 01H DUP (?) 表示分配一个 8 字节（quad word）未初始化的空间; ==============================================; 栈帧布局定义; ==============================================ptr$ = 32 ; 局部变量 ptr 在栈上的偏移量是 32 字节; ==============================================; main 函数开始; ==============================================main PROC$LN4: ; 标签：代码块开始 ; 函数序言（prologue）：设置栈帧 sub rsp, 56 ; 00000038H ; 在栈上分配 56 字节空间（局部变量 + 对齐） ; 为什么要 56 字节？ ; - 32字节：预留空间（可能用于参数传递） ; - 8字节：ptr 变量 ; - 16字节：对齐到16字节边界（Windows x64 调用约定要求） ; ====================================== ; 步骤1：调用 malloc 分配内存 ; ====================================== mov ecx, 4 ; 参数1：size = 4 字节 ; Windows x64 调用约定：前4个参数在 RCX, RDX, R8, R9 ; 这里 malloc 只需要一个参数，所以放在 RCX 的低32位 ECX call QWORD PTR __imp_malloc ; 调用 malloc ; __imp_malloc 是导入函数地址（从 DLL 导入） ; QWORD PTR 表示这是一个64位指针 ; ====================================== ; 步骤2：保存返回的指针 ; ====================================== mov QWORD PTR ptr$[rsp], rax ; 将返回值保存到栈上的 ptr 变量 ; malloc 的返回值（分配的内存地址）在 RAX 中 ; ptr$[rsp] = rsp + 32（上面定义的偏移量） ; ====================================== ; 步骤3：检查分配是否成功 ; ====================================== cmp QWORD PTR ptr$[rsp], 0 ; 比较 ptr 是否为 NULL jne SHORT $LN2@main ; 如果不为 NULL，跳转到成功处理 ; jne = Jump if Not Equal（如果不等于0） ; ====================================== ; 分支：分配失败的处理 ; ====================================== lea rcx, OFFSET FLAT:$SG6371 ; 加载字符串地址到 RCX ; LEA = Load Effective Address（加载有效地址） ; OFFSET FLAT: 表示相对于数据段基址的偏移 ; 准备调用 printf 的第一个参数 call printf ; 调用 printf 输出错误信息 ; 这里没有 __imp_ 前缀，可能是静态链接或内联 mov eax, 1 ; 设置返回值 1（表示错误） jmp SHORT $LN1@main ; 跳转到函数结尾 ; ======================================; 标签：分配成功的处理; ======================================$LN2@main: ; ====================================== ; 步骤4：使用分配的内存（写入值） ; ====================================== mov rax, QWORD PTR ptr$[rsp] ; 加载 ptr 到 RAX mov DWORD PTR [rax], 42 ; 将 42 写入指针指向的位置 ; DWORD PTR [rax] 表示将 RAX 作为指针，写入32位值 ; 42 的十六进制是 2AH ; ====================================== ; 步骤5：读取并打印这个值 ; ====================================== mov rax, QWORD PTR ptr$[rsp] ; 再次加载 ptr（可能被优化掉，但这里没优化） mov edx, DWORD PTR [rax] ; 读取刚写入的值到 EDX ; EDX 是 printf 的第二个参数寄存器 lea rcx, OFFSET FLAT:$SG6372 ; 加载格式字符串到 RCX（第一个参数） call printf ; 调用 printf ; ====================================== ; 步骤6：释放内存 ; ====================================== mov rcx, QWORD PTR ptr$[rsp] ; 将 ptr 加载到 RCX（free 的参数） call QWORD PTR __imp_free ; 调用 free ; ====================================== ; 步骤7：置空指针（避免悬垂指针） ; ====================================== mov QWORD PTR ptr$[rsp], 0 ; 将 ptr 设为 NULL ; ====================================== ; 步骤8：设置返回值 0（成功） ; ====================================== xor eax, eax ; EAX = 0（返回 0） ; XOR 自己是最快的清零方式 ; ======================================; 标签：函数返回点（两个分支的汇合处）; ======================================$LN1@main: ; 函数结尾（epilogue）：恢复栈帧 add rsp, 56 ; 释放栈空间 ret 0 ; 返回main ENDP new中的构造函数先考虑可能出现的情况。会变化的有以下这些：new的是内置类型对象还是自定义类型对象。如果是自定义类型对象，使用new A；还是new A（）有零初始化的问题。以及有无用户显式定义了构造函数。 无显式初始化写一个测试代码看一看，是否有构造函数的影响且初始化采用new X的不带各种括号的形式： 123456789101112131415161718192021222324252627282930struct A &#123; int x; A() &#123; std::cout &lt;&lt; &quot;A constructed&quot; &lt;&lt; std::endl; &#125; // 有用户定义构造函数&#125;;struct B &#123; int x; // 没有构造函数&#125;;struct C &#123; int x; C() = default; // 显式默认构造函数&#125;;int main() &#123; std::cout &lt;&lt; &quot;Testing A (has ctor):&quot; &lt;&lt; std::endl; A* a = new A; // 会输出 std::cout &lt;&lt; &quot; Testing B (no ctor):&quot; &lt;&lt; std::endl; B* b = new B; // 不会输出 std::cout &lt;&lt; &quot; Testing C (defaulted ctor):&quot; &lt;&lt; std::endl; C* c = new C; // 不会输出 delete a; delete b; delete c; return 0;&#125; 运行结果： 123456Testing A (has ctor):A constructedTesting B (no ctor):Testing C (defaulted ctor): 一个一个来看： 第一部分：A::A() 构造函数分析12345678910111213141516171819A::A(void) PROC$LN3: mov QWORD PTR [rsp+8], rcx ; 保存 this 指针 sub rsp, 40 ; 分配栈空间 ; 输出 &quot;A constructed&quot; lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;A constructed&quot; mov rcx, QWORD PTR __imp_std::cout ; RCX = std::cout call std::operator&lt;&lt; ; 调用 operator&lt;&lt; ; 输出 std::endl lea rdx, OFFSET FLAT:std::endl ; RDX = endl 函数地址 mov rcx, rax ; RCX = cout（上一条的返回值） call QWORD PTR __imp_std::basic_ostream::operator&lt;&lt; mov rax, QWORD PTR this$[rsp] ; 返回 this 指针 add rsp, 40 ; 恢复栈 ret 0A::A(void) ENDP A 的构造函数是真实存在的函数，包含实际的代码（输出语句）。 第二部分：main 函数分析创建对象 A（有构造函数）1234567891011121314151617181920212223242526272829; 输出 &quot;Testing A (has ctor):&quot;lea rdx, OFFSET FLAT:$SG35287 ; RDX = 字符串地址mov rcx, QWORD PTR __imp_std::cout ; RCX = coutcall std::operator&lt;&lt;; ... 输出 endl; 分配 A 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T1[rsp], rax ; 保存返回指针cmp QWORD PTR $T1[rsp], 0 ; 检查分配是否成功je SHORT $LN3@main ; 如果失败，跳转; 关键：调用构造函数！mov rcx, QWORD PTR $T1[rsp] ; RCX = this 指针call A::A(void) ; 调用构造函数 A::A()mov QWORD PTR tv80[rsp], rax ; 保存结果jmp SHORT $LN4@main; 分配失败处理$LN3@main:mov QWORD PTR tv80[rsp], 0 ; 存储 nullptr; 保存到变量 a$LN4@main:mov rax, QWORD PTR tv80[rsp]mov QWORD PTR a$[rsp], rax ; 保存到 a 对于类 A，有明显的 call A::A(void) 指令，这就是构造函数的调用。 创建对象 B（没有构造函数）123456789; 输出 &quot;Testing B (no ctor):&quot;; ... 类似前面的输出代码; 分配 B 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T3[rsp], rax ; 保存返回指针mov rax, QWORD PTR $T3[rsp] ; 加载指针mov QWORD PTR b$[rsp], rax ; 直接保存到 b 关键差异： 没有空指针检查分配后直接保存指针，没有 cmp 和 je 指令 没有构造函数调用 没有 call B::B(void) 之类的指令 分配后直接使用，指针直接存入变量 创建对象 C（默认构造函数）123456789; 输出 &quot;Testing C (defaulted ctor):&quot;; ... 输出代码; 分配 C 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T4[rsp], rax ; 保存返回指针mov rax, QWORD PTR $T4[rsp] ; 加载指针mov QWORD PTR c$[rsp], rax ; 直接保存到 c 与 B 完全一样,C() = default; 和没有构造函数在汇编层面没有区别。 值初始化刚刚的实验的new的方式是不带任何括号的。下面看看new X()这种带括号的值初始化： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;struct A &#123; int x; A() &#123; std::cout &lt;&lt; &quot;A constructed&quot; &lt;&lt; std::endl; &#125;&#125;;struct B &#123; int x; // 没有构造函数&#125;;struct C &#123; int x; C() = default; // 显式默认&#125;;int main() &#123; std::cout &lt;&lt; &quot;Testing A (has ctor) with parentheses:&quot; &lt;&lt; std::endl; A* a = new A(); // 值初始化 - 会调用构造函数 std::cout &lt;&lt; &quot; Testing B (no ctor) with parentheses:&quot; &lt;&lt; std::endl; B* b = new B(); // 值初始化 - 会进行零初始化 std::cout &lt;&lt; &quot; Testing C (defaulted ctor) with parentheses:&quot; &lt;&lt; std::endl; C* c = new C(); // 值初始化 - 会进行零初始化 // 为了演示差异，输出值 std::cout &lt;&lt; &quot; Checking values:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a-&gt;x = &quot; &lt;&lt; a-&gt;x &lt;&lt; std::endl; // 构造函数可能设定了值 std::cout &lt;&lt; &quot;b-&gt;x = &quot; &lt;&lt; b-&gt;x &lt;&lt; std::endl; // 应该为0（零初始化） std::cout &lt;&lt; &quot;c-&gt;x = &quot; &lt;&lt; c-&gt;x &lt;&lt; std::endl; // 应该为0（零初始化） delete a; delete b; delete c; return 0;&#125; 测试结果： 1234567891011Testing A (has ctor) with parentheses:A constructedTesting B (no ctor) with parentheses:Testing C (defaulted ctor) with parentheses:Checking values:a-&gt;x = -842150451b-&gt;x = 0c-&gt;x = 0 情况1：new A() - 有用户定义构造函数asm 1234567891011121314151617181920212223242526; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T3[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T3[rsp], 0je SHORT $LN3@main ; 如果失败，跳转; 调用构造函数mov rcx, QWORD PTR $T3[rsp] ; RCX = this 指针call A::A(void) ; 调用构造函数mov QWORD PTR tv80[rsp], rax ; 保存结果jmp SHORT $LN4@main; 分配失败处理$LN3@main:mov QWORD PTR tv80[rsp], 0 ; 存储 nullptr; 保存到变量 a$LN4@main:mov rax, QWORD PTR tv80[rsp]mov QWORD PTR $T4[rsp], raxmov rax, QWORD PTR $T4[rsp]mov QWORD PTR a$[rsp], rax ; 保存到 a 关键点：对于有构造函数的类 A，new A() 的行为是： 分配内存 检查分配成功 调用构造函数 保存指针 特别注意：没有清零操作。因为类 A 有用户定义的构造函数，编译器依赖构造函数来初始化对象。 情况2：new B() - 没有构造函数123456789101112131415161718192021222324252627; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T1[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T1[rsp], 0je SHORT $LN5@main ; 如果失败，跳转; 清零内存mov rdi, QWORD PTR $T1[rsp] ; RDI = 目标地址xor eax, eax ; EAX = 0mov ecx, 4 ; ECX = 4字节rep stosb ; 清零4字节内存mov rax, QWORD PTR $T1[rsp]mov QWORD PTR tv91[rsp], rax ; 保存结果jmp SHORT $LN6@main; 分配失败处理$LN5@main:mov QWORD PTR tv91[rsp], 0 ; 存储 nullptr; 保存到变量 b$LN6@main:mov rax, QWORD PTR tv91[rsp]mov QWORD PTR b$[rsp], rax ; 保存到 b 关键点：对于没有构造函数的类 B，new B() 的行为是： 分配内存 检查分配成功 清零内存（rep stosb） 保存指针 这就是值初始化的核心：new B() 触发了零初始化，即使类 B 没有构造函数。 情况3：new C() - 默认构造函数asm 123456789101112131415161718192021222324252627; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T2[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T2[rsp], 0je SHORT $LN7@main ; 如果失败，跳转; 清零内存（与B完全相同）mov rdi, QWORD PTR $T2[rsp] ; RDI = 目标地址xor eax, eax ; EAX = 0mov ecx, 4 ; ECX = 4字节rep stosb ; 清零4字节内存mov rax, QWORD PTR $T2[rsp]mov QWORD PTR tv139[rsp], rax ; 保存结果jmp SHORT $LN8@main; 分配失败处理$LN7@main:mov QWORD PTR tv139[rsp], 0 ; 存储 nullptr; 保存到变量 c$LN8@main:mov rax, QWORD PTR tv139[rsp]mov QWORD PTR c$[rsp], rax ; 保存到 c 类 C 的代码与类 B 完全相同。C() = default; 和没有构造函数在 new C() 的情况下行为完全一致。 混淆的点：列表初始化和成员初始化列表说实话，我有点搞混这两个概念了。重新梳理一遍： 写一个测试代码看看： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;class Demo &#123; std::string data; int id; public: // 构造函数1：有成员初始化列表 Demo() : data(&quot;default&quot;), id(0) &#123; std::cout &lt;&lt; &quot;Constructor 1: member init list &quot;; &#125; // 构造函数2：没有成员初始化列表 Demo(int i) &#123; data = &quot;assigned&quot;; id = i; std::cout &lt;&lt; &quot;Constructor 2: assignment in body &quot;; &#125; // 构造函数3：混合 Demo(const std::string&amp; s) : data(s) &#123; id = 42; // 内置类型，区别不大 std::cout &lt;&lt; &quot;Constructor 3: mixed &quot;; &#125;&#125;;int main() &#123; // 外部语法决定调用哪个构造函数 Demo* d1 = new Demo(); // 调用Demo() - 有初始化列表 Demo* d2 = new Demo&#123;&#125;; // 调用Demo() - 有初始化列表 Demo* d3 = new Demo(100); // 调用Demo(int) - 没有初始化列表 Demo* d4 = new Demo&#123;100&#125;; // 调用Demo(int) - 没有初始化列表 Demo* d5 = new Demo&#123;&quot;test&quot;&#125;; // 调用Demo(string) - 有部分初始化列表 delete d1; delete d2; delete d3; delete d4; delete d5; return 0;&#125; 运行结果如下： 1234567891011121314Demo* d1 = new Demo()Constructor 1: member init list========================Demo* d2 = new Demo&#123;&#125;Constructor 1: member init list========================Demo* d3 = new Demo(100);Constructor 2: assignment in body========================Demo* d4 = new Demo&#123; 100 &#125;Constructor 2: assignment in body========================Demo* d5 = new Demo&#123;&quot;test&quot; &#125;Constructor 3: mixed 详细分析：三个构造函数的汇编对比构造函数1分析：Demo::Demo(void) - 有成员初始化列表1234567891011121314151617181920212223242526Demo::Demo(void) PROC$LN4: mov QWORD PTR [rsp+8], rcx ; 保存 this 指针 sub rsp, 40 ; 分配栈空间 ; === 成员初始化列表开始 === mov rax, QWORD PTR this$[rsp] ; RAX = this lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;default&quot; 字符串地址 mov rcx, rax ; RCX = this（data成员的地址） call std::basic_string::basic_string(char const*) ; 直接构造data！ ; === 成员初始化列表结束 === ; 初始化 id mov rax, QWORD PTR this$[rsp] ; RAX = this mov DWORD PTR [rax+32], 0 ; this-&gt;id = 0 ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; ; RDX = 输出字符串 mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(void) ENDP 关键点：data 成员通过直接调用构造函数初始化，这是最高效的方式。 构造函数2分析：Demo::Demo(int) - 没有成员初始化列表12345678910111213141516171819202122232425262728293031323334Demo::Demo(int) PROC$LN4: mov DWORD PTR [rsp+16], edx ; 保存参数 i mov QWORD PTR [rsp+8], rcx ; 保存 this sub rsp, 40 ; === 没有成员初始化列表！data默认构造 === mov rax, QWORD PTR this$[rsp] ; RAX = this mov rcx, rax ; RCX = this（data地址） call std::basic_string::basic_string(void) ; 默认构造函数！ ; data现在是一个空字符串 ; === 构造函数体开始：赋值操作 === mov rax, QWORD PTR this$[rsp] ; RAX = this lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;assigned&quot; mov rcx, rax ; RCX = &amp;data call std::basic_string::operator= ; 赋值操作！ ; 这里调用了 operator=，不是构造函数 ; 初始化 id mov rax, QWORD PTR this$[rsp] mov ecx, DWORD PTR i$[rsp] ; ECX = 参数 i mov DWORD PTR [rax+32], ecx ; this-&gt;id = i ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(int) ENDP 关键差异： 多一次函数调用：先调用默认构造函数，再调用 operator= 效率更低：std::string 被构造了两次（默认构造 + 赋值） 构造函数3分析：Demo::Demo(const string&amp;) - 混合方式1234567891011121314151617181920212223242526Demo::Demo(std::basic_string&lt;char,...&gt; const &amp;) PROC$LN4: mov QWORD PTR [rsp+16], rdx ; 保存参数 s 的引用 mov QWORD PTR [rsp+8], rcx ; 保存 this sub rsp, 40 ; === 成员初始化列表：data使用拷贝构造 === mov rax, QWORD PTR this$[rsp] ; RAX = this mov rdx, QWORD PTR s$[rsp] ; RDX = 参数 s（源字符串） mov rcx, rax ; RCX = this（目标地址） call std::basic_string::basic_string(string const&amp;) ; 拷贝构造！ ; === 构造函数体：初始化 id === mov rax, QWORD PTR this$[rsp] mov DWORD PTR [rax+32], 42 ; this-&gt;id = 42 ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(std::basic_string&lt;char,...&gt; const &amp;) ENDP 关键点：data 通过拷贝构造函数直接初始化，这是高效的。 main 函数分析：五种创建方式1. d1 = new Demo() - 默认构造函数123456789mov ecx, 40 ; sizeof(Demo) = 40 (32+8，考虑对齐)call void * operator newmov QWORD PTR $T2[rsp], raxcmp QWORD PTR $T2[rsp], 0je SHORT $LN3@main ; 检查分配失败mov rcx, QWORD PTR $T2[rsp]call Demo::Demo(void) ; 调用构造函数1 2. d2 = new Demo&#123;&#125; - 列表初始化（空列表）1234567; 与 d1 完全相同！mov ecx, 40call void * operator newcmp rax, 0je ...mov rcx, raxcall Demo::Demo(void) ; 同样调用构造函数1 3. d3 = new Demo(100) - 直接初始化12345mov ecx, 40call void * operator newmov edx, 100 ; 参数：i = 100mov rcx, raxcall Demo::Demo(int) ; 调用构造函数2 4. d4 = new Demo&#123;100&#125; - 列表初始化123456; 与 d3 完全相同！mov ecx, 40call void * operator newmov edx, 100 ; 参数：i = 100mov rcx, raxcall Demo::Demo(int) ; 同样调用构造函数2 5. d5 = new Demo&#123;&quot;test&quot;&#125; - 列表初始化（字符串）这是最复杂的情况： 123456789101112131415161718192021222324252627; 1. 分配内存mov ecx, 40call void * operator newmov QWORD PTR $T6[rsp], rax; 2. 创建临时字符串 &quot;test&quot;lea rdx, OFFSET FLAT:$SG35705 ; RDX = &quot;test&quot;lea rcx, QWORD PTR $T17[rsp] ; RCX = 临时字符串位置call std::basic_string::basic_string(char const*) ; 构造临时字符串; 3. 标记需要清理临时字符串mov eax, DWORD PTR $T1[rsp]or eax, 1mov DWORD PTR $T1[rsp], eax; 4. 调用构造函数3lea rdx, QWORD PTR $T17[rsp] ; RDX = 临时字符串的引用mov rcx, QWORD PTR $T6[rsp] ; RCX = 新分配的Demo对象call Demo::Demo(string const&amp;) ; 调用构造函数3; 5. 清理临时字符串mov eax, DWORD PTR $T1[rsp]and eax, 1test eax, eaxje SHORT $LN30@mainlea rcx, QWORD PTR $T17[rsp]call std::basic_string::~basic_string ; 析构临时字符串 对比 new Demo() 和 new Demo&#123;&#125; 的汇编完全一样在这个例子中，两者都调用 Demo::Demo(void)，生成相同的代码。 new Demo(100) 和 new Demo&#123;100&#125; 的汇编完全一样两者都调用 Demo::Demo(int)，生成相同的代码。 构造函数2的效率问题清晰可见对比构造函数1和2： 构造函数1：1次字符串构造函数调用 构造函数2：2次函数调用（默认构造 + operator=） 临时对象的处理new Demo&#123;&quot;test&quot;&#125; 需要创建临时字符串，然后通过引用传递给构造函数，最后清理临时对象。 根据文章内容，您对C++中new和delete的探索非常深入！您已经发现了不同初始化方式的细微差别以及构造函数实现方式对性能的影响。基于您的分析，我重新整理了总结部分，并优化了对比表格，使其更清晰准确。 总结 通过实验分析，可以得出以下关键结论： new的本质：new表达式分为两步：首先调用operator new分配内存，然后根据需要调用构造函数。对于没有用户定义构造函数的类型，编译器会优化掉构造函数调用。 初始化差异： new T（默认初始化）：对有构造函数的类型调用构造函数；对无构造函数的类型不初始化。 new T()（值初始化）：对有构造函数的类型调用构造函数并可能进行零初始化；对无构造函数的类型进行零初始化。 new T&#123;&#125;（列表初始化）：行为与直接初始化类似，但禁止窄化转换。 构造函数效率：使用成员初始化列表直接在内存中构造对象，比在构造函数体内赋值更高效，避免了先默认构造再赋值的开销。 内存分配：operator new最终会调用malloc，在调试版本中会添加额外的调试信息用于内存泄漏检测。 错误处理：默认情况下new在分配失败时抛出std::bad_alloc异常，但可以通过new(std::nothrow)使用不抛出版本。 分类 语法 零初始化 构造函数调用 示例 内置类型 默认初始化 new int ❌ 否 无 int* p = new int; // 随机值 值初始化 new int() ✅ 是 无 int* p = new int(); // 0 列表初始化 new int&#123;&#125; ✅ 是 无 int* p = new int&#123;&#125;; // 0 平凡类型（无构造函数） 默认初始化 new POD ❌ 否 无 POD* p = new POD; // 成员随机值 值初始化 new POD() ✅ 是 无 POD* p = new POD(); // 成员零初始化 列表初始化 new POD&#123;&#125; ✅ 是 无 POD* p = new POD&#123;&#125;; // 成员零初始化 非平凡类型（有构造函数） 默认初始化 new Class ❌ 否 ✅ 调用默认构造函数 Class* c = new Class; // 调用Class() 值初始化 new Class() ⚠️ 可能¹ ✅ 调用默认构造函数 Class* c = new Class(); // 调用Class() 列表初始化 new Class&#123;&#125; ❌ 否 ✅ 调用默认构造函数 Class* c = new Class&#123;&#125;; // 调用Class() 构造函数差异 成员初始化列表 : member(value) ❌ 否 直接构造成员 最高效，避免额外赋值 构造函数体内赋值 member = value ❌ 否 先默认构造再赋值 效率较低，多一次赋值操作 说明： 值初始化对于有构造函数的类：根据编译器实现，new Class()可能在调用构造函数前先进行零初始化。MSVC在调试版本中会执行零初始化，但这不是C++标准要求的。 性能建议：对于类成员变量，优先使用成员初始化列表，避免在构造函数体内赋值，特别是对于std::string、std::vector等非平凡类型。 内存管理：new/delete必须配对使用，new[]/delete[]必须配对使用，混用会导致未定义行为。 通过对C++中new表达式和构造函数实现方式的深入分析，可以清楚地认识到：外部初始化语法与类内部构造函数的实现方式是两个独立且正交的概念。 当我们在代码中使用new T、new T()或new T&#123;&#125;等不同语法创建对象时，这些外部语法只负责选择调用哪个构造函数以及决定是否进行零初始化，它们无法改变类内部已经定义好的构造方式。是否在构造过程中先调用成员变量的默认构造函数，完全取决于类设计者在编写构造函数时是选择使用成员初始化列表还是在构造函数体内进行赋值操作。 使用成员初始化列表的构造函数会直接调用成员变量带参数的构造函数，一步到位地完成初始化，避免了不必要的默认构造步骤。而将初始化操作放在构造函数体内的方式，则会强制编译器先调用成员变量的默认构造函数创建一个临时对象，然后再通过赋值运算符将值赋给该对象，这种额外的开销与外部使用何种new语法毫无关系。 无论外部采用new MyClass、new MyClass()还是new MyClass&#123;&#125;的语法，只要内部构造函数使用成员初始化列表，就不会调用成员变量的默认构造函数；反之，如果内部构造函数在函数体内赋值，就一定会先调用默认构造函数。这一构造过程的差异是类设计阶段决定的，与对象创建时使用的外部语法无关。 零初始化的发生确实与外部语法密切相关，而与类内部构造函数的实现方式相对独立。当使用new T()进行值初始化时，对于没有用户定义构造函数的平凡类型，编译器会在分配内存后执行零初始化操作，将所有成员设置为零值。这种零初始化发生在构造函数调用之前，是内存分配后立即执行的底层操作。 有趣的是，对于有用户定义构造函数的类，即使使用new T()语法，C++标准也不强制要求进行零初始化。不过在实际编译中，特别是MSVC的调试版本，编译器可能会在调用用户定义的构造函数之前插入零初始化的代码，但这属于编译器的实现细节而非语言标准的要求。 相比之下，成员初始化列表与构造函数体内赋值的区别在于对象构造的路径不同，而零初始化则是更前置的内存准备阶段。无论类内部采用哪种构造方式，只要该类没有用户定义的构造函数且使用值初始化语法new T()，都会触发零初始化。但如果类有用户定义的构造函数，零初始化就可能被跳过，直接进入构造函数执行阶段。 因此，零初始化主要受两个因素影响：一是类是否有用户定义的构造函数，二是外部是否使用值初始化语法。对于希望确保成员初始化为零值的场景，程序员需要明确使用new T()或new T&#123;&#125;语法，并且了解这仅对无用户定义构造函数的类型保证有效。对于有构造函数的类，零初始化的责任应完全由构造函数承担，通过成员初始化列表明确设置每个成员的初始值是比较安全的做法。 {}初始化（统一初始化或列表初始化）在C++11中引入，旨在提供一种统一的初始化语法，但它与()初始化存在多方面的重要区别。窄化转换的禁止只是其中最明显的一点，但还有更本质的行为差异。 当使用{}初始化时，编译器会优先考虑std::initializer_list构造函数。这意味着如果类定义了接受std::initializer_list参数的构造函数，{}初始化将调用这个构造函数，而()初始化则会调用其他匹配的构造函数。这种优先级差异可能导致完全不同的对象构造路径。 对于聚合类型（没有用户定义构造函数、没有私有或受保护的非静态数据成员、没有基类、没有虚函数的类），{}初始化允许直接初始化各个成员，这是一种简洁而高效的初始化方式。而()初始化对聚合类型的行为则不同，它可能需要进行转换或者根本不可用。 在值的初始化方面，new T{}会进行值初始化，对于内置类型和没有构造函数的类，这意味着零初始化。虽然new T()也有类似行为，但{}提供了更一致的语法，避免了与函数声明混淆的经典问题。 此外，{}初始化还解决了C++中最令人烦恼的解析问题。在复杂表达式中，{}能够明确区分对象初始化和函数声明，而()则可能产生歧义。 啊啊啊啊，这时候又要问，这位std::initializer_list又是谁？ 具体使用请参考https://learn.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170微软的C++文档： 在C++中，std::initializer_list和成员初始化列表虽然名称相似，但本质上是两个截然不同的概念，理解它们的区别对于掌握现代C++初始化语义至关重要。 std::initializer_list是C++11标准库中定义的一种特殊模板类型，它作为构造函数参数使用，专门用于接收花括号初始化器中的值序列。当类定义了接受std::initializer_list参数的构造函数时，使用花括号&#123;&#125;进行初始化会优先匹配这个构造函数，这使得对象可以从一组值直接初始化。这种设计使得像std::vector&lt;int&gt; v&#123;1, 2, 3&#125;这样的语法成为可能，其中花括号内的值被整体传递给std::initializer_list构造函数。 而成员初始化列表是构造函数定义本身的组成部分，它位于构造函数参数列表之后、函数体之前，采用冒号引导的语法形式。成员初始化列表的用途是在进入构造函数体之前直接初始化类的各个成员变量，避免了先默认构造再赋值的性能开销。这是一种优化手段，确保成员变量从一开始就被正确初始化。 这两种机制虽然都与初始化相关，但作用层面完全不同。std::initializer_list关注的是如何将外部提供的一组值传递给对象，属于接口设计的一部分；而成员初始化列表关注的是对象内部成员变量的构造方式，属于实现优化的范畴。前者影响的是对象创建时用户能使用的语法形式，后者影响的是对象构造过程中的性能表现。 在实际编程中，一个类的构造函数完全可以同时使用这两种机制：它既可以接受std::initializer_list参数来支持列表初始化，同时在实现内部使用成员初始化列表来高效地初始化成员变量。这种组合使得C++的初始化机制既灵活又高效，既提供了友好的用户接口，又保证了良好的运行时性能。 整理到这里，我终于理解了为什么有的人会专门写一本书来讲C++的初始化了，太可怕了这也。 下一篇再整理free和delete吧，这也太可怕了。 太可怕了。","tags":["C++"]},{"title":"malloc失败假装没事谁信（malloc内存分配相关总结整理）","path":"/2026/01/24/我真的很讨厌malloc失败假装没事/","content":"今天首先很讨厌自己学了也有一阵C++了但是感觉如果让我说的话还是支支吾吾不知从何说起。感觉就是所有关键词知识点都在抢占大脑输出通道，没有逻辑章法。 第二个讨厌的就是malloc失败了假装自己没事，原因就是只返回一个void*类型，还得我们自己做一次检查。就像买了房子只给了钥匙，然后发现这钥匙是NULL用不了。 先倒出来脑子里有的，再一点点整理。 new/delete和malloc/free都可以进行内存分配和释放，区别在于new/delete是C++里的一个运算符，而malloc则是C库里的一个函数。这里先点一下题，这个性质也就决定了，new既然作为内置实现的一个运算符，任何new过程中出现的失败都会使得new这个操作失败并抛出异常，默认会抛出 std::bad_alloc 异常。而malloc作为函数，它只会返回一个void*指针，不会抛出异常操作。至于这块地址能不能用，用户还得自己检查一遍。 malloc和free：malloc和free是C语言内存管理的基石。我在本科的时候写C最讨厌的就是这两位，因为抄起来相对较长，malloc这个名字看起来又不是什么正经英语。malloc，全名：memory allocation（这下看起来正经了）和free来自C语言，C++也就继承了这两个函数，这两位隶属于C标准库。一会再整理new和delete，那两位是靠malloc来实现的。 为什么不叫memaloc？之前一直以为是ma+loc，今天定睛一看嘿原来是m+alloc 当调用malloc(size_t size)时，操作系统和运行时库会进行一系列复杂的操作。具体如下：malloc首先会从进程的堆中寻找足够大的连续空闲内存块。如果找到了合适的，它就会把这个内存块标记为已分配，然后，返回指向内存块起始地址的指针。 但是，作为C++程序员，以及那群面试官中老登们，成功固然令人欣喜，失败则意味着能有更多考察我的知识点（）。malloc什么时候会失败？ 第一个原因很简单，就是内存不足。进程请求的内存总量，超过了系统能提供的物理内存和虚拟内存之和时，分配就会失效。 第二个也很好想到，就是连续的内存不够，内存太碎片了，这时候也会失效。 第三个是关于地址空间的。进程的虚拟地址空间如果全占完了，即使物理内存还剩很多也没用。（32位系统进程是4GB的虚拟地址空间）。 第四个是内存分配器损坏，由于程序错误比如缓冲区溢出，重复释放等（这个有疑问）。 当空间不够时，malloc会返回NULL来表示分配失败。我们必须检查这个返回值。对空指针解引用是未定义行为（段错误）。 与malloc相对应的就是free。free(void* ptr)负责释放之前分配的内存。由内存分配器将被释放的内存块标记为空闲。 free也会失败。首先free不返回任何值，这里的失败主要指的是程序的行为出错。最经典的就是重复释放，对一块内存多次调用free也会导致未定义行为。内存分配器会认为这块内存已经被释放，再次释放时可能破坏内存管理数据结构。 什么是破坏内存管理的数据结构： 许多分配器在分配的内存块前面存储元数据（大小、状态、链接指针等）。 当程序第一次调用free释放内存时，内存分配器会在这块内存区域的头部或尾部找到它自己之前记录的管理数据。这些数据至少包括这块内存的大小，以及一个表示该内存是否已被分配的状态标志。分配器会将这个状态标志改为“空闲”。之后，分配器通常会把这整块内存（包括用户数据区域和管理数据区域）视为一个空闲块，并将其添加到一个用于跟踪所有空闲内存的数据结构中。这个数据结构常见的形式是链表或树。例如，如果是链表，分配器会在这个空闲块的管理数据区写入指向链表中下一个空闲块和上一个空闲块的指针。 这里会出现几种破坏情况： 第一种情况是，在两次free之间，没有其他代码改动过这块内存。此时管理数据中的状态可能已经是“空闲”。当分配器试图再次将其标记为“空闲”时，这个操作本身可能无意义，但也可能破坏其他用于内部记账的标志。更重要的是，分配器会再次执行“将空闲块插入数据结构”的操作。这会导致同一个内存块在空闲链表或树中出现两次。当后续进行内存分配时，分配器可能会把这个块分配出去，但它在链表中还有一个副本。之后对这个副本的任何操作，比如尝试从链表中移除它，都会访问到可能已被用户数据覆盖的内存区域（现在它是已分配状态），从而导致读取或写入错误的内存地址。 第二种更常见且更复杂的情况是，在两次free之间，这块内存可能已经被重新分配出去，用于其他用途。新的数据可能已经写入了原来的用户区域，甚至可能覆盖了部分原始的管理数据（如果新的使用方式允许写入足够多的数据）。当第二次free执行时，分配器读取的管理数据是无效的或被篡改过的。例如，它读到一个被用户数据篡改过的“内存块大小”值。分配器会根据这个错误的大小值去计算哪里是这块内存的尾部，以及哪些是相邻的内存块，进而去修改那些它认为是“相邻块”头部的管理数据。这直接破坏了其他正在使用的内存中的数据，而这些数据可能属于程序的变量、对象或其他关键结构。 第二种释放失败的原因我称之为多管闲事。比如试图释放栈上的变量、全局变量或通过 new 分配的内存。 第三种就是完全想当然地去释放。如果我释放的不是原始分配给我的指针，而是我对这个指针做了点运算，比如，我就想释放我申请内存的后半部分。这么想想好像非常符合情理。但最后释放可能就会出错。因为内存分配器依赖这个原始指针精确值来定位内存块的管理信息。任何指针运算都会破坏这个前提，导致分配器操作错误的内存地址，进而损坏内存管理数据或用户数据。 关于返回值以及void* malloc 返回一个 void* 类型的指针，void* 字面意思是”指向 void 的指针”，但更准确的理解是”通用指针”或”无类型指针”。 内存本身只是字节序列，没有内在的类型信息。编译器需要知道如何解释这些字节。例如，同样的 4 个字节，可以被解释为整数、浮点数、4 个字符，或者只是一个内存地址。void* 表示”这里有一块内存，但不知道它应该被解释为什么类型”。 这时候理解了当时为什么觉得抄malloc函数很麻烦：比如 进行 int* ptr = (int*)malloc(sizeof(int)); 时，发生了两件事： malloc 分配了一块适当大小的原始内存，返回 void* 还要通过类型转换告诉编译器这块内存当作整数来使用 一句里出现了三个int，让本科时候的我抄得一头雾水。 关于new和delete，我后面专门开一篇来学习整理，因为那个感觉和自定义类型相关性较高，重点在对象的创建和释放上。底层还是malloc这些。","tags":["C++"]},{"title":"LRU把最老的赶出门犯法吗","path":"/2026/01/21/LRU把最老的赶出门犯法吗/","content":"今天来学学LRU在UE5.6引擎里的实现，之前会写大致的LRU算法，也没太关注内存有没有泄漏什么的。顺带学学C++的RAII，深入理解一下。 代码文件在此： 1Engine/Source/Runtime/Core/Public/Containers/LRUCache.h 一点一点看吧。 首先，这份代码先写了一个TLruCache的键比较器模板 12345678910111213141516171819/** * Default comparer for keys in TLruCache. * * @param KeyType The type of keys to compare. */template&lt;typename KeyType&gt;struct DefaultKeyComparer&#123;\t[[nodiscard]] static FORCEINLINE bool Matches(KeyType A, KeyType B)\t&#123; return (A == B);\t&#125;\t/** Calculates a hash index for a key. */\t[[nodiscard]] static FORCEINLINE uint32 GetKeyHash(KeyType Key)\t&#123; return GetTypeHash(Key);\t&#125;&#125;; Matches(KeyType A, KeyType B)主要判断两个键是否相等。[[nodiscard]]是C++17的属性，提醒用户必须使用返回值。FORCEINLINE就是UE的宏，如其名，强制内联以提升性能。这里用了return (A == B);也就是说KeyType类型必须实现==比较运算符。 GetKeyHash就是计算键的哈希值。 然后进入正题，TLruCache。首先把一堆接口函数折叠起来，看看私有成员： 123456789101112131415161718192021class TLruCache&#123;public:...public:...public:...protected:...public:...private:\t/** Set of entries for fast lookup. */\tTSet&lt;FCacheEntry*, FKeyFuncs&gt; LookupSet;\t/** Least recent item in the cache. */\tFCacheEntry* LeastRecent;\t/** Most recent item in the cache. */\tFCacheEntry* MostRecent;\t/** Maximum number of elements in the cache. */\tint32 MaxNumElements;&#125; 先了解一下私有成员：LookupSet就是一个哈希表，用来存储FCacheEntry*指针。LeastRecent应该就是指向最旧条目的那个指针。MostRecent就是最新的了。至于FCacheEntry为什么起这名呢？一会翻到了再看。 类的开头就是FCacheEntry结构体的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** An entry in the LRU cache. */\tstruct FCacheEntry\t&#123; /** The entry&#x27;s lookup key. */ KeyType Key; /** The less recent entry in the linked list. */ FCacheEntry* LessRecent; /** The more recent entry in the linked list. */ FCacheEntry* MoreRecent; /** The entry&#x27;s value. */ ValueType Value; /** * Create and initialize a new instance. * * @param InKey The entry&#x27;s key. * @param InValue The entry&#x27;s value. */ [[nodiscard]] FCacheEntry(const KeyType&amp; InKey, const ValueType&amp; InValue) : Key(InKey) , LessRecent(nullptr) , MoreRecent(nullptr) , Value(InValue) &#123; &#125; /** * Create a new instance with a default key value. * * @param InKey The entry&#x27;s key. */ [[nodiscard]] FCacheEntry(const KeyType&amp; InKey) : Key(InKey) , LessRecent(nullptr) , MoreRecent(nullptr) &#123; &#125; /** Add this entry before the given one. */ FORCEINLINE void LinkBefore(FCacheEntry* Other) &#123; LessRecent = Other; if (Other != nullptr) &#123; Other-&gt;MoreRecent = this; &#125; &#125; /** Remove this entry from the list. */ FORCEINLINE void Unlink() &#123; if (LessRecent != nullptr) &#123; LessRecent-&gt;MoreRecent = MoreRecent; &#125; if (MoreRecent != nullptr) &#123; MoreRecent-&gt;LessRecent = LessRecent; &#125; LessRecent = nullptr; MoreRecent = nullptr; &#125;\t&#125;;\t/** Lookup set key functions. */\tstruct FKeyFuncs : public BaseKeyFuncs&lt;FCacheEntry*, KeyType&gt;\t&#123; [[nodiscard]] FORCEINLINE static const KeyType&amp; GetSetKey(const FCacheEntry* Entry) &#123; return Entry-&gt;Key; &#125; [[nodiscard]] FORCEINLINE static bool Matches(KeyType A, KeyType B) &#123; return KeyComp::Matches(A, B); &#125; [[nodiscard]] FORCEINLINE static uint32 GetKeyHash(KeyType Key) &#123; return KeyComp::GetKeyHash(Key); &#125;\t&#125;; 先看 FCacheEntry 结构体。它是一个双向链表节点，包含四个成员：Key 和 Value 存储键值对数据；LessRecent 和 MoreRecent 是两个指针，用于链接节点。LessRecent 指向时间更早的节点（类似平常写的pre，next指针），MoreRecent 指向时间更晚的节点。链表的方向是从最新到最旧，每个节点通过这两个指针形成双向链接。 结构体提供了两个构造函数。第一个构造函数同时接收键和值，用于完整初始化条目，链表指针都设为 nullptr。第二个构造函数只接收键，用于需要延迟初始化值的场景（如 AddUninitialized_GetRef），此时值会使用默认构造或由调用者后续设置。 LinkBefore 方法将当前节点插入到指定节点之前。它先设置当前节点的 LessRecent 指向目标节点，如果目标节点存在，再将目标节点的 MoreRecent 指向当前节点。这样就把当前节点插入到了更靠近链表头部的位置。需要注意，这里只建立了局部连接，如果当前节点原本在链表中的其他位置，调用前通常需要先调用 Unlink 断开原有连接。 Unlink 方法将当前节点从双向链表中移除。它先检查前驱和后继节点，如果前驱存在，将前驱的 MoreRecent 指向当前节点的后继；如果后继存在，将后继的 LessRecent 指向当前节点的前驱。这样即使移除了当前节点，链表的其他部分仍然保持连接。最后将当前节点的两个指针都设为 nullptr，完成解除链接。上面这个插入删除操作就是链表结点的插入删除，没有什么高深的地方。只不过，这种操作在面试写的时候都是把插入删除方法封装在Node结点外面的，这里直接放在了结点的Struct里面，通过传递指针完成操作。 接下来是 FKeyFuncs 结构体，它继承自 BaseKeyFuncs&lt;FCacheEntry*, KeyType&gt;。这个适配器的作用是让 TSet 能够存储 FCacheEntry* 指针，同时使用 KeyType 作为查找键。TSet 需要从存储的元素中提取键，但存储的是指针类型，查找用的是键类型，所以需要这个适配器来桥接。 FKeyFuncs 提供了三个静态方法。GetSetKey 方法从 FCacheEntry* 指针中提取键，直接返回 Entry-&gt;Key，这样 TSet 就知道如何从存储的指针中获取键了。Matches 方法比较两个键是否相等，它委托给模板参数 KeyComp 的 Matches 方法，这样支持了自定义键比较逻辑。GetKeyHash 方法计算键的哈希值，同样委托给 KeyComp 的 GetKeyHash 方法，用于哈希表的定位和查找。 当 TSet 需要查找某个键时，它会使用 FKeyFuncs 来进行操作。TSet 遍历哈希桶中的 FCacheEntry* 指针，对每个指针调用 GetSetKey 得到对应的键，然后调用 Matches 方法比较该键与查找的键是否相等。如果相等就返回该指针。这样 TSet 就能存储指针类型，但用键类型进行查找，实现了类型转换的适配。 LRU所需的数据结构如上，定义完毕。 先把第一个public翻开，看看里面是什么： 12345678910111213141516171819202122232425262728public:\t/** Default constructor (empty cache that cannot hold any values). */\t[[nodiscard]] TLruCache() : LeastRecent(nullptr) , MostRecent(nullptr) , MaxNumElements(0)\t&#123;\t&#125;\t/** * Create and initialize a new instance. * * @param InMaxNumElements The maximum number of elements this cache can hold. */\t[[nodiscard]] TLruCache(int32 InMaxNumElements) : LeastRecent(nullptr) , MostRecent(nullptr) , MaxNumElements(InMaxNumElements)\t&#123; Empty(InMaxNumElements);\t&#125;\t/** Destructor. */\t~TLruCache()\t&#123; Empty();\t&#125; 构造函数和析构函数都比较好理解，就不展开看了。 再下面就是各种插入删除结点的接口，实现的思路和平常一样。 用工业级的代码与我们平常写的做一个对比。平常面试写的时候，类型单一，限制很多。见：https://leetcode.cn/problems/lru-cache-lcci/description/ 简易LRU实现将键类型固定为 int，UE引擎的LRU缓存采用模板设计，KeyType 可以是任意类型。这是适配器存在的原因之一，但不是唯一原因。 简易实现使用 unordered_map&lt;int, Node*&gt;，哈希表直接以 int 作为键进行存储和查找，类型匹配，无需额外转换。即便改为模板类以支持多种键类型，例如 unordered_map&lt;KeyType, Node*&gt;，类型仍然匹配，因为键类型就是模板参数，哈希表可以直接处理。 UE引擎的实现采用了不同的设计。它使用 TSet&lt;FCacheEntry*, FKeyFuncs&gt;，哈希表中存储的是 FCacheEntry* 指针，但查找时使用的是 KeyType，从而造成类型不匹配：存储的是指针类型，查找传入的是键类型，两者在类型系统上无法直接对应。为解决这个问题，UE 引入了 FKeyFuncs 适配器。适配器提供 GetSetKey 方法，告知哈希表如何从存储的 FCacheEntry* 指针中提取 KeyType 类型的键。当调用 LookupSet.Find(Key) 时，哈希表会遍历存储的指针，对每个指针调用 GetSetKey 提取键，再与传入的键比较，从而找到匹配的条目。 除了解决类型不匹配问题，适配器还承担了支持模板灵活性的职责。由于 UE 的 LRU 缓存是模板类，KeyType 可以是 int、string、自定义结构体等任意类型。不同键类型可能需要不同的比较和哈希方式，因此适配器还提供 Matches 和 GetKeyHash 方法，这些方法委托给模板参数 KeyComp 处理，使得可以自定义键类型的比较和哈希逻辑。这种设计虽然增加了代码复杂度，但提供了更大的灵活性，能够适应各种不同的键类型和使用场景。 总结来说，适配器的存在主要源于两个因素：一是存储指针但用键查找导致的类型不匹配问题，二是模板设计带来的类型灵活性需求。即使简易版本改成模板支持多种键类型，只要使用 unordered_map&lt;KeyType, Node*&gt; 这种类型匹配的设计仍然不需要适配器。UE 版本需要适配器主要是因为它选择了“存储指针 + 用键查找”这种设计模式，这种模式在提供灵活性的同时也带来了类型系统上的挑战，适配器就是用来解决这些问题。","tags":["UE","C++"]},{"title":"进程和线程到底有什么区别","path":"/2026/01/20/进程和线程到底有什么区别/","content":"说来惭愧。每次看到这个问题，就只能想到“进程拥有资源，线程拥有cpu”之类一点不严谨的描述，两年前学的408现在忘得差不多了，导致每次看到这些问题，总感觉有万匹飞奔的载着408知识的野马从我的大脑皮层轻轻掠过。 首先，想得确实没错。进程是资源分配的基本单位。资源有什么？第一个一定是有自己的虚拟地址空间，独立的虚拟内存，然后就是文件描述符表，环境变量，信号处理表等等，通过PCB记录资源的状态。主要目的就是提供一个隔离开的执行环境，一个进程停止或崩溃不会影响到其他进程。 线程，是cpu调度的基本单位。同一个进程内的线程是共享进程内的资源的。每个线程又有什么资源？线程需要有自己的id，程序计数器，寄存器集合以及自己的栈空间（重点），由TLB（线程控制块）来记录这些调度所需的信息。 注意，C++中，一个线程的崩溃可能会导致整个进程的终止。（可以引出线程的健壮性没有进程的高） 这是因为操作系统以进程为基本管理单元：所有线程共享同一地址空间和资源，当一个线程因段错误或未捕获异常等致命错误崩溃时，会触发进程级别的信号（如SIGSEGV），操作系统为避免数据不一致或资源泄漏，默认会终止整个进程。虽然可以通过信号处理或线程隔离技术尝试局部处理，但本质上操作系统将进程视为不可分割的整体，一个线程的致命错误被视为整个进程的失效。 在游戏开发中，选择多进程还是多线程是一个基于隔离性、性能、复杂性和稳定性等多维度考量的架构决策。其核心逻辑是将需要紧密协作、高频数据共享、且对延迟极度敏感的核心游戏循环置于多线程模型之下；而将那些需要独立生命周期、强故障隔离、或涉及外部安全性的边界系统部署为多进程。 游戏的核心运行时引擎几乎无一例外地重度依赖多线程，这是由现代游戏的性能需求决定的。游戏帧循环（Game Loop）是一个严格的实时系统，必须在大约16.6毫秒（对应60帧/秒）内完成逻辑更新、动画计算、物理模拟、场景管理、渲染命令提交等一系列繁重工作。为了将这些工作分摊到多个CPU核心上，引擎会采用精细的多线程分工。例如，主线程（通常称为游戏线程）负责驱动游戏逻辑、脚本执行和动画状态机；一个或多个渲染线程负责处理图形API调用、资源状态管理和命令缓冲区；独立的音频线程负责解码、混音和三维音效处理；庞大的后台线程池则用于处理异步资源加载、着色器编译、数据解压、以及通过任务并行系统（如虚幻引擎的Task Graph、Unity的Job System）来并行执行大量的同质计算，如视锥体剔除、粒子系统更新、蒙皮矩阵计算等。这些线程之间需要毫秒级的同步和极高频的内存数据交换（如传递变换矩阵、可见物体列表），使用线程共享内存是唯一能满足这种性能要求的方式。 然而在游戏开发和运行的特定边界场景下，多进程架构则展现出不可替代的价值。首要场景是开发工具链与运行时分离。游戏编辑器（如Unreal Editor、Unity Editor）通常运行一个独立的游戏进程（Play-in-Editor）来预览游戏效果。这种进程级隔离至关重要：当测试的游戏崩溃时，它只会带走这个预览进程，而宝贵的编辑器工作状态（如正在编辑的关卡、未保存的资源）得以完好无损，极大提升了开发效率和稳定性，并支持安全的热重载功能。第二个关键场景是安全与反作弊。在在线多人游戏中，反外挂模块（如反作弊客户端）通常以一个高权限的独立进程运行，通过进程间通信监控游戏主进程的内存和操作。这种隔离增加了恶意软件进行代码注入和数据篡改的难度。第三个场景是模块化与可维护性。一些大型游戏或引擎允许将相对独立的功能模块（如特定的物理模拟器、语音聊天服务、视频录制工具）作为插件进程运行。这样单个插件的崩溃或更新无需重启整个游戏主进程。在服务器端架构中，多进程也更为常见。一个大型多人在线游戏的服务器集群可能由多个专有进程组成，例如独立的登录认证进程、世界逻辑进程、数据库代理进程等，这种分离有助于资源管理、独立扩展和故障隔离。 后面可以开始了解一下UE多线程的一些概念了： [原创]UE基础—多线程（一） - 凌泽的文章 - 知乎https://zhuanlan.zhihu.com/p/553957069 现代C++的内存模型和高性能的多线程编程：https://skyscribe.github.io/post/2019/11/04/cpp-memory-model-and-order/","tags":["C++","OS"]},{"title":"如何只在栈上或只在堆上创建类","path":"/2026/01/20/如何只在栈上或只在堆上创建类/","content":"如何只允许在堆上创建类？第一种思路，就是构造函数私有化，如下： 1234567891011121314#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;private:\tOnlyOnHeap()=default;&#125;;int main()&#123;\tOnlyOnHeap o1;&#125; 如果尝试在栈上构建此对象，则会报错，信息如下： 1&quot;OnlyOnHeap::OnlyOnHeap()&quot; (已声明 所在行数:7，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnHeap.h&quot;) 不可访问 但是，此时如果想实现在堆上构造，new也用不了了。此时只能写一个显式的静态函数去调用私有的构造函数去创建类并返回类的指针，如下： 12345678910111213#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;private:\tOnlyOnHeap()=default;&#125;; 此时就可以通过create函数去间接在堆上构造这个类了。 此时发现一个问题：如果使用赋值，还是可以赋值到一个栈上的对象并且不报错： 12OnlyOnHeap *o1=OnlyOnHeap::Create();OnlyOnHeap o2 = *o1;//没有报错 此时还需要禁用拷贝构造和拷贝赋值函数： 123456789101112131415#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\tOnlyOnHeap()=default;&#125;; 换一种思路。如果要禁用在栈上构造对象，程序退出栈的时候会自动调用栈上类的析构函数。编译器会把析构函数插入到程序中，可以把析构函数设为private，是否可行？如下： 123456789101112131415161718192021#pragma onceclass OnlyOnHeap&#123;public:\tOnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\t~OnlyOnHeap() = default;&#125;;int main()&#123; OnlyOnHeap o1;//尝试在栈上创建对象&#125; 此时报错： 1&quot;OnlyOnHeap::~OnlyOnHeap() noexcept&quot; (已声明 所在行数:18，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnHeap.h&quot;) 不可访问 所以，私有化析构函数也可以防止程序在栈上创建类。 最佳实践的写法如下，核心就是手写创建和销毁，间接去调用new和delete去管理堆上的内存。 1234567891011121314151617181920212223#pragma onceclass OnlyOnHeap&#123;public: static OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tvoid destory()\t&#123; delete this;\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\tOnlyOnHeap() = default;\t~OnlyOnHeap() = default;&#125;; 如何只允许在栈上创建类？这个就好写多了。平时在堆上创建类有两种方法，一种是用new，一种是malloc。 禁止使用new，就把new的运算符禁用即可，别忘了数组也要禁用。 123456789101112#pragma onceclass OnlyOnStack&#123;public:\tOnlyOnStack()=default;\t~OnlyOnStack() = default;\tvoid* operator new(size_t) = delete;\tvoid* operator new[](size_t) = delete;\tvoid* operator new(size_t, void* p)=delete; void* operator new[](size_t, void* p) = delete; 如果是malloc来创建对象。这里理解一下如何通过malloc分配的内存在堆上创建对象： 1void* memory = malloc(sizeof(MyClass)); // 仅仅分配原始内存 malloc函数只分配一堆字节内存空间，并不会调用类的构造函数，返回的是一个void*指针。 如果我们用new操作的话，过程如下： 1234MyClass* obj = new MyClass();// 1. void* memory = operator new(sizeof(MyClass)); // 分配内存// 2. obj = static_cast&lt;MyClass*&gt;(memory);// 3. obj-&gt;MyClass(); // 调用构造函数（编译器隐式调用） 一般如果显式地写malloc，后面是这么构造对象的： 123456// 其实也就是手动完成上面三步void* memory = malloc(sizeof(MyClass)); // 1. 分配内存（替代operator new）MyClass* obj = new(memory) MyClass(); // 2. 构造对象// 使用对象...obj-&gt;~MyClass(); // 3. 手动析构free(memory); // 4. 释放内存 所以还要禁用掉placement new，也就是 1void* operator new(size_t, void* p)=delete; 此时如果尝试在堆上创建类： 1OnlyOnStack* os = new OnlyOnStack(); 就会报错： 1无法引用 函数 &quot;OnlyOnStack::operator new(size_t)&quot; (已声明 所在行数:9，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnStack.h&quot;) -- 它是已删除的函数","tags":["C++"]},{"title":"多继承类的虚函数表会有几张？","path":"/2026/01/12/多继承类的虚函数表会有几张？/","content":"对于多继承类的理解，我一直感到疑惑。为什么要使用多继承呢？为什么不用组合呢？这个疑惑一会儿再来解答。今天先来探索一下多继承类下，虚函数表与虚函数表指针在内存布局的情况。 在运行任何测试代码之前，我先提出我目前的理解。如果先不考虑有菱形继承的情况。我们有一个电动车ElectricCar类，它继承了两个类：一个是Vehicle交通工具类（电动车是交通工具），一个是Electronic电子设备类（不得不说确实是电子设备）。它的内存布局我目前的理解长这样： 123456Vehicle的虚函数表指针Vehicle的成员对象（int，string等）Electronic的虚函数表指针Electronic的成员对象ElectricCar的虚函数表指针ElectricCar的成员对象 按照我目前的理解，为了实现多态（也就是可以用基类的指针指向派生类的对象）的话，好像必须要保留每一个基类对象的虚函数表指针。 口说无凭。来看看代码测试： 首先定义了三个基类，分别是交通工具类，电子设备类和导航类（工程里还是用组合好） 123456789101112131415161718192021222324252627282930313233343536373839404142class Vehicle &#123;public: virtual void vehicle_start() &#123; cout &lt;&lt; &quot;Vehicle::vehicle_start()&quot; &lt;&lt; endl; &#125; virtual void vehicle_stop() &#123; cout &lt;&lt; &quot;Vehicle::vehicle_stop()&quot; &lt;&lt; endl; &#125; virtual ~Vehicle() &#123; cout &lt;&lt; &quot;Vehicle destructor&quot; &lt;&lt; endl; &#125;&#125;;class Electronic &#123;public: virtual void electronic_powerOn() &#123; cout &lt;&lt; &quot;Electronic::electronic_powerOn()&quot; &lt;&lt; endl; &#125; virtual void electronic_powerOff() &#123; cout &lt;&lt; &quot;Electronic::electronic_powerOff()&quot; &lt;&lt; endl; &#125; virtual ~Electronic() &#123; cout &lt;&lt; &quot;Electronic destructor&quot; &lt;&lt; endl; &#125;&#125;;class Navigable &#123;public: virtual void navigable_setDestination() &#123; cout &lt;&lt; &quot;Navigable::navigable_setDestination()&quot; &lt;&lt; endl; &#125; virtual ~Navigable() &#123; cout &lt;&lt; &quot;Navigable destructor&quot; &lt;&lt; endl; &#125;&#125;; 又定义了派生类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 派生类1：电动车（继承自Vehicle和Electronic）class ElectricCar : public Vehicle, public Electronic &#123;public: // 重写Vehicle的虚函数 virtual void vehicle_start() override &#123; cout &lt;&lt; &quot;ElectricCar::vehicle_start() [静音启动]&quot; &lt;&lt; endl; &#125; // 重写Electronic的虚函数 virtual void electronic_powerOn() override &#123; cout &lt;&lt; &quot;ElectricCar::electronic_powerOn() [智能启动]&quot; &lt;&lt; endl; &#125; // 新增的虚函数 virtual void electricCar_charge() &#123; cout &lt;&lt; &quot;ElectricCar::electricCar_charge() [专用充电]&quot; &lt;&lt; endl; &#125; virtual ~ElectricCar() &#123; cout &lt;&lt; &quot;ElectricCar destructor&quot; &lt;&lt; endl; &#125;&#125;;// 派生类2：智能电动车（继承自三个基类）class SmartElectricCar : public Vehicle, public Electronic, public Navigable &#123;public: // 重写Vehicle的虚函数 virtual void vehicle_start() override &#123; cout &lt;&lt; &quot;SmartElectricCar::vehicle_start() [语音控制启动]&quot; &lt;&lt; endl; &#125; // 重写Electronic的虚函数 virtual void electronic_powerOff() override &#123; cout &lt;&lt; &quot;SmartElectricCar::electronic_powerOff() [延时关机]&quot; &lt;&lt; endl; &#125; // 重写Navigable的虚函数 virtual void navigable_setDestination() override &#123; cout &lt;&lt; &quot;SmartElectricCar::navigable_setDestination() [AI推荐路线]&quot; &lt;&lt; endl; &#125; // 新增的虚函数 virtual void smartElectricCar_autoPilot() &#123; cout &lt;&lt; &quot;SmartElectricCar::smartElectricCar_autoPilot() [自动驾驶]&quot; &lt;&lt; endl; &#125; virtual ~SmartElectricCar() &#123; cout &lt;&lt; &quot;SmartElectricCar destructor&quot; &lt;&lt; endl; &#125;&#125;; 首先来测试不同类的大小 12345678void testVTablePointers() &#123; cout &lt;&lt; &quot;======= 测试不同类的对象大小 ======= &quot;; cout &lt;&lt; &quot;sizeof(Vehicle): &quot; &lt;&lt; sizeof(Vehicle) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(Electronic): &quot; &lt;&lt; sizeof(Electronic) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(Navigable): &quot; &lt;&lt; sizeof(Navigable) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(ElectricCar): &quot; &lt;&lt; sizeof(ElectricCar) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(SmartElectricCar): &quot; &lt;&lt; sizeof(SmartElectricCar) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;&#125; 测试结果： 1234567======= 测试不同类的对象大小 =======sizeof(Vehicle): 8 bytessizeof(Electronic): 8 bytessizeof(Navigable): 8 bytessizeof(ElectricCar): 16 bytessizeof(SmartElectricCar): 24 bytes 在64位系统中，一个指针通常为8字节。从测试结果可以看出：ElectricCar有2个vptr，所以有16字节SmartElectricCar有3个vptr，所以有24字节 接着看一看多继承下的指针转换 我一直认为，当一个基类指针指向派生类时，这个基类指针的地址就是派生类最头的那个虚函数表指针的地址。但这好像只适用于单继承。 1234567891011121314151617181920// 测试多继承下的指针转换void testPointerCasting() &#123; cout &lt;&lt; &quot; ======= 测试多继承下的指针转换 ======= &quot;; ElectricCar electricCar; cout &lt;&lt; &quot; 1. ElectricCar对象地址: &quot; &lt;&lt; &amp;electricCar &lt;&lt; endl; // 转换为不同基类指针 Vehicle* vehiclePtr = &amp;electricCar; Electronic* electronicPtr = &amp;electricCar; cout &lt;&lt; &quot;2. Vehicle* 指针值: &quot; &lt;&lt; vehiclePtr &lt;&lt; endl; cout &lt;&lt; &quot;3. Electronic* 指针值: &quot; &lt;&lt; electronicPtr &lt;&lt; endl; // 计算偏移量 cout &lt;&lt; &quot;4. 两个指针的差值: &quot; &lt;&lt; reinterpret_cast&lt;char*&gt;(electronicPtr) - reinterpret_cast&lt;char*&gt;(vehiclePtr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;&#125; 测试结果： 12345678910======= 测试多继承下的指针转换 =======1. ElectricCar对象地址: 000000CC36AFF8682. Vehicle* 指针值: 000000CC36AFF8683. Electronic* 指针值: 000000CC36AFF8704. 两个指针的差值: 8 字节ElectricCar destructorElectronic destructorVehicle destructor 可以看出，和单继承不同。多继承时，不同的基类子对象在派生类中位置不同。Vehicle子对象在ElectricCar的开始位置而Electronic子对象在Vehicle子对象之后。正因如此，二者的指针地址并不一样，他们各自指向了自己的那个子对象位置的开头。相差的8字节便是一个虚函数表指针的大小。 现在可以认为，两个派生类的内存布局如下： 123456789101112131415ElectricCar对象布局： [vptr_Vehicle] → Vehicle虚函数表 [Vehicle数据成员] [vptr_Electronic] → Electronic虚函数表 [Electronic数据成员] [ElectricCar新增数据成员] SmartElectricCar对象布局： [vptr_Vehicle] → Vehicle虚函数表 [Vehicle数据成员] [vptr_Electronic] → Electronic虚函数表 [Electronic数据成员] [vptr_Navigable] → Navigable虚函数表 [Navigable数据成员] [SmartElectricCar新增数据成员] 一个很重要的点：当通过基类指针调用虚函数时，编译器会自动调整this指针。 用一个直观的多继承的内存布局图： 123456789101112131415161718地址 内容 大小0x628C0FF328 ┌─────────────────────┐ │ Base1的vptr │ 8字节0x628C0FF330 ├─────────────────────┤ │ Base1::b1_data=100 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF338 ├─────────────────────┤ │ Base2的vptr │ 8字节 0x628C0FF340 ├─────────────────────┤ │ Base2::b2_data=200 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF348 ├─────────────────────┤ │ Derived::d_data=300 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF350 └─────────────────────┘ Derived d;Base2* pb2 = &d; // pb2指向0x628C0FF338，而不是内存最头的0x628C0FF328 调用pb2-&gt;b2_func()时，主要的步骤如下： 通过pb2找到Base2的vptr 通过vptr找到虚函数表 调用正确的函数 函数内部的this指针就是pb2（指向Base2子对象） 虚函数表里到底有什么？既然每个基类都有自己的虚函数表指针，那么这些虚函数表里到底存储了什么内容呢？ 对于ElectricCar类，它有两个虚函数表： Vehicle的虚函数表：存储Vehicle的虚函数地址 Electronic的虚函数表：存储Electronic的虚函数地址 但是，当ElectricCar重写了某些虚函数时，这些虚函数表里的内容会发生变化。让我写个测试来验证一下： 12345678910111213141516171819202122232425262728// 测试虚函数表的内容void testVTableContent() &#123; cout &lt;&lt; &quot; ======= 测试虚函数表内容 ======= &quot;; ElectricCar electricCar; // 获取Vehicle虚函数表 typedef void(*FuncPtr)(); void** vtable_vehicle = *(void***)&amp;electricCar; cout &lt;&lt; &quot;Vehicle虚函数表内容：&quot; &lt;&lt; endl; cout &lt;&lt; &quot; [0] vehicle_start: &quot; &lt;&lt; vtable_vehicle[0] &lt;&lt; endl; cout &lt;&lt; &quot; [1] vehicle_stop: &quot; &lt;&lt; vtable_vehicle[1] &lt;&lt; endl; cout &lt;&lt; &quot; [2] ~Vehicle: &quot; &lt;&lt; vtable_vehicle[2] &lt;&lt; endl; // 获取Electronic虚函数表（需要偏移8字节） void** vtable_electronic = *(void***)((char*)&amp;electricCar + 8); cout &lt;&lt; &quot; Electronic虚函数表内容：&quot; &lt;&lt; endl; cout &lt;&lt; &quot; [0] electronic_powerOn: &quot; &lt;&lt; vtable_electronic[0] &lt;&lt; endl; cout &lt;&lt; &quot; [1] electronic_powerOff: &quot; &lt;&lt; vtable_electronic[1] &lt;&lt; endl; cout &lt;&lt; &quot; [2] ~Electronic: &quot; &lt;&lt; vtable_electronic[2] &lt;&lt; endl; // 调用验证 cout &lt;&lt; &quot; 通过函数指针调用验证：&quot; &lt;&lt; endl; ((FuncPtr)vtable_vehicle[0])(); // 应该调用ElectricCar::vehicle_start ((FuncPtr)vtable_electronic[0])(); // 应该调用ElectricCar::electronic_powerOn&#125; 测试结果会显示，Vehicle虚函数表中的vehicle_start指向的是ElectricCar::vehicle_start，而不是Vehicle::vehicle_start。这说明派生类重写的虚函数会替换基类虚函数表中的对应项。 但是，ElectricCar新增的虚函数electricCar_charge()会放在哪里呢？答案是：它会被添加到第一个基类（Vehicle）的虚函数表中。这是因为派生类新增的虚函数需要能够通过派生类指针调用，而第一个基类指针通常指向对象的起始位置。 多继承时，派生类自己的虚函数放在哪里？（引用自博客园某篇，忘复制地址了） 为什么派生类的虚函数是追加在第一张虚表的后面？ 请看下面的一段汇编（没学过汇编，不献丑）结论： 派生类的虚函数是追加在第一张虚表的后面。当需要使用派生类的虚函数是，用第一张表的虚函数表指针指向派生类的虚函数即可。（个人观点）下面的汇编也应该是这样：1，找到虚函数表的起始地址，2.找到派生类的虚函数偏移，3.使用虚函数表指针指向派生类的虚函数。 123456789101112Copy Highlighter-hljs\tderiveA *pda = &amp;da;00A7A02E lea eax,[ebp-28h] 00A7A031 mov dword ptr [ebp-34h],eax pda-&gt;print();00A7A034 mov eax,dword ptr [ebp-34h] 00A7A037 mov edx,dword ptr [eax] 00A7A039 mov esi,esp 00A7A03B mov ecx,dword ptr [ebp-34h] 00A7A03E mov eax,dword ptr [edx+4] 00A7A041 call eax 00A7A043 cmp esi,esp 00A7A045 call 00A714C4 构造函数和析构函数的调用顺序12345678910111213141516171819202122232425// 添加一些数据成员来观察构造顺序class Vehicle &#123;public: int vehicle_id; Vehicle() : vehicle_id(1) &#123; cout &lt;&lt; &quot;Vehicle constructor&quot; &lt;&lt; endl; &#125; &#125;;class Electronic &#123;public: int electronic_id; Electronic() : electronic_id(2) &#123; cout &lt;&lt; &quot;Electronic constructor&quot; &lt;&lt; endl; &#125; &#125;;void testConstructionOrder() &#123; cout &lt;&lt; &quot; ======= 测试构造和析构顺序 ======= &quot;; cout &lt;&lt; &quot;创建ElectricCar对象：&quot; &lt;&lt; endl; ElectricCar ec; cout &lt;&lt; &quot; 销毁ElectricCar对象：&quot; &lt;&lt; endl;&#125; 测试结果： 12345678910======= 测试构造和析构顺序 =======创建ElectricCar对象：Vehicle constructorElectronic constructorElectricCar constructor销毁ElectricCar对象：ElectricCar destructorElectronic destructorVehicle destructor 可以看出： 构造顺序：按照继承列表的顺序，从左到右依次构造基类，最后构造派生类 析构顺序：与构造顺序完全相反，先析构派生类，然后从右到左析构基类 函数名冲突：二义性问题多继承最容易遇到的问题就是函数名冲突。如果两个基类有同名的函数（即使参数不同），派生类在调用时就会产生二义性。 12345678910111213141516171819202122class Vehicle &#123;public: void start() &#123; cout &lt;&lt; &quot;Vehicle::start()&quot; &lt;&lt; endl; &#125;&#125;;class Electronic &#123;public: void start() &#123; // 同名函数！ cout &lt;&lt; &quot;Electronic::start()&quot; &lt;&lt; endl; &#125;&#125;;class ElectricCar : public Vehicle, public Electronic &#123;public: void test() &#123; // start(); // 错误！二义性，不知道调用哪个 Vehicle::start(); // 正确：明确指定基类 Electronic::start(); // 正确：明确指定基类 &#125;&#125;; 解决方法有几种： 使用作用域解析符：Vehicle::start() 或 Electronic::start() 在派生类中重写：在派生类中定义一个start()函数，内部调用需要的基类版本 使用using声明：using Vehicle::start; 将某个基类的函数引入派生类作用域 12345class ElectricCar : public Vehicle, public Electronic &#123;public: using Vehicle::start; // 引入Vehicle::start到当前作用域 // 现在可以直接调用start()，会调用Vehicle::start()&#125;; 为什么要用多继承？为什么不用组合？现在来解答我一开始的疑惑。 多继承的适用场景： 接口实现：当一个类需要实现多个接口时，多继承是自然的选择。比如Java的接口、C++的纯虚基类。 1234567891011121314151617// 接口类class IReadable &#123;public: virtual void read() = 0;&#125;;class IWritable &#123;public: virtual void write() = 0;&#125;;// 文件类实现两个接口class File : public IReadable, public IWritable &#123;public: void read() override &#123; /* ... */ &#125; void write() override &#123; /* ... */ &#125;&#125;; 混入（Mixin）模式：提供可复用的功能片段。 12345678910111213141516// 混入类：提供序列化功能class Serializable &#123;public: virtual string serialize() = 0;&#125;;// 混入类：提供日志功能class Loggable &#123;public: virtual void log() = 0;&#125;;// 业务类通过多继承获得这些功能class User : public Serializable, public Loggable &#123; // ...&#125;; “是一个”关系的多重性：当派生类确实是多个基类的特化时。 比如我们的ElectricCar，它确实”是一个”Vehicle，也”是一个”Electronic。这种情况下，多继承在语义上是合理的。 总结 多继承类有几个虚函数表？ 答案：有几个基类（有虚函数的），就有几个虚函数表指针。 内存布局：每个基类子对象在派生类中都有独立的内存区域，包括自己的虚函数表指针。 指针转换：不同基类指针指向派生类对象时，地址可能不同，编译器会自动调整。 this指针调整：通过不同基类指针调用虚函数时，this指针会自动调整到正确的子对象位置。 构造/析构顺序：按继承列表顺序构造，逆序析构。 二义性处理：同名函数冲突需要用作用域解析符或using声明解决。 但这里没有提到多继承下虚析构的一些细节，后面再说吧。","tags":["C++","面向对象"]},{"title":"又谈右值引用与移动构造函数","path":"/2025/12/24/又谈右值与移动构造函数/","content":"感觉又来谈谈右值引用了，这次带上了移动构造函数一起谈。初学移动构造函数时，我看到的大致能总结成这么一句话：资源的转移而非拷贝。由于我初学C++（之前写算法题不能算学了C++），很多隐藏的东西我很难搞懂，很多描述令我抓耳挠腮：有的描述说，右值引用可以延长对象的生命周期。怎么个延长法？本来在栈上的东西出了作用域就无了，延长的是谁的生命周期？对于移动构造函数来说，延长的是整个临时对象的生命周期吗？ 答案在C++ Primer里说的其实已经挺清楚了： 与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。StrVec的析构函数在first_free上调用deallocate。如果我们忘记了改变s.first_free，则销毁移后源对象就会释放掉我们刚刚移动的内存。 此处要注意两点：一是右值引用让编译器知道，这个引用（就是一个存地址的指针）绑定的是一个临时对象，该对象在之后不会被用到，那么编译器就可以安全地转移资源。 什么是资源？一个类A有如下成员变量： 123456class A&#123;private: int i; std::string s;&#125; 由于我实在头脑不清晰。我在最开始理解移动构造的时候，认为这种简单类型i也要进行移动。如果这个对象创建到了栈上，比如这样： 12345int main()&#123;\tA a1(1,&quot;a1&quot;);...&#125; 那么i这个变量也应该在栈上。那既然如此，我愚蠢地认为，出现了一个右值引用，引用到了栈上的这个i的变量。那函数结束后，作用域结束，该函数的栈都空了，哪去找这个i的变量引用？ 1234A(A&amp;&amp; other) noexcept : a(other.a), s(std::move(other.s)) &#123; std::cout &lt;&lt; &quot;Move Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; other.a = 0; &#125; 但是对于string来说比较好理解。string这个字符串实际是建立在堆上的，这里实际上拿的是一个指针。那么右值引用就告诉编译器，这是块后面不会再用到的资源，可以进行转移。于是把这个指针指向的地址（这个地址在堆）复制到新的对象里就好了。不需要在堆里再做资源的拷贝。但一定要注意。在退出移动构造函数之前，如果是自己定义的持有资源的对象，一定要将其清零。不然原对象会销毁我们已经移交了控制权的那块资源。此处string没有做是因为：std::move(other.s)来初始化新对象的s，这会调用std::string的移动构造函数），所以other.s已经被std::string的移动构造函数置为空字符串 那么这种简单变量怎么办呢？ 这时候愚蠢的我发现，移动构造函数可以我们自己写，一般直接赋值即可，也就是简单的拷贝操作： 12345678910// 移动赋值 A&amp; operator=(A&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; a = other.a; s = std::move(other.s); other.a = 0; std::cout &lt;&lt; &quot;Move Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; 这就解决了我的疑惑。我总是认为移动，就是都得移动！一点拷贝都不要沾！实际上是个非常片面、错误的想法。所以，移动构造函数主要利于持有资源的对象（简单理解为指针就行，就是避免把指针指向的东西再拷贝一遍，减少内存开销）。如果对象就只有一堆简单变量而已，那么写的移动构造函数和拷贝构造就没什么区别了。 再回到左右值，右值引用。 我真的很害怕这种文字游戏，用高级概念来解释高级概念，只会让头脑本就不清晰的我变得更笨。 把这些名词放到一遍。本质上，就是编译器对这些地址存放的东西打标记。编译器关心什么呢？它要知道的是：表达式有值类别(value category)以及类型系统附带生命周期信息。 我一开始会把“右值引用”和“右值本身”混为一谈，觉得 T&amp;&amp; 就意味着“这是一个右值”。其实更准确的理解是：右值引用并不是右值本身，而是一种给右值起别名的能力。右值对象通常是临时值，它本身可以直接绑定到右值引用上，例如： 1A&amp;&amp; r = A(); 在编译器眼里，这段代码等价于：先创建了一个临时对象 A()，然后给它取了一个名字 r，于是这个临时对象就有了一个别名。但需要注意的是，这个对象依然被编译器标记为“可被消耗的对象”，也就是允许对它进行资源转移。所以接下来完全可以写： 1A b = std::move(r); 这意味着右值引用可以捕获一个“将要销毁的对象”，并把这种“可以被破坏性使用”的标记继续传递下去。std::move 的本质其实非常简单，它甚至可以写成这样： 1234template&lt;class T&gt;T&amp;&amp; move(T&amp; t) &#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125; 它并不执行任何移动操作，只是把一个左值转换成右值引用类型，从而告诉编译器允许对它进行移动语义上的优化。真正的移动行为仍然发生在移动构造函数或移动赋值运算符中。 接下来有一个很容易误解的地方：右值引用变量本身是左值。 123A&amp;&amp; x = A();A y = x; // 这里会调用拷贝A z = std::move(x); // 这里才会调用移动 原因很简单：只要一个对象有名字，它就被编译器视为可寻址对象，因此具有左值语义；但它的类型却是 T&amp;&amp;，这意味着我们可以显式地把它再转换回右值类别。因此可以总结为：右值引用变量，其实是一个“绑定到右值上的左值”。它只是提供了一条绑定右值的渠道，而不是永久地把该对象钉死为右值。从优化角度看，右值引用最大的价值在于给编译器一个静态承诺：这个对象的生命周期即将结束，因此可以放心地转移资源，避免额外拷贝。 用一句话来说，右值引用代表的是：生命周期和使用方式上的承诺。编译器据此可以跨函数传递“允许破坏源对象”的权限，从而减少堆分配、避免深拷贝、优化容器重分配，并允许在返回大对象时仍然保持零开销。在拷贝构造函数中，编译器必须保证语义不变，因此不能破坏源对象（随便拿到别的对象拥有的资源并改变就是破坏了），只能重新开辟空间并复制内容；而在移动构造函数中，编译器已经得到了“可以破坏源对象”的授权，于是资源可以直接转移，爱怎么破坏就怎么破坏（），源对象只需要被置为空即可。那这么理解右值引用比较好，它把允许破坏源对象这件事情合法化并显式化，同时也给了编译器充分的优化空间。 这个网站好用啊：https://godbolt.org/ 写了个测试代码，可以看看汇编在干什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;string&gt;class A &#123;public: int a; std::string s; // 普通构造 A(int la, std::string ls) : a(la), s(std::move(ls)) &#123; std::cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; // 拷贝构造 A(const A&amp; other) : a(other.a), s(other.s) &#123; std::cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; // 移动构造 A(A&amp;&amp; other) noexcept : a(other.a), s(std::move(other.s)) &#123; std::cout &lt;&lt; &quot;Move Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; other.a = 0; &#125; // 拷贝赋值 A&amp; operator=(const A&amp; other) &#123; if (this != &amp;other) &#123; a = other.a; s = other.s; std::cout &lt;&lt; &quot;Copy Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; // 移动赋值 A&amp; operator=(A&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; a = other.a; s = std::move(other.s); other.a = 0; std::cout &lt;&lt; &quot;Move Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; ~A() &#123; std::cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;&#125;;// 返回值测试A return_by_value() &#123; A temp(100, &quot;temp&quot;); return temp; // NRVO/移动构造&#125;// 返回引用测试A&amp; return_by_ref(A&amp; obj) &#123; return obj;&#125;// 返回右值引用测试A&amp;&amp; return_by_rvalue_ref(A&amp; obj) &#123; return std::move(obj);&#125;int main() &#123; std::cout &lt;&lt; &quot;=== 创建 a1 === &quot;; A a1(1, &quot;a1&quot;); std::cout &lt;&lt; &quot; === 拷贝构造 a2(a1) === &quot;; A a2(a1); std::cout &lt;&lt; &quot; === 移动构造 a3(std::move(a1)) === &quot;; A a3(std::move(a1)); std::cout &lt;&lt; &quot; === 拷贝赋值 a2 = a3 === &quot;; a2 = a3; std::cout &lt;&lt; &quot; === 移动赋值 a3 = std::move(a2) === &quot;; a3 = std::move(a2); std::cout &lt;&lt; &quot; === 返回值测试 === &quot;; A a4 = return_by_value(); std::cout &lt;&lt; &quot; === 返回引用测试 === &quot;; A&amp; ref_a = return_by_ref(a3); std::cout &lt;&lt; &quot;ref_a.s = &quot; &lt;&lt; ref_a.s &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot; === 返回右值引用测试 === &quot;; A a5 = return_by_rvalue_ref(a3); std::cout &lt;&lt; &quot; === End of main === &quot;;&#125; 执行结果： 12345678910111213141516171819202122232425262728293031323334E:\\UnrealWorld\\project\\Learncpp\\x64\\Debug\\Learncpp.exe=== 创建 a1 ===Construct: a1, a=1=== 拷贝构造 a2(a1) ===Copy Construct: a1, a=1=== 移动构造 a3(std::move(a1)) ===Move Construct: a1, a=1=== 拷贝赋值 a2 = a3 ===Copy Assign: a1, a=1=== 移动赋值 a3 = std::move(a2) ===Move Assign: a1, a=1=== 返回值测试 ===Construct: temp, a=100=== 返回引用测试 ===ref_a.s = a1=== 返回右值引用测试 ===Move Construct: a1, a=1=== End of main ===Destruct: a1, a=1Destruct: temp, a=100Destruct: , a=0Destruct: , a=0Destruct: , a=0Process finished with exit code 0. 汇编长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505# License: MSVC Proprietary# The use of this compiler is only permitted for internal evaluation purposes and is otherwise governed by the MSVC License Agreement.# See https://visualstudio.microsoft.com/license-terms/vs2022-ga-community/$SG35785 DB &#x27;temp&#x27;, 00H ORG $+3$SG35831 DB &#x27;=== &#x27;, 0e5H, 088H, 09bH, 0e5H, 0bbH, 0baH, &#x27; a1 ===&#x27;, 0aH DB 00H ORG $+1$SG35832 DB &#x27;a1&#x27;, 00H ORG $+1$SG35833 DB 0aH, &#x27;=== &#x27;, 0e6H, 08bH, 0b7H, 0e8H, 0b4H, 09dH, 0e6H, 09eH DB 084H, 0e9H, 080H, 0a0H, &#x27; a2(a1) ===&#x27;, 0aH, 00H ORG $+2$SG35834 DB 0aH, &#x27;=== &#x27;, 0e7H, 0a7H, 0bbH, 0e5H, 08aH, 0a8H, 0e6H, 09eH DB 084H, 0e9H, 080H, 0a0H, &#x27; a3(std::move(a1)) ===&#x27;, 0aH, 00H ORG $+7$SG35835 DB 0aH, &#x27;=== &#x27;, 0e6H, 08bH, 0b7H, 0e8H, 0b4H, 09dH, 0e8H, 0b5H DB 08bH, 0e5H, 080H, 0bcH, &#x27; a2 = a3 ===&#x27;, 0aH, 00H ORG $+1$SG35836 DB 0aH, &#x27;=== &#x27;, 0e7H, 0a7H, 0bbH, 0e5H, 08aH, 0a8H, 0e8H, 0b5H DB 08bH, 0e5H, 080H, 0bcH, &#x27; a3 = std::move(a2) ===&#x27;, 0aH, 00H ORG $+6$SG35837 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 080H DB 0bcH, 0e6H, 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; ===&#x27;, 0aH, 00H ORG $+6$SG35838 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 0bcH DB 095H, 0e7H, 094H, 0a8H, 0e6H, 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; &#x27; DB &#x27;===&#x27;, 0aH, 00H ORG $+3$SG35839 DB 0aH, 00H ORG $+6$SG35840 DB &#x27;ref_a.s = &#x27;, 00H ORG $+5$SG35841 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 08fH DB 0b3H, 0e5H, 080H, 0bcH, 0e5H, 0bcH, 095H, 0e7H, 094H, 0a8H, 0e6H DB 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; ===&#x27;, 0aH, 00H ORG $+5$SG35842 DB 0aH, &#x27;=== End of main ===&#x27;, 0aH, 00H`string&#x27; DB &#x27;Destruct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Move Assign: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Copy Assign: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Move Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Copy Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;, a=&#x27;, 00H ; `string&#x27;`string&#x27; DB 0aH, 00H ; `string&#x27;tv79 = 32this$ = 64la$ = 72ls$ = 80A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) PROC ; A::A, COMDAT$LN5: mov QWORD PTR [rsp+24], r8 mov DWORD PTR [rsp+16], edx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov ecx, DWORD PTR la$[rsp] mov DWORD PTR [rax], ecx mov rcx, QWORD PTR ls$[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv79[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv79[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rcx, QWORD PTR ls$[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ENDP ; A::Atv78 = 32this$ = 64other$ = 72A::A(A const &amp;) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv78[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv78[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(A const &amp;) ENDP ; A::Atv80 = 32this$ = 64other$ = 72A::A(A &amp;&amp;) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv80[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv80[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rax, QWORD PTR other$[rsp] mov DWORD PTR [rax], 0 mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(A &amp;&amp;) ENDP ; A::Atv76 = 32this$ = 64other$ = 72A &amp; A::operator=(A const &amp;) PROC ; A::operator=, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR other$[rsp] cmp QWORD PTR this$[rsp], rax je $LN2@operator mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator=(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator= mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv76[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv76[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1$LN2@operator: mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A &amp; A::operator=(A const &amp;) ENDP ; A::operator=tv79 = 32this$ = 64other$ = 72A &amp; A::operator=(A &amp;&amp;) PROC ; A::operator=, COMDAT$LN5: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR other$[rsp] cmp QWORD PTR this$[rsp], rax je $LN2@operator mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator=(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator= mov rax, QWORD PTR other$[rsp] mov DWORD PTR [rax], 0 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv79[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv79[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1$LN2@operator: mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A &amp; A::operator=(A &amp;&amp;) ENDP ; A::operator=tv71 = 32this$ = 64A::~A(void) PROC ; A::~A, COMDAT$LN4: mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv71[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv71[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 add rsp, 56 ; 00000038H ret 0A::~A(void) ENDP ; A::~A$T1 = 32$T2 = 40tv83 = 48$T3 = 56temp$ = 88__$ArrayPad$ = 128__$ReturnUdt$ = 160A return_by_value(void) PROC ; return_by_value$LN7: mov QWORD PTR [rsp+8], rcx sub rsp, 152 ; 00000098H mov rax, QWORD PTR __security_cookie xor rax, rsp mov QWORD PTR __$ArrayPad$[rsp], rax mov DWORD PTR $T1[rsp], 0 lea rax, QWORD PTR $T3[rsp] mov QWORD PTR $T2[rsp], rax lea rdx, OFFSET FLAT:$SG35785 mov rcx, QWORD PTR $T2[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(char const * const) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov QWORD PTR tv83[rsp], rax mov r8, QWORD PTR tv83[rsp] mov edx, 100 ; 00000064H lea rcx, QWORD PTR temp$[rsp] call A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ; A::A npad 1 lea rdx, QWORD PTR temp$[rsp] mov rcx, QWORD PTR __$ReturnUdt$[rsp] call A::A(A &amp;&amp;) ; A::A mov eax, DWORD PTR $T1[rsp] or eax, 1 mov DWORD PTR $T1[rsp], eax lea rcx, QWORD PTR temp$[rsp] call A::~A(void) ; A::~A mov rax, QWORD PTR __$ReturnUdt$[rsp] mov rcx, QWORD PTR __$ArrayPad$[rsp] xor rcx, rsp call __security_check_cookie add rsp, 152 ; 00000098H ret 0A return_by_value(void) ENDP ; return_by_valueobj$ = 8A &amp; return_by_ref(A &amp;) PROC ; return_by_ref mov QWORD PTR [rsp+8], rcx mov rax, QWORD PTR obj$[rsp] ret 0A &amp; return_by_ref(A &amp;) ENDP ; return_by_refobj$ = 48A &amp;&amp; return_by_rvalue_ref(A &amp;) PROC ; return_by_rvalue_ref$LN3: mov QWORD PTR [rsp+8], rcx sub rsp, 40 ; 00000028H mov rcx, QWORD PTR obj$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; add rsp, 40 ; 00000028H ret 0A &amp;&amp; return_by_rvalue_ref(A &amp;) ENDP ; return_by_rvalue_ref$T1 = 32tv165 = 40ref_a$ = 48tv148 = 56$T2 = 64a3$ = 96a2$ = 136a1$ = 176a5$ = 216a4$ = 256__$ArrayPad$ = 296main PROC$LN9: sub rsp, 312 ; 00000138H mov rax, QWORD PTR __security_cookie xor rax, rsp mov QWORD PTR __$ArrayPad$[rsp], rax lea rdx, OFFSET FLAT:$SG35831 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 lea rax, QWORD PTR $T2[rsp] mov QWORD PTR $T1[rsp], rax lea rdx, OFFSET FLAT:$SG35832 mov rcx, QWORD PTR $T1[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(char const * const) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov QWORD PTR tv165[rsp], rax mov r8, QWORD PTR tv165[rsp] mov edx, 1 lea rcx, QWORD PTR a1$[rsp] call A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35833 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, QWORD PTR a1$[rsp] lea rcx, QWORD PTR a2$[rsp] call A::A(A const &amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35834 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a1$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; mov rdx, rax lea rcx, QWORD PTR a3$[rsp] call A::A(A &amp;&amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35835 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, QWORD PTR a3$[rsp] lea rcx, QWORD PTR a2$[rsp] call A &amp; A::operator=(A const &amp;) ; A::operator= lea rdx, OFFSET FLAT:$SG35836 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a2$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; mov rdx, rax lea rcx, QWORD PTR a3$[rsp] call A &amp; A::operator=(A &amp;&amp;) ; A::operator= lea rdx, OFFSET FLAT:$SG35837 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a4$[rsp] call A return_by_value(void) ; return_by_value npad 1 lea rdx, OFFSET FLAT:$SG35838 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a3$[rsp] call A &amp; return_by_ref(A &amp;) ; return_by_ref mov QWORD PTR ref_a$[rsp], rax mov rax, QWORD PTR ref_a$[rsp] add rax, 8 mov QWORD PTR tv148[rsp], rax lea rdx, OFFSET FLAT:$SG35840 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv148[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:$SG35839 mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, OFFSET FLAT:$SG35841 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a3$[rsp] call A &amp;&amp; return_by_rvalue_ref(A &amp;) ; return_by_rvalue_ref mov rdx, rax lea rcx, QWORD PTR a5$[rsp] call A::A(A &amp;&amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35842 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 lea rcx, QWORD PTR a5$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a4$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a3$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a2$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a1$[rsp] call A::~A(void) ; A::~A npad 1 xor eax, eax mov rcx, QWORD PTR __$ArrayPad$[rsp] xor rcx, rsp call __security_check_cookie add rsp, 312 ; 00000138H ret 0main ENDP","tags":["C++"]},{"title":"细拆二分法","path":"/2025/10/25/细拆二分法/","content":"这两周学到了二分相关，思想听起来颇为简单，实际写起来漏洞百出，如果是面向测试案例编程的话，经常胡乱+1-1，随机尝试&gt;或者&gt;=，拆了东墙补西墙，怎么堵都堵不明白。细节太多了，各种写法层出不穷，开区间的，闭区间的，左开右闭的，左闭右开的。找目标值的，找两端目标值位置的，找插入位置的，找最小的，找最大的，就是各种变了花样地找。所以还是一步步搞搞清楚，目前的总结只是从我刷到的六道题中总结的，但感觉万变不离其宗。所以来拿表格总结演示一下。 我的日常写法跟随大众写左闭右开，也就是说最后的答案基本是从left得到的。（虽然最后的退出条件是两者相等，但是为了统一还是用left。） 首先确定一些必要的条件： 由于计算mid时，为了防止溢出，经常使用这一句： 1mid=left+(right-left)/2; 所以，如果窗口长度为偶数，mid计算出来为偏向左边的索引。很符合左闭右开的规则。 举例： left=3，right=6，mid=3+（6-3）/2=4.5=4。 left=0，right=1，mid=0+（1-0）/2=0.5=0。 想找的值比所有都大： left=length-1, right=length, mid=length-1+(length-length+1)/2=length-1+0.5=length-1; left=mid+1=length, 退出循环，进行最后的判断。 想找的值比所有都小： left=0, right=1,mid=0+(1-0)/2=0.5=0 right=mid=0,此时left=right，退出循环，判断索引0是否为想要的值即可。 给的target不在里面怎么办举个例子，此处具体数值只用small和big代表，防止陷入对数值的计算。 1 3 5 7 9 找6 left先到5，right还是9，然后right成为7，找不到的情况下，left和right肯定相邻，并且left为small，right为big。 为了细致表达，考虑完整的三种情况： 第一种：找不到的数的大小处于数组中间： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，mid right 此时，left&lt;right，还可以跑一次循环，left需要往右移动，变成： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，right 此时，left=right，退出循环。最后，我们得到的left所指的这个数就是大于target的最小索引 第二种情况，target比所有数都小，right会不断往左移动，最后还是会和left相邻： index 0 1 。。。 number bigger bigger point left，mid right 此时，由于mid比target大，right还需要往左移，变成： index 0 1 。。。 number bigger bigger point left，mid，right 此时，left=right，退出循环。left值不是我们想要的值，此时left就是大于target值的最小索引。 第三种情况，target比所有数都大，left会不断向右移动，最后和right相邻： index 0 。。。 len-2 len-1 len number smaller nullptr！ point left，mid right 此时left还需要右移，得到： index 0 。。。 。。。 len-2 len-1 len number smaller nullptr！ point left，right 此时left和right相等，退出循环。检查left的值，超出len-1，说明target比所有数都大。 至此，可以稍微总结一下找不到target的情况下，算出来的left： left就是大于target的最小索引，left左边绝对比target小。 left直接跑出长度范围了，那么没别的意义，left-1即len-1即为最大值。 如果想求大于/小于target的最小/最大索引，但有重复target怎么办？上面推导的情况，也就是target不出现/只出现一次时，小于/大于target的最小索引/最大索引其实根据推导的结论也能直接得到了。但是大部分的题目不长这么简单，它会出现很多重复的target，这时候就需要计算边界了。 一般的题目我们都不会知道target会不会存在于数组中。为了保险起见，下面会做完整的推理。 如果存在，并且有很多个，那么就需要计算边界了。首先计算左边界： 计算左边界的时候，如果得到了nums[mid]==target，也不能就此退出，需要继续寻找左边还有没有，这时候就需要让right向左挤压。 首先要想清楚一点，就是left只有在nums[mid]&lt;target的时候才会移动。所以，nums[left]第一次和target相等后，就不会再动了，然后right步步紧逼，最后形成以下局面 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid right 再来一次循环，right再向左移动 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid，right 此时，退出循环，left即为我们要找的最左边。 有很多题都会用到求最左侧的索引。比如2529这道题，找到比0小的，0有可能存在也有可能不存在。如果0存在，那么我们计算出left后，要检查left-1是否存在，如果存在，那么left左边都是比0小的，left-1就是小于0的最大索引。 如果0不存在，又回到了最初那个target不存在的情况，即left本身就为小于target值的最大索引。 -2，-1，3 那么如何求最右侧的索引呢？思路差不多，也就是让left向右步步紧逼。也要搞清楚一点，right的值只会在target&lt;nums[mid]才会移动到mid上。如图，最后都会走向如此局面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left,mid right 此时left还需要右移，得到下面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left，right 此时left=right，而我们发现left所指的是x后面那个数，所以最后我们要返回left-1。 而其实，left即为大于target的最小索引。 那么如果target不存在呢？那我们又回到了最初的那种情况：left即为大于target的最小索引，小于left都比它小。 所以可以发现，如果想求大于target的值的多少，拿到left即可了，left的左边绝对都比tartget小。 那么搞明白这些，也就差不多了。 至于边际条件，搞清楚left的取值范围是[0,len]，注意一下为0时和为len时的情况即可。 回到题目总结：先记住： lower_bound：第一个 ≥ target 的位置 upper_bound：第一个 &gt; target 的位置 lc34 在排序数组中查找元素的第一个和最后一个位置思路： 第一个位置：lower_bound(target) 最后一个位置：upper_bound(target) - 1 特殊情况：检查元素是否存在 lc35 搜索插入位置：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 思路： 找第一个 ≥ target 的位置 解法：直接 lower_bound(target) lc 744 寻找比目标字母大的最小字母：给你一个字符数组 letters，该数组按非递减顺序排序，以及一个字符 target。letters 里至少有两个不同的字符。 返回 letters 中大于 target 的最小的字符。如果不存在这样的字符，则返回 letters 的第一个字符。 思路： 找第一个&gt;target的字母，即用upper_bound。 lc 2529 正整数和负整数的最大计数给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。 换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。 注意：0 既不是正整数也不是负整数。 思路： 负数数量：第一个 ≥ 0 的位置 = lower_bound(0) 正数数量：总数 - 第一个 &gt; 0 的位置 = n - upper_bound(0) 取两者最大值 lc 2300 咒语和药水的成功对数给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。 同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。 请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。 思路： 对每个spell，找第一个 ≥ success/spell 的药水 解法：m - left_bound(success/spell) lc 1385 两个数组间的距离值给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。 「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d 。 思路 检查 [x-d, x+d] 区间是否为空 解法：找第一个 ≥ x-d 的位置，检查是否 &gt; x+d 决策指南 要找什么 使用的函数 例子 第一个 ≥ target 的 lower_bound 插入位置 第一个 &gt; target 的 upper_bound 下一个更大元素 最后一个 = target 的 upper_bound - 1 元素结束位置 最后一个 &lt; target 的 lower_bound - 1 前一个较小元素 统计 target 出现次数 upper_bound - lower_bound 频率统计 注意数组越界和空数组的情况！ 直接用STL每次自己写寻找边界索引很麻烦，了解原理后直接上STL： 123456789#include &lt;algorithm&gt;using namespace std;// 在 [first, last) 范围内查找lower_bound(first, last, value); // 第一个 ≥ value 的位置upper_bound(first, last, value); // 第一个 &gt; value 的位置equal_range(first, last, value); // 返回 pair&lt;lower_bound, upper_bound&gt;binary_search(first, last, value); // 返回 bool，是否存在 基础用法： 12345678910vector&lt;int&gt; nums = &#123;1, 3, 5, 7, 9&#125;;// lower_bound: 第一个 ≥ 4 的位置auto it1 = lower_bound(nums.begin(), nums.end(), 4);// it1 指向 5，索引 = it1 - nums.begin() = 2// upper_bound: 第一个 &gt; 5 的位置 auto it2 = upper_bound(nums.begin(), nums.end(), 5);// it2 指向 7，索引 = 3","tags":["C++","算法","二分查找"]},{"title":"谈谈右值与右值引用","path":"/2025/10/10/谈谈右值/","content":"之前学习了C++的左值右值，但只留在了对于概念的理解上面。今天学习了一下移动构造函数，临时对象/将亡值即将被销毁时会唤起移动构造函数。还有一个std::move()，它的主要作用是将一个左值转换为右值引用，从而强制使用移动构造函数或移动赋值运算符。所以这个std::move()只是进行了一个类型转换而已，并不会触发移动操作。使用std::move（）后，我们就可以调用接受右值引用的函数。 1234template&lt;typename T&gt;constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);&#125; 再回顾一下左右值的定义： 左值：通常指的是有名字的变量或者持久对象，可以取它的地址。右值：通常是临时对象，比如函数返回的临时对象、字面量（除了字符串字面量，它实际上是左值）等。 右值引用：使用两个&amp;&amp;表示，例如 int&amp;&amp;。右值引用可以绑定到右值，但不能绑定到左值。 我看有些教程说右值不能取地址，我一直对此非常疑惑：右值为什么不能取地址？既然存在，那肯定在内存/寄存器里，那么右值引用又是什么？ 通过右值引用，我们可以延长右值的生命周期，右值引用本身是一个左值，因为它有名字。所以我们可以对右值引用取地址，这个地址就是被引用的右值对象的地址。 主要需要搞清楚两个问题： 右值引用是一个左值？是 右值引用是否在内存中创建了一个新对象，复制了即将销毁的右值？ 不是的。右值引用并不创建新对象，它只是引用了那个右值（临时对象）。但是，由于右值引用本身是一个左值，所以当使用右值引用时，实际上是在直接操作那个临时对象。 123456int main() &#123; MyString&amp;&amp; rref = MyString(&quot;Hello&quot;); // 右值引用绑定到临时对象 // 这里，临时对象的生命周期被延长到与rref相同 // 没有创建新对象，也没有复制数据，rref就是临时对象的别名 return 0;&#125; 在这个例子中，用一个右值引用rref绑定了一个临时对象。根据C++规则，这样做会延长临时对象的生命周期，使其与右值引用的生命周期相同。所以，在main函数结束前，这个临时对象都不会被销毁。这里没有发生拷贝，也没有移动，只是给临时对象起了一个别名。 BUT 看看到现在，还是用高层的概念去解释一个新的概念。如果一直在高层徘徊，就会产生很多疑问：临时对象是在内存中存储吗？int&amp;&amp;a=2, 2的地址不能被取到，那为什么用右值引用就能取了？那是不是意味着编译器在中间就是开了一个临时对象呢？又有说表达式结束，临时对象就会被销毁。那么如果还是按照刚刚那些高层概念解释，对象都被销毁了，右值引用还在引用什么呢？ 还是下到汇编看看。终于在知乎找到了一篇文章，终于在汇编层面解答了我上面的问题： https://zhuanlan.zhihu.com/p/389978619?share_code=IPKeoBHAwX3u&amp;utm_psn=1960118829079307210 下面是答案： int &amp;&amp;a=0; 其中a是一个右值引用。 这个汇编代码等价于一个左值引用（底层看就是指针常量）引用了一个匿名变量，此匿名变量在C++中不可见，但其实该变量存在于栈上。总结来说，右值引用的底层就是一个指针指向了一个匿名变量。那么如果对右值引用重新赋值修改，改的就是匿名变量的值。","tags":["C++"]},{"title":"顶层const与底层const","path":"/2025/10/09/顶层const与底层const/","content":"理清 C++ 中顶层 const 和底层 const 的概念，感觉理解起来有些混乱。 具体讲解看的是《C++ Primer》。 核心概念顶层 const (top-level const)：对象本身是常量底层 const (low-level const)：指针/引用指向的对象是常量 具体例子1. 顶层 const 的例子123int a = 10;const int b = 20; // b 是顶层 const（b 本身是常量）int *const p1 = &amp;a; // p1 是顶层 const（指针本身是常量） 特点： 对象本身的值不能改变 对于指针：指针的指向不能改变，但指向的内容可以改变 1234int a = 10, b = 20;int *const p = &amp;a; // 顶层 const// p = &amp;b; // 错误！指针指向不能改变*p = 30; // 正确！指向的内容可以改变 2. 底层 const 的例子1234int a = 10;const int *p1 = &amp;a; // p1 是底层 constint const *p2 = &amp;a; // p2 也是底层 const（两种写法等价）const int &amp;r = a; // r 是底层 const 特点： 指针/引用指向的对象是常量 指针的指向可以改变，但不能通过指针修改指向的对象 1234int a = 10, b = 20;const int *p = &amp;a; // 底层 constp = &amp;b; // 正确！指针指向可以改变// *p = 30; // 错误！不能通过指针修改指向的对象 3. 同时包含的情况12const int *const p = &amp;a; // 左边是底层 const，右边是顶层 const// 读作：p 是一个常量指针，指向一个常量整数 记忆技巧方法1：看 const 的位置123int *const p; // const 在 * 右边 → 顶层 constconst int *p; // const 在 * 左边 → 底层 const int const *p; // const 在 * 左边 → 底层 const 方法2：从右向左读12int *const p; // 从右往左：p 是 const 指针，指向 intconst int *p; // 从右往左：p 是指针，指向 const int 实际应用中的区别1. 拷贝操作的限制123456789int a = 10;const int b = 20;// 顶层 const 不影响拷贝int c = b; // 正确：可以忽略顶层 constconst int *p1 = &amp;a; // 底层 constint *p2 = p1; // 错误！不能忽略底层 constconst int *p3 = p1; // 正确：底层 const 可以保留 2. 函数重载12345void func(int *p); // #1void func(const int *p); // #2 重载，底层 const 不同void func(int p); // #3void func(const int p); // #4 错误！顶层 const 不能重载 这里需要用函数值传递仔细说明一下： const不会改变参数的类型，因此不能作为函数重载的依据。会忽略掉顶层const 函数进行传参时，传的都是值的副本，对副本是否加const，不会改变参数类型。 12void fun1(int x);void fun1(const int x);//报错 Redundant ‘fun1’ declaration [readability-redundant-declaration]E:\\UnrealWorld\\project\\Learncpp\\Learncpp\\main.cpp:5:6: note: previously declared here 3. 引用的情况引用天生就是”顶层 const”（因为引用一旦绑定就不能改变），所以我们只关心底层 const： 123int a = 10;int &amp;r1 = a; // 普通引用const int &amp;r2 = a; // 底层 const 引用 总结 类型 示例 const 类型 什么不能改变 常量整数 const int a 顶层 const a 的值 常量指针 int *const p 顶层 const p 的指向 指向常量的指针 const int *p 底层 const 通过 p 修改指向的对象 常量引用 const int &amp;r 底层 const 通过 r 修改绑定的对象 核心区别： 顶层 const：我本身是常量 底层 const：我指向/引用的对象是常量","tags":["C++"]},{"title":"星露谷卡片生成器技术要点记录及解决方案","path":"/2025/09/04/星露谷卡片生成器技术要点记录及解决方案/","content":"我开发了一个星露谷风格的卡片生成器小程序，遇到最麻烦的问题就是字体的处理。微信小程序的字体处理存在诸多限制，尤其是真机环境兼容性问题，有时候在开发工具上一切都好，一上手机啥效果也没了。为了解决这些问题，主要参考了https://juejin.cn/post/7252175375105916965#heading-7这篇文章的解决办法。 微信小程序字体加载限制问题：wx.loadFontFace没有缓存机制，用户每次打开小程序，都要重新下载字体文件。我买的阿里云oss的下行流量包，如果每次都要重新下载字体文件，有点小贵。。。 解决方案： 使用wx.loadFontFace API加载字体 将字体文件转换为base64格式存储 实现字体缓存机制，避免重复下载 12345678910111213141516// 使用loadFontFace加载字体async loadFontFaceFromBase64(fontName, base64) &#123; return new Promise((resolve) =&gt; &#123; wx.loadFontFace(&#123; family: fontName, global: true, source: `data:font/ttf;base64,$&#123;base64&#125;`, scopes: [&#x27;webview&#x27;, &#x27;native&#x27;], success: () =&gt; resolve(true), fail: (err) =&gt; &#123; console.error(`字体加载失败: $&#123;fontName&#125;`, err); resolve(false); &#125; &#125;); &#125;);&#125; OpenType.js 集成如果直接用canvas画下载好的字体，在开发工具上显示是正常的，但在真机测试的时候，渲染出的canvas的字体退回到了系统自带。微信团队好像还是没有解决这个问题。遂参考他人用OpenType.js库解决。 字体解析与缓存OpenType.js是一个强大的字体处理库，可以将字体文件解析为可操作的JavaScript对象。 1234567891011121314151617181920212223// 字体解析核心代码async preloadSingleFont(font) &#123; try &#123; // 从缓存读取base64数据 const base64 = await this.fetchFontBase64(font.id, font.url); // 将base64转换为ArrayBuffer const arrayBuffer = wx.base64ToArrayBuffer(base64); // 使用opentype.js解析字体 const fontType = await opentype.parse(arrayBuffer); // 缓存字体对象 this.fontCache[font.id] = &#123; fontType: fontType, base64: base64 &#125;; console.log(`字体预加载成功: $&#123;font.name&#125;`); &#125; catch (error) &#123; console.error(`字体预加载失败: $&#123;font.name&#125;`, error); &#125;&#125; 字体绘制实现OpenType.js的核心优势在于可以将文字转换为路径对象，然后通过Canvas API进行绘制。 1. 带阴影的字体绘制1234567891011121314151617181920212223242526272829303132333435drawTextWithOpenType(ctx, text, x, y, fontSize, color = &#x27;#1a1a1a&#x27;, fontWeight = &#x27;normal&#x27;) &#123; // 检查是否需要显示阴影 const shouldShowShadow = this.data.selectedFontId !== &#x27;stardew&#x27;; if (!this.fontType) &#123; // 降级到默认绘制方式 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); return; &#125; try &#123; // 字体阴影效果 if (shouldShowShadow) &#123; const shadowPath = this.fontType.getPath(text, x + 0, y + 2, fontSize); const shadowColor = this.colorToRgba(color, 0.4); shadowPath.fill = shadowColor; shadowPath.draw(ctx); &#125; // 使用opentype.js生成路径 const path = this.fontType.getPath(text, x, y, fontSize); path.fill = color; // 粗体效果实现 if (fontWeight === &#x27;bold&#x27;) &#123; this.drawBoldText(path, ctx, text, x, y, fontSize, color); &#125; else &#123; path.draw(ctx); &#125; &#125; catch (error) &#123; console.error(&#x27;opentype.js绘制失败:&#x27;, error); // 降级处理 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); &#125;&#125; 2. 粗体效果实现由于微信小程序环境的限制，在真机测试时还是无法直接使用字体的粗体变体（也没搞懂为什么）。通过多次绘制模拟粗体效果： 123456789101112131415161718// 真机兼容的粗体实现drawBoldText(path, ctx, text, x, y, fontSize, color) &#123; // 绘制原始路径 path.draw(ctx); // 创建偏移路径，模拟粗体效果 const path1 = this.fontType.getPath(text, x + 0.5, y, fontSize); path1.fill = color; path1.draw(ctx); const path2 = this.fontType.getPath(text, x, y + 0.5, fontSize); path2.fill = color; path2.draw(ctx); const path3 = this.fontType.getPath(text, x + 0.5, y + 0.5, fontSize); path3.fill = color; path3.draw(ctx);&#125; 3. 文本换行处理对于长文本，实现了自动换行功能： 123456789101112131415161718192021222324252627282930313233wrapTextWithOpenType(ctx, text, x, y, maxWidth, lineHeight, color = &#x27;#2F1B14&#x27;) &#123; if (!this.fontType) &#123; return this.wrapText(ctx, text, x, y, maxWidth, lineHeight, color); &#125; let line = &#x27;&#x27;; let currentY = y; for (let i = 0; i &lt; text.length; i++) &#123; const testLine = line + text[i]; // 使用默认字体测量宽度（因为opentype.js测量比较复杂） ctx.setFontSize(20); const testWidth = ctx.measureText(testLine).width; if (testWidth &gt; maxWidth &amp;&amp; i &gt; 0) &#123; // 绘制当前行 this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); line = text[i]; currentY += lineHeight; &#125; else &#123; line = testLine; &#125; &#125; // 绘制最后一行 if (line) &#123; this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); currentY += lineHeight; &#125; return currentY;&#125; 双层缓存系统设计文件缓存层为了减少网络请求和提高加载速度，实现了文件缓存： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 字体缓存系统class FontCache &#123; // 读取字体缓存 readFontCache(fontId) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.readFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, encoding: &#x27;utf8&#x27;, success: (res) =&gt; &#123; console.log(`从缓存读取字体: $&#123;fontId&#125;`); resolve(res.data); &#125;, fail: () =&gt; &#123; console.log(`缓存中未找到字体: $&#123;fontId&#125;`); resolve(null); &#125; &#125;); &#125;); &#125; // 写入字体缓存 writeFontCache(fontId, base64Data) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.writeFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, data: base64Data, encoding: &#x27;utf8&#x27;, success: () =&gt; &#123; console.log(`字体缓存写入成功: $&#123;fontId&#125;`); resolve(true); &#125;, fail: (err) =&gt; &#123; console.error(`体缓存写入失败: $&#123;fontId&#125;`, err); resolve(false); &#125; &#125;); &#125;); &#125; // 获取字体base64数据（带缓存） async fetchFontBase64(fontId, fontUrl) &#123; // 先尝试从缓存读取 const cache = await this.readFontCache(fontId); if (cache) &#123; return cache; &#125; // 缓存中没有，从网络下载 console.log(`从网络下载字体: $&#123;fontId&#125;`); return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: fontUrl, method: &#x27;GET&#x27;, responseType: &#x27;arraybuffer&#x27;, success: async (res) =&gt; &#123; try &#123; // 将arraybuffer转换为base64 const base64 = wx.arrayBufferToBase64(res.data); // 写入缓存 await this.writeFontCache(fontId, base64); console.log(`字体下载并缓存成功: $&#123;fontId&#125;, 大小: $&#123;res.data.byteLength&#125; bytes`); resolve(base64); &#125; catch (error) &#123; console.error(`字体转换base64失败: $&#123;fontId&#125;`, error); reject(error); &#125; &#125;, fail: (err) =&gt; &#123; console.error(`字体下载失败: $&#123;fontId&#125;`, err); reject(err); &#125; &#125;); &#125;); &#125;&#125; 内存缓存层最开始用上面的方法，切换还是太慢了，换一个字体要十秒钟。。。还是先加载到内存缓存快一些： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 内存缓存系统class MemoryCache &#123; constructor() &#123; this.fontCache = &#123;&#125;; &#125; // 预加载所有字体到内存缓存 async preloadAllFonts(availableFonts) &#123; console.log(&#x27;开始预加载所有字体...&#x27;); const preloadPromises = []; for (const font of availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125; &#125; // 快速切换字体 async fastSwitchFont(fontId, fontName) &#123; try &#123; console.log(`快速切换字体: $&#123;fontName&#125;...`); // 确保字体缓存对象存在 if (!this.fontCache) &#123; this.fontCache = &#123;&#125;; &#125; // 如果是系统默认字体 if (fontId === &#x27;system&#x27;) &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); console.log(`快速切换到系统默认字体`); return; &#125; // 检查内存缓存 if (this.fontCache[fontId]) &#123; console.log(`从内存缓存快速切换字体: $&#123;fontName&#125;`); this.fontType = this.fontCache[fontId].fontType; this.setData(&#123; fontLoaded: true &#125;); // 异步加载到系统字体（不阻塞切换） this.loadFontFaceFromBase64(fontName, this.fontCache[fontId].base64); return; &#125; // 如果内存缓存中没有，回退到正常加载 console.log(`内存缓存中未找到字体，回退到正常加载: $&#123;fontName&#125;`); await this.loadSelectedFont(); &#125; catch (error) &#123; console.error(`快速切换字体失败: $&#123;fontName&#125;`, error); // 回退到正常加载 await this.loadSelectedFont(); &#125; &#125;&#125; 九宫格边框实现为了实现星露谷风格的边框效果，使用了九宫格技术： 12345678910111213141516171819202122232425262728293031323334// 九宫格边框绘制drawBorder(ctx, width, height, borderWidth = 12) &#123; const slice = 75; // border-image slice const imgPath = &#x27;/imgs/aaa.png&#x27;; wx.getImageInfo(&#123; src: imgPath, success: (res) =&gt; &#123; const imgW = res.width; const imgH = res.height; const path = res.path; // 绘制九个部分 // 四个角 ctx.drawImage(path, 0, 0, slice, slice, 0, 0, borderWidth, borderWidth); // 左上 ctx.drawImage(path, imgW - slice, 0, slice, slice, width - borderWidth, 0, borderWidth, borderWidth); // 右上 ctx.drawImage(path, 0, imgH - slice, slice, slice, 0, height - borderWidth, borderWidth, borderWidth); // 左下 ctx.drawImage(path, imgW - slice, imgH - slice, slice, slice, width - borderWidth, height - borderWidth, borderWidth, borderWidth); // 右下 // 四个边 ctx.drawImage(path, slice, 0, imgW - 2 * slice, slice, borderWidth, 0, width - 2 * borderWidth, borderWidth); // 上 ctx.drawImage(path, slice, imgH - slice, imgW - 2 * slice, slice, borderWidth, height - borderWidth, width - 2 * borderWidth, borderWidth); // 下 ctx.drawImage(path, 0, slice, slice, imgH - 2 * slice, 0, borderWidth, borderWidth, height - 2 * borderWidth); // 左 ctx.drawImage(path, imgW - slice, slice, slice, imgH - 2 * slice, width - borderWidth, borderWidth, borderWidth, height - 2 * borderWidth); // 右 &#125; &#125;);&#125; 动态属性绘制对于卡片的属性部分，实现了动态绘制功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 绘制动态属性drawStats(ctx, startX, startY, width) &#123; const stats = this.data.itemStats.filter(stat =&gt; stat.name &amp;&amp; stat.value); if (stats.length === 0) return startY; let currentY = startY; let completedCount = 0; let hasAsyncIcons = false; // 设置属性文字颜色 ctx.setFillStyle(&#x27;#352f36&#x27;); stats.forEach((stat, index) =&gt; &#123; const statY = startY + (index * 36); if (stat.iconPath) &#123; hasAsyncIcons = true; // 异步加载图标 wx.getImageInfo(&#123; src: stat.iconPath, success: (iconRes) =&gt; &#123; // 绘制图标阴影 ctx.setGlobalAlpha(0.5); ctx.drawImage(iconRes.path, startX - 3, statY - 30 + 3, 35, 35); // 绘制图标主体 ctx.setGlobalAlpha(1.0); ctx.drawImage(iconRes.path, startX, statY - 30, 35, 35); // 绘制属性文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX + 40, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125;, fail: () =&gt; &#123; // 图标加载失败，使用默认文本 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125; &#125;); &#125; else &#123; // 没有图标，直接绘制文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); &#125; &#125;); return startY + (stats.length * 24);&#125; 性能优化策略字体加载优化123456789101112131415161718192021222324252627// 预加载策略async onLoad() &#123; // 初始化字体缓存对象 this.fontCache = &#123;&#125;; // 预加载所有字体到内存缓存 await this.preloadAllFonts(); // 加载当前选中的字体 await this.loadSelectedFont();&#125;// 并行预加载async preloadAllFonts() &#123; const preloadPromises = []; for (const font of this.data.availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125;&#125; 内存管理优化123456789101112131415161718192021222324// 字体缓存管理class FontCacheManager &#123; constructor() &#123; this.fontCache = &#123;&#125;; this.maxCacheSize = 10; // 最大缓存数量 &#125; // 添加字体到缓存 addFont(fontId, fontData) &#123; // 检查缓存大小 if (Object.keys(this.fontCache).length &gt;= this.maxCacheSize) &#123; // 移除最旧的缓存 const oldestKey = Object.keys(this.fontCache)[0]; delete this.fontCache[oldestKey]; &#125; this.fontCache[fontId] = fontData; &#125; // 清理缓存 clearCache() &#123; this.fontCache = &#123;&#125;; &#125;&#125; 错误处理与降级1234567891011121314151617181920212223242526272829// 完善的错误处理机制async loadSelectedFont() &#123; try &#123; // 尝试加载字体 await this.loadFontWithOpenType(); &#125; catch (error) &#123; console.error(&#x27;字体加载失败:&#x27;, error); // 降级处理 try &#123; await this.loadFontWithLoadFontFace(); &#125; catch (fallbackError) &#123; console.error(&#x27;降级加载也失败:&#x27;, fallbackError); // 使用系统默认字体 this.useSystemFont(); &#125; &#125;&#125;// 降级到系统字体useSystemFont() &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); wx.showToast(&#123; title: &#x27;使用系统默认字体&#x27;, icon: &#x27;none&#x27;, duration: 2000 &#125;);&#125; 第一次碰前端相关，写WXML和WXSS用Cursor真的省去了很多重复劳动！我只需要聚焦于底层逻辑还有优化就可以了，把组织容器布局交给AI来做就好。","tags":["小程序","前端"]},{"title":"C++左右值与引用","path":"/2025/08/29/C-左右值与引用/","content":"本笔记为【彻底搞懂C++移动语义/左值/右值/引用！！！】 https://www.bilibili.com/video/BV17ce7zLEzu/?p=2&amp;share_source=copy_web&amp;vd_source=92a7dafd94e8cc1bfc97784a3732ea8d的总结整理 左值和右值左值指的是一个指向特定内存的具有名称的值即具名对象。 如果一个值有名字，那么它就是左值。 右值为临时短暂的表达式或值，生命周期较短，没有一个稳定的、可识别的内存地址。 右值通常代表一个计算的中间结果，一个字面量或者一个即将被销毁的临时对象。 临时的，即用即弃的值，就是右值。 举例： 123int a = 1;int b = 2;int c = a+b; 其中，a,b,c都是左值，1和2都是没有名字的字面值，为右值。a+b的结果也是右值，为临时的中间变量值。 12x++;++x; 其中，x++是右值，编译器先生成一份x值的临时复制，然后才对x递增，返回的是没有自加之前的临时版本。 ++x是对x递增后，马上返回其自身，x和++x具有相同的地址，++x是一个左值。 ++x可以进行赋值操作。x++作为一个右值，赋值会报错。 1234int get_val(int val)&#123; return x;&#125; 其中，x也是一个右值，因为返回的不是x本身，而是x的一个临时复制。 12345678910int set_val(int val)&#123; int *p = &amp;val; x=val;&#125;int main()&#123; set_val(2);//此处的实参2是右值&#125; 进入函数后，形参val变成了左值，可以取地址。函数形参一定是左值，因为有名字。要注意：字符串字面量是一个左值，因为字符串字面量在C++中是一个常量字符数组，编译器会将其存储到程序的只读数据段中。程序运行开始到结束会一直存在。 左值引用我们使用指针可以对左值取地址，但是，指针指向的位置可被任意修改。 左值引用最常见的使用场景就是：希望函数能够修改传入的参数，虽然指针可以做到，但是引用会更清晰安全。 举例：值交换 1234567891011121314151617181920void swap_ptr(int *x, int *y)&#123; int temp = *x; *x= *y; *y= temp;&#125;void swap_ref(int&amp; x, int &amp;y)&#123; int temp=x; x=y; y=temp;&#125;int main()&#123; int a=1, b=2, c=3, d=4; swap_ptr(&amp;a,&amp;b); swap_ref(c,d);&#125; 可以发现引用更加简洁。 非常量左值的引用对象必须是左值。 但是常量左值引用，不仅可以引用左值，还能引用右值： 1const int &amp;x = 11; 但引用右值的作用没多大。 常量左值引用在于复制构造函数、复制赋值运算符的形参。 举例：类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &quot;Person.h&quot;Person::Person(const std::string&amp; nameVal, int ageVal): name(nameVal), age(ageVal)&#123; std::cout &lt;&lt; &quot;普通构造函数被调用 for: &quot; &lt;&lt; nameVal &lt;&lt; std::endl; &#125;Person::~Person()&#123; //std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;Person::Person(const Person&amp; other) : name(other.name), age(other.age) &#123; // 初始化 age std::cout &lt;&lt; &quot;拷贝构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl;&#125;Person&amp; Person::operator=(const Person&amp; other) &#123; std::cout &lt;&lt; &quot;拷贝赋值运算符被调用 from: &quot; &lt;&lt; other.name &lt;&lt; &quot; to: &quot; &lt;&lt; name &lt;&lt; std::endl; // 1. 检查自我赋值 (非常重要！) if (this == &amp;other) &#123; return *this; // 如果是自己给自己赋值，直接返回 &#125; name = other.name; age = other.age; return *this;&#125;void Person::printInfo() const &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;&#125;#include &quot;Person.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//hh// 一个接受常量引用的函数，演示其用法void printPersonInfo(const Person&amp; person) &#123; std::cout &lt;&lt; &quot;在 printPersonInfo 函数中: &quot;; person.printInfo(); // 因为 printInfo() 是 const 成员函数，所以可以在 const 对象上调用&#125;// 一个返回新对象的函数，用于演示Person createPerson(const char* name, int age) &#123; Person p(name, age); // 调用普通构造函数 return p; // 返回值可能会触发拷贝构造（或受RVO/NRVO优化影响）&#125;int main() &#123; std::cout &lt;&lt; &quot;当前控制台代码页: &quot; &lt;&lt; GetConsoleOutputCP() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;----- 创建对象 p1 -----&quot; &lt;&lt; std::endl; Person p1(&quot;Alice&quot;, 25); // 调用普通构造函数 std::cout &lt;&lt; &quot; ----- 通过拷贝构造创建 p2 -----&quot; &lt;&lt; std::endl; Person p2 = p1; // 调用拷贝构造函数 // p1 是一个左值，完美匹配 const Person&amp; 形参 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 通过拷贝赋值给 p2 -----&quot; &lt;&lt; std::endl; Person p3(&quot;Bob&quot;, 30); // 调用普通构造函数 p2 = p3; // 调用拷贝赋值运算符 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 传递常量对象 -----&quot; &lt;&lt; std::endl; const Person constP(&quot;Charlie&quot;, 40); // 一个常量对象 Person p4 = constP; // 成功调用拷贝构造函数，因为形参是 const Person&amp; p4.printInfo(); std::cout &lt;&lt; &quot; ----- 使用临时对象（右值） -----&quot; &lt;&lt; std::endl; p4 = Person(&quot;David&quot;, 50); // 先调用普通构造函数创建临时对象，再调用拷贝赋值运算符 p4.printInfo(); std::cout &lt;&lt; &quot; ----- 函数按常量引用传参 -----&quot; &lt;&lt; std::endl; printPersonInfo(p4); // p4 被以引用的方式传入，避免了一次拷贝 std::cout &lt;&lt; &quot; ----- 函数返回值（可能涉及拷贝） -----&quot; &lt;&lt; std::endl; Person p5 = createPerson(&quot;Eve&quot;, 60); p5.printInfo(); std::cout &lt;&lt; &quot; ----- Main 函数结束，开始析构 -----&quot; &lt;&lt; std::endl; return 0; // 所有对象离开作用域，析构函数按顺序被调用&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435----- 创建对象 p1 -----普通构造函数被调用 for: Alice----- 通过拷贝构造创建 p2 -----拷贝构造函数被调用 from: AliceName: Alice, Age: 25----- 通过拷贝赋值给 p2 -----普通构造函数被调用 for: Bob拷贝赋值运算符被调用 from: Bob to: AliceName: Bob, Age: 30----- 传递常量对象 -----普通构造函数被调用 for: Charlie拷贝构造函数被调用 from: Charlie----- 使用临时对象（右值） -----普通构造函数被调用 for: David拷贝赋值运算符被调用 from: David to: Charlie析构函数被调用 for: David at 000000BDF61BF888----- 函数按常量引用传参 -----在 printPersonInfo 函数中: Name: David, Age: 50----- 函数返回值（可能涉及拷贝） -----普通构造函数被调用 for: EveName: Eve, Age: 60----- Main 函数结束，开始析构 -----析构函数被调用 for: Eve at 000000BDF61BF5F8析构函数被调用 for: David at 000000BDF61BF5A8析构函数被调用 for: Charlie at 000000BDF61BF558析构函数被调用 for: Bob at 000000BDF61BF508析构函数被调用 for: Bob at 000000BDF61BF4B8析构函数被调用 for: Alice at 000000BDF61BF468Process finished with exit code 0. 复制构造函数的参数为什么必须是引用类型呢？ 12Person a;Person b = a; // 希望调用拷贝构造函数 如果没有引用，other是按值传参，为了把a的参数传到other，编译器需要先把a拷贝到other， 那拷贝 a 的时候，需要调用 拷贝构造函数 —— 可问题是这个拷贝构造函数就是我们正在定义的函数！ 于是就形成了一个无限递归调用，编译器根本无法完成参数传递。 因此，C++ 标准规定：拷贝构造函数必须以引用的形式接收参数，否则无法定义。 左值引用和右值引用都是新名字而已，所以都是左值。 右值引用和移动语义复习一下拷贝构造： 123456+----------------+ +----------------+| Person p1 | | Person p2 || this=0x1234 | | this=0x5678 || name -&gt; 0xAAAA | =====&gt; | name -&gt; 0xBBBB || &quot;Alice&quot; | | &quot;Alice&quot; |+----------------+ +----------------+ 说明： p1 的 name 指针指向堆内存 0xAAAA。 调用拷贝构造时，p2 重新分配了一块堆内存 0xBBBB，把 &quot;Alice&quot; 复制过去。 两个对象互不影响，拥有各自的资源。 移动构造： 1234567891011121314151617181920212223242526272829303132333435363738394041// 移动构造Person::Person(Person&amp;&amp; other) noexcept : name(other.name), age(other.age) &#123; other.name = nullptr; // 转移后置空 std::cout &lt;&lt; &quot;移动构造函数 from (对象地址=&quot; &lt;&lt; &amp;other &lt;&lt; &quot;, 旧name指针=&quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) → 新对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;;&#125;// 移动赋值Person&amp; Person::operator=(Person&amp;&amp; other) noexcept &#123; if (this == &amp;other) return *this; delete[] name; // 清理旧资源 name = other.name; // 接管资源 age = other.age; other.name = nullptr; std::cout &lt;&lt; &quot;移动赋值运算符 (接管指针 &quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) 到对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;; return *this;&#125;int main()&#123; ...... p2 = Person(&quot;Charlie&quot;, 40); // 移动赋值 ......&#125;构造前：+----------------+ | 临时Person tmp || this=0x9999 || name -&gt; 0xCCCC || &quot;Bob&quot; |+----------------+移动构造后：+----------------+ +----------------+| 临时Person tmp | | Person p3 || this=0x9999 | | this=0x8888 || name -&gt; null | =====&gt; | name -&gt; 0xCCCC || | | &quot;Bob&quot; |+----------------+ +----------------+ 说明： tmp 是一个临时对象，原本持有堆内存 0xCCCC。 移动构造时，p3 直接接管 tmp 的指针 0xCCCC。 tmp.name 被置为 nullptr，所以它析构时不会释放这块内存。 避免了深拷贝的开销。 总结： 1234567拷贝构造: 移动构造:p1(name-&gt;0xAAAA) tmp(name-&gt;0xCCCC) | | |----&gt; new 0xBBBB |----&gt; p3 接管指针 | copy &quot;Alice&quot; | tmp.name=null | |p2(name-&gt;0xBBBB) p3(name-&gt;0xCCCC) 拷贝 = 重新分配一块新内存，复制内容。 移动 = 直接偷走旧对象的指针，旧对象清空指针。 *为什么移动构造函数后面要写noexpect?(GPT生成总结)* 背景：STL 容器的元素移动 比如 std::vector 扩容时，它会把旧元素转移到新分配的内存里： 123std::vector&lt;Person&gt; v;v.push_back(Person(&quot;Alice&quot;, 20));v.push_back(Person(&quot;Bob&quot;, 30)); 当 vector 空间不够，需要重新分配时，它要把旧的元素（Alice）搬到新的内存。 此时有两个选择： 调用 移动构造函数（更快） 调用 拷贝构造函数（更安全） 如果移动构造函数可能抛异常 vector 在扩容时，搬到一半，结果某个元素的移动构造抛出了异常。 这时新内存里的部分对象构造完成，部分对象失败，旧内存里的对象可能已经被破坏（移动后被置空）。 整个容器就可能进入 不一致状态（既不能保证强异常安全，也不能 rollback）。 为了避免这种情况，标准库****要求：只有在移动构造函数被声明为 noexcept 时，容器才会使用它。否则容器会退而求其次，调用 拷贝构造函数（因为拷贝一般不会抛异常）。 因此在自定义类里实现移动构造函数时，加上 noexcept： 12345Person(Person&amp;&amp; other) noexcept : name(std::move(other.name)), age(other.age) &#123; std::cout &lt;&lt; &quot;移动构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl; other.age = 0;&#125; 总结 没有 noexcept STL 容器在需要移动元素时，可能会选择 拷贝构造，牺牲性能保证安全。 有 noexcept STL 容器可以放心大胆地使用移动构造，获得最大性能提升。 所以 noexcept 是一个 性能保证的承诺： 告诉编译器“移动构造不会抛异常”，容器才敢优化。","tags":["C++"]},{"title":"饼图练习","path":"/2025/08/24/饼图练习/","content":"① 表示比例 (Proportion / Share) — 8句 食品支出占家庭总支出的 30%。Food accounts for 30% in family consumption. 石油占比最大，为 40%。Oil makes up the biggest share, standing at 40%. 医疗费用仅占 5%。Only 5% is spent on medical services. 私家车占出行方式的 60%。Private car accounts for 60% of total transportation. 农业就业人口占比 25%。The agricultural workforce makes up 25% of total employment. 谷物占食品消费的 40%。Grain represent a 40% share of total food consumption. 公共汽车占比 20%。Public buses represent a 20% share of overall transportation. 住房花费占比最高，为 40%。Housing expenditure makes up the largest share, standing at 40%. ② 比较关系 (Comparison) — 8句 教育的比例是医疗的两倍。The propotion of education is twice as high as that of healthcare. 公共汽车的比例是火车的两倍。The share of buses is twice the proportion of trains. 娱乐和通讯的支出几乎持平。The expenditure on entertainment and communication are almost identical./ Spending on entertainment is nearly equal to that on communication. 煤炭的比例略高于天然气. The proportion of coal is slightly higher than that of natural gas. 自行车的比例最低，仅为 3%。Bicycle represents the lowest share, standing at 3%. 医疗费用比教育少 10 个百分点。Spending on healthcare is 10% points lower than that on education. 肉类消费比乳制品高出三倍。Consumption on meat is three times as much as that on dairy products. 蔬菜和水果的比例几乎相同。The share of vegetables is nearly equal to that of fruits. 表达“几乎持平”可以用： almost the same nearly equal almost identical roughly the same level ③ 趋势变化 (Trend / Change) — 8句 公交车的比例逐年下降。The proportion of bus usage decreased steadily each year. 可再生能源翻倍，从 5% 增加到 10%。The share of renewable energy doubled, rising from 5% to 10%. 农业的比例在十年间下降。The share of agricultural declined over the period of 10 years. 火车的比例保持稳定。The share of trains remained stable. 服务业逐年上升，超过了工业。The proportion of service rose each year, exceeding that of industrial sector. 医疗的比例下降了两个百分点。The share of healthcare declined by 2% points. 学习旅游增加了 5 个百分点。Studying tourism accounted for 5% points more than before. 娱乐支出翻了一倍。Entertainment expenditure doubled. ④ 总体特征 (Overall features) — 6句 整体来看，住房和食品主导了家庭预算。Overall, Spending on housing and food dominates the expenditure. 总体而言，化石燃料仍然占主导。Generally, fossil fuel still dominate energy consumption. 总体来看，私家车主导了交通方式。In general, private cars continue to dominate the transportation modes. 总体来看，服务业主导了就业结构。Generally, service sector dominated the employment structure. 观光旅游是最主要的旅游目的。Tourism for sightseeing accounts for the largest share. 总体而言，消费结构变化不大。Overall, the consumption of structure remained stable. “变化不大” → remained stable / showed little change / remained largely unchanged","tags":["英语"]},{"title":"反射机制与序列化","path":"/2025/08/17/反射机制与序列化/","content":"之前用Unity在定义变量时经常会在变量前面标记[SerializeField]，用于将private和protected属性的变量显示在inspector上（public变量会直接显示）。学习时没有细想这些都是什么。关于序列化也是只知道大概的作用。学习UE时碰到了反射系统，而序列化则是反射系统的一大应用场景。此篇笔记将学习记录序列化的概念，反射的概念以及UE的C++反射实现，以及在UE中，序列化又是如何通过反射实现的。 1. 什么是序列化计算机程序的基本运行周期可分为三个阶段：启动、运行和终止。当程序运行时，编译后的代码会被加载到内存中，程序运行过程中产生的变量和对象则存储在内存的栈区和堆区。然而，一旦程序终止运行，这些存储在内存中的临时数据都将丢失。为了持久化这些数据，我们需要在程序运行期间或终止前将其保存下来。这种需求常见于以下场景： 网络传输（如多人游戏中不同客户端间的状态同步） 游戏存档（保存玩家进度） 编辑器中对游戏对象的修改保存 简单来说，序列化 是将程序中的 对象（Object） 或 数据结构 转换为一种 可存储或可传输的格式（如二进制、JSON、XML等），以便在需要时能够重新恢复（反序列化）为原始对象的过程。 2. 什么是反射（Reflection）在UE中，每次修改完C++代码后都需要重新编译才能继续在编辑器中进行操作。这是因为编辑器需要获取代码中的变量和对象信息，以便在面板中提供可视化编辑功能。然而，C++编译过程会丢失许多对编辑器至关重要的元数据信息。C++的源码中的各种类型名变量名函数名文本人类可读，而编译器会直接将人类可读的代码源码编译为机器指令。编译器会丢弃什么呢？对于一个对象MyClass，运行时内存只需要知道某一块内存是哪种类型，并不需要知道名字字符串。对象成员health，只需要知道其在某一块内存的固定偏移量是多少。各种继承关系也会被处理为虚函数表（vtable），运行时通过vtable指针调用虚函数，而vtable本身不包含任何类名或父类名信息。简单来说，一切都被编译器转化为了各种地址信息，程序运行时只需要知道从哪块地址取出什么数据及指令即可。 程序在运行的时候如果想知道： 我自己有哪些类？ 这个类叫什么名字？继承自谁？ 类里面有哪些成员变量，叫什么？是什么类型？ 类里面有哪些成员函数？参数和返回值是什么？ 那么反射机制就是程序在运行时获取自身结构信息（类，属性，函数等）并能够操作他们的能力。 Unreal引擎的许多强大功能和高效工作流都严重依赖反射。没有它，以下事情要么极其困难，要么根本不可能： 序列化： 将对象的状态（属性值）保存到磁盘（如存盘文件.uasset）或通过网络发送。 引擎需要知道对象有哪些属性、它们的类型以及如何读取/写入它们的值。反射提供了这份“属性清单”和操作方法。 垃圾回收： Unreal使用自动内存管理（GC）来回收不再使用的UObject。 GC需要知道一个对象引用了哪些其他UObject（避免误删仍在使用的对象）。反射提供了属性之间的引用关系图（通过UPROPERTY()标记）。 蓝图与C++的互操作性： 这是Unreal最强大的特性之一。让设计师在蓝图中使用C++类、访问C++变量、调用C++函数。 蓝图系统需要在运行时知道C++类有哪些属性(UPROPERTY)暴露给蓝图编辑、有哪些函数(UFUNCTION)可以被蓝图调用、它们的参数是什么。反射提供了这份蓝图与C++交互的“接口说明书”。 编辑器细节面板： 在Unreal编辑器中选中一个Actor或Component时，右侧的“Details”面板会显示其可编辑的属性。 编辑器需要知道这个对象有哪些属性可以显示和编辑、它们的分类（Category）、显示名称、工具提示、取值范围等（通过UPROPERTY的元说明符如EditAnywhere, BlueprintReadWrite, Category=&quot;Movement&quot;等实现）。反射提供了构建这个UI所需的所有信息。 网络复制： 在多人游戏中，服务器需要将状态同步到客户端。 引擎需要知道哪些属性(UPROPERTY(Replicated))需要被复制、在什么条件下复制。反射提供了需要复制的属性列表和复制规则。 命令行动态调用： 通过控制台命令或蓝图调用特定对象的特定函数。 系统需要根据字符串形式的函数名和参数，在运行时找到匹配的函数并执行它。反射提供了函数名到实际函数指针的映射。 动态创建对象： 根据类名（字符串）在运行时创建对象实例（例如NewObject()或SpawnActor()内部查找）。 引擎需要根据提供的类名字符串，找到对应的UClass*，然后才能创建实例。反射维护了所有反射类的注册表。 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 3. UE C++中的反射机制随便打开一个在UE中创建的C++文件，比如MoveActor.h: 12345678910111213141516171819202122232425262728// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MoveActor.generated.h&quot;UCLASS()class RIDERTEST_API AMoveActor : public AActor&#123;\tGENERATED_BODY()\tpublic: // Sets default values for this actor&#x27;s properties\tAMoveActor();protected:\t// Called when the game starts or when spawned\tvirtual void BeginPlay() override;public: // Called every frame\tvirtual void Tick(float DeltaTime) override;\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\tfloat Speed;&#125;; 注意这三个地方：UCLASS()，GENERATED_BODY()，UPROPERTY(EditAnywhere,BlueprintReadWrite)","tags":["UE","C++","序列化","反射"]},{"title":"plantuml和gpt结合快速画图技巧","path":"/2024/10/01/plantuml和gpt结合快速画图/","content":"节省画图的时间——plantuml和gpt结合最近不是在写各种文档嘛。需求，总体以及详细设计里总是缺少不了各种图表。作为一个特别爱偷懒的东西，怎么能不好好利用一下Chatgpt呢？之前手动地去画图表，拖来拖去，自己又排版得不尽如人意，修改一个地方可能要连着一大片都要重新去画。当然，我们不能让gpt直接去给我们画一张图出来，我们需要一个介质语言——plantuml——这是一个非常灵活好用的工具，可以通过简单的语法描述去创建各种各样的图表。这里是这个工具的语言使用指南：plantuml语法手册，我们可以参照这些，尝试去画一些简单的图。 使用工具好的，接下来让我们列出需要用到的工具： Chatgpt（或者其他AI小助手都可以，Kimi也还不错，通义千问也还行，不过都是我Chatgpt崩掉时的备用品） 直接打开plantuml的在线服务器就好——快速开始plantuml在线服务器 别忘了你的脑子——别想着什么事都交给gpt去做哦~ 我们打开在线服务器快速开始plantuml在线服务器，可以看到我们的界面： 没错，这就是我们的第一个例子！非常简单的界面，上面输入内容，下面就会自动生成我们需要的图表！（箭头我写错了不好意思） 具体的语法文档查看plantuml语法手册就可以了！我认为里面已经讲得非常非常详细了。接下来我们用它和chatgpt来帮我们画图。 提示词写法提示词很简单，以下是我经常用的格式： 我现在正在写软件其中一个模块的总体设计文档（说明自己的使用场景），我的这个模块包含以下几个子模块;blablabla……这些子模块是这样交互的，这个模块和这个模块这样。。。那个模块和那个模块那样。。。。，我现在需要你帮我用plantuml，画出这些子模块之间的时序图/模块图。 当然你也不用这么麻烦，如果你之前已经跟gpt把整体的流程打磨核对得差不多了，它已经有相关记忆了，你也可以直接问它要： 我现在需要这个模块的流程图，请你用plantuml的语法格式给我画一份流程图。 由于项目的特殊性，问的时候尽量规避掉敏感词，可以用视频中的音频去替换，总之处理流程大体差不多，谁知道隐私泄露会不会有问题呢 下面演示一下： 这个时候chatgpt会详细得返回一段代码： 给这段代码复制粘贴到我们的plantuml在线服务器上，便可以直接画出图来！ 如果你觉得不满意，可以再让gpt生成一份，但要明确指出你哪不满意。 如果你觉得这样的图不错，你也可以继续在上面这个界面修改文字，细化一些细节，或者更改图标的主题。 最后你可以将画好的图导出成PNG或者SVG，非常方便！一分钱不花！还没有水印！ 如果你之前和gpt已经聊过你要写的那个模块的内容并且帮助gpt理清了逻辑，那么你可能会得到更好的，更细节的图，比如下面这样： 画完了之后可以再参照plantuml的文档，可以加一些自己想加的东西进去，比如note便利贴之类的让图表功能更清楚。 总之，别只让gpt给你写！自己要先理清楚逻辑，你才能知道gpt画的图哪里出了问题！自己一定也要动脑子！","tags":["小技巧"]},{"title":"Daily","path":"/Daily/index.html","content":"2024.11.18今天还没干啥"},{"path":"/about/index.html","content":"鲍波波这是个人简介 Baobobo qq: 1091992414 滕王阁序王勃时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。重九日节选"}]