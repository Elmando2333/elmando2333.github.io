[{"title":"细拆二分法","path":"/2025/10/25/细拆二分法/","content":"这两周学到了二分相关，思想听起来颇为简单，实际写起来漏洞百出，如果是面向测试案例编程的话，经常胡乱+1-1，随机尝试&gt;或者&gt;=，拆了东墙补西墙，怎么堵都堵不明白。细节太多了，各种写法层出不穷，开区间的，闭区间的，左开右闭的，左闭右开的。找目标值的，找两端目标值位置的，找插入位置的，找最小的，找最大的，就是各种变了花样地找。所以还是一步步搞搞清楚，目前的总结只是从我刷到的六道题中总结的，但感觉万变不离其宗。所以来拿表格总结演示一下。 我的日常写法跟随大众写左闭右开，也就是说最后的答案基本是从left得到的。（虽然最后的退出条件是两者相等，但是为了统一还是用left。） 首先确定一些必要的条件： 由于计算mid时，为了防止溢出，经常使用这一句： 1mid=left+(right-left)/2; 所以，如果窗口长度为偶数，mid计算出来为偏向左边的索引。很符合左闭右开的规则。 举例： left=3，right=6，mid=3+（6-3）/2=4.5=4。 left=0，right=1，mid=0+（1-0）/2=0.5=0。 想找的值比所有都大： left=length-1, right=length, mid=length-1+(length-length+1)/2=length-1+0.5=length-1; left=mid+1=length, 退出循环，进行最后的判断。 想找的值比所有都小： left=0, right=1,mid=0+(1-0)/2=0.5=0 right=mid=0,此时left=right，退出循环，判断索引0是否为想要的值即可。 给的target不在里面怎么办举个例子，此处具体数值只用small和big代表，防止陷入对数值的计算。 1 3 5 7 9 找6 left先到5，right还是9，然后right成为7，找不到的情况下，left和right肯定相邻，并且left为small，right为big。 为了细致表达，考虑完整的三种情况： 第一种：找不到的数的大小处于数组中间： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，mid right 此时，left&lt;right，还可以跑一次循环，left需要往右移动，变成： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，right 此时，left=right，退出循环。最后，我们得到的left所指的这个数就是大于target的最小索引 第二种情况，target比所有数都小，right会不断往左移动，最后还是会和left相邻： index 0 1 。。。 number bigger bigger point left，mid right 此时，由于mid比target大，right还需要往左移，变成： index 0 1 。。。 number bigger bigger point left，mid，right 此时，left=right，退出循环。left值不是我们想要的值，此时left就是大于target值的最小索引。 第三种情况，target比所有数都大，left会不断向右移动，最后和right相邻： index 0 。。。 len-2 len-1 len number smaller nullptr！ point left，mid right 此时left还需要右移，得到： index 0 。。。 。。。 len-2 len-1 len number smaller nullptr！ point left，right 此时left和right相等，退出循环。检查left的值，超出len-1，说明target比所有数都大。 至此，可以稍微总结一下找不到target的情况下，算出来的left： left左边还有地，那么left就是小于target的最大索引，left+1如果存在，那么left+1就是大于target的最小索引。 left直接跑出长度范围了，那么没别的意义，left-1即len-1即为最大值。 如果想求大于/小于target的最小/最大索引，但有重复target怎么办？上面推导的情况，也就是target不出现/只出现一次时，小于/大于target的最小索引/最大索引其实根据推导的结论也能直接得到了。但是大部分的题目不长这么简单，它会出现很多重复的target，这时候就需要计算边界了。 一般的题目我们都不会知道target会不会存在于数组中。为了保险起见，下面会做完整的推理。 如果存在，并且有很多个，那么就需要计算边界了。首先计算左边界： 计算左边界的时候，如果得到了nums[mid]==target，也不能就此退出，需要继续寻找左边还有没有，这时候就需要让right向左挤压。 首先要想清楚一点，就是left只有在nums[mid]&lt;target的时候才会移动。所以，nums[left]第一次和target相等后，就不会再动了，然后right步步紧逼，最后形成以下局面 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid right 再来一次循环，right再向左移动 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid，right 此时，退出循环，left即为我们要找的最左边。 有很多题都会用到求最左侧的索引。比如2529这道题，找到比0小的，0有可能存在也有可能不存在。如果0存在，那么我们计算出left后，要检查left-1是否存在，如果存在，那么left左边都是比0小的，left-1就是小于0的最大索引。 如果0不存在，又回到了最初那个target不存在的情况，即left本身就为小于target值的最大索引。 -2，-1，3 那么如何求最右侧的索引呢？思路差不多，也就是让left向右步步紧逼。也要搞清楚一点，right的值只会在target&lt;nums[mid]才会移动到mid上。如图，最后都会走向如此局面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left,mid right 此时left还需要右移，得到下面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left，right 此时left=right，而我们发现left所指的是x后面那个数，所以最后我们要返回left-1。 而其实，left即为大于target的最小索引。 那么如果target不存在呢？那我们又回到了最初的那种情况：left即为大于target的最小索引，小于left都比它小。 所以可以发现，如果想求大于target的值的多少，拿到left即可了，left的左边绝对都比tartget小。 那么搞明白这些，也就差不多了。 至于边际条件，搞清楚left的取值范围是[0,len]，注意一下为0时和为len时的情况即可。 代码：（待补充）","tags":["C++","算法","二分查找"]},{"title":"谈谈右值与右值引用","path":"/2025/10/10/谈谈右值/","content":"之前学习了C++的左值右值，但只留在了对于概念的理解上面。今天学习了一下移动构造函数，临时对象/将亡值即将被销毁时会唤起移动构造函数。还有一个std::move()，它的主要作用是将一个左值转换为右值引用，从而强制使用移动构造函数或移动赋值运算符。所以这个std::move()只是进行了一个类型转换而已，并不会触发移动操作。使用std::move（）后，我们就可以调用接受右值引用的函数。 1234template&lt;typename T&gt;constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);&#125; 再回顾一下左右值的定义： 左值：通常指的是有名字的变量或者持久对象，可以取它的地址。右值：通常是临时对象，比如函数返回的临时对象、字面量（除了字符串字面量，它实际上是左值）等。 右值引用：使用两个&amp;&amp;表示，例如 int&amp;&amp;。右值引用可以绑定到右值，但不能绑定到左值。 我看有些教程说右值不能取地址，我一直对此非常疑惑：右值为什么不能取地址？既然存在，那肯定在内存/寄存器里，那么右值引用又是什么？ 通过右值引用，我们可以延长右值的生命周期，右值引用本身是一个左值，因为它有名字。所以我们可以对右值引用取地址，这个地址就是被引用的右值对象的地址。 主要需要搞清楚两个问题： 右值引用是一个左值？是 右值引用是否在内存中创建了一个新对象，复制了即将销毁的右值？ 不是的。右值引用并不创建新对象，它只是引用了那个右值（临时对象）。但是，由于右值引用本身是一个左值，所以当使用右值引用时，实际上是在直接操作那个临时对象。 123456int main() &#123; MyString&amp;&amp; rref = MyString(&quot;Hello&quot;); // 右值引用绑定到临时对象 // 这里，临时对象的生命周期被延长到与rref相同 // 没有创建新对象，也没有复制数据，rref就是临时对象的别名 return 0;&#125; 在这个例子中，用一个右值引用rref绑定了一个临时对象。根据C++规则，这样做会延长临时对象的生命周期，使其与右值引用的生命周期相同。所以，在main函数结束前，这个临时对象都不会被销毁。这里没有发生拷贝，也没有移动，只是给临时对象起了一个别名。 BUT 看看到现在，还是用高层的概念去解释一个新的概念。如果一直在高层徘徊，就会产生很多疑问：临时对象是在内存中存储吗？int&amp;&amp;a=2, 2的地址不能被取到，那为什么用右值引用就能取了？那是不是意味着编译器在中间就是开了一个临时对象呢？又有说表达式结束，临时对象就会被销毁。那么如果还是按照刚刚那些高层概念解释，对象都被销毁了，右值引用还在引用什么呢？ 还是下到汇编看看。终于在知乎找到了一篇文章，终于在汇编层面解答了我上面的问题： https://zhuanlan.zhihu.com/p/389978619?share_code=IPKeoBHAwX3u&amp;utm_psn=1960118829079307210 下面是答案： int &amp;&amp;a=0; 其中a是一个右值引用。 这个汇编代码等价于一个左值引用（底层看就是指针常量）引用了一个匿名变量，此匿名变量在C++中不可见，但其实该变量存在于栈上。总结来说，右值引用的底层就是一个指针指向了一个匿名变量。那么如果对右值引用重新赋值修改，改的就是匿名变量的值。","tags":["C++"]},{"title":"顶层const与底层const","path":"/2025/10/09/顶层const与底层const/","content":"理清 C++ 中顶层 const 和底层 const 的概念，感觉理解起来有些混乱。 具体讲解看的是《C++ Primer》。 核心概念顶层 const (top-level const)：对象本身是常量底层 const (low-level const)：指针/引用指向的对象是常量 具体例子1. 顶层 const 的例子123int a = 10;const int b = 20; // b 是顶层 const（b 本身是常量）int *const p1 = &amp;a; // p1 是顶层 const（指针本身是常量） 特点： 对象本身的值不能改变 对于指针：指针的指向不能改变，但指向的内容可以改变 1234int a = 10, b = 20;int *const p = &amp;a; // 顶层 const// p = &amp;b; // 错误！指针指向不能改变*p = 30; // 正确！指向的内容可以改变 2. 底层 const 的例子1234int a = 10;const int *p1 = &amp;a; // p1 是底层 constint const *p2 = &amp;a; // p2 也是底层 const（两种写法等价）const int &amp;r = a; // r 是底层 const 特点： 指针/引用指向的对象是常量 指针的指向可以改变，但不能通过指针修改指向的对象 1234int a = 10, b = 20;const int *p = &amp;a; // 底层 constp = &amp;b; // 正确！指针指向可以改变// *p = 30; // 错误！不能通过指针修改指向的对象 3. 同时包含的情况12const int *const p = &amp;a; // 左边是底层 const，右边是顶层 const// 读作：p 是一个常量指针，指向一个常量整数 记忆技巧方法1：看 const 的位置123int *const p; // const 在 * 右边 → 顶层 constconst int *p; // const 在 * 左边 → 底层 const int const *p; // const 在 * 左边 → 底层 const 方法2：从右向左读12int *const p; // 从右往左：p 是 const 指针，指向 intconst int *p; // 从右往左：p 是指针，指向 const int 实际应用中的区别1. 拷贝操作的限制123456789int a = 10;const int b = 20;// 顶层 const 不影响拷贝int c = b; // 正确：可以忽略顶层 constconst int *p1 = &amp;a; // 底层 constint *p2 = p1; // 错误！不能忽略底层 constconst int *p3 = p1; // 正确：底层 const 可以保留 2. 函数重载12345void func(int *p); // #1void func(const int *p); // #2 重载，底层 const 不同void func(int p); // #3void func(const int p); // #4 错误！顶层 const 不能重载 这里需要用函数值传递仔细说明一下： const不会改变参数的类型，因此不能作为函数重载的依据。会忽略掉顶层const 函数进行传参时，传的都是值的副本，对副本是否加const，不会改变参数类型。 12void fun1(int x);void fun1(const int x);//报错 Redundant ‘fun1’ declaration [readability-redundant-declaration]E:\\UnrealWorld\\project\\Learncpp\\Learncpp\\main.cpp:5:6: note: previously declared here 3. 引用的情况引用天生就是”顶层 const”（因为引用一旦绑定就不能改变），所以我们只关心底层 const： 123int a = 10;int &amp;r1 = a; // 普通引用const int &amp;r2 = a; // 底层 const 引用 总结 类型 示例 const 类型 什么不能改变 常量整数 const int a 顶层 const a 的值 常量指针 int *const p 顶层 const p 的指向 指向常量的指针 const int *p 底层 const 通过 p 修改指向的对象 常量引用 const int &amp;r 底层 const 通过 r 修改绑定的对象 核心区别： 顶层 const：我本身是常量 底层 const：我指向/引用的对象是常量","tags":["C++"]},{"title":"星露谷卡片生成器技术要点记录及解决方案","path":"/2025/09/04/星露谷卡片生成器技术要点记录及解决方案/","content":"我开发了一个星露谷风格的卡片生成器小程序，遇到最麻烦的问题就是字体的处理。微信小程序的字体处理存在诸多限制，尤其是真机环境兼容性问题，有时候在开发工具上一切都好，一上手机啥效果也没了。为了解决这些问题，主要参考了https://juejin.cn/post/7252175375105916965#heading-7这篇文章的解决办法。 微信小程序字体加载限制问题：wx.loadFontFace没有缓存机制，用户每次打开小程序，都要重新下载字体文件。我买的阿里云oss的下行流量包，如果每次都要重新下载字体文件，有点小贵。。。 解决方案： 使用wx.loadFontFace API加载字体 将字体文件转换为base64格式存储 实现字体缓存机制，避免重复下载 12345678910111213141516// 使用loadFontFace加载字体async loadFontFaceFromBase64(fontName, base64) &#123; return new Promise((resolve) =&gt; &#123; wx.loadFontFace(&#123; family: fontName, global: true, source: `data:font/ttf;base64,$&#123;base64&#125;`, scopes: [&#x27;webview&#x27;, &#x27;native&#x27;], success: () =&gt; resolve(true), fail: (err) =&gt; &#123; console.error(`字体加载失败: $&#123;fontName&#125;`, err); resolve(false); &#125; &#125;); &#125;);&#125; OpenType.js 集成如果直接用canvas画下载好的字体，在开发工具上显示是正常的，但在真机测试的时候，渲染出的canvas的字体退回到了系统自带。微信团队好像还是没有解决这个问题。遂参考他人用OpenType.js库解决。 字体解析与缓存OpenType.js是一个强大的字体处理库，可以将字体文件解析为可操作的JavaScript对象。 1234567891011121314151617181920212223// 字体解析核心代码async preloadSingleFont(font) &#123; try &#123; // 从缓存读取base64数据 const base64 = await this.fetchFontBase64(font.id, font.url); // 将base64转换为ArrayBuffer const arrayBuffer = wx.base64ToArrayBuffer(base64); // 使用opentype.js解析字体 const fontType = await opentype.parse(arrayBuffer); // 缓存字体对象 this.fontCache[font.id] = &#123; fontType: fontType, base64: base64 &#125;; console.log(`字体预加载成功: $&#123;font.name&#125;`); &#125; catch (error) &#123; console.error(`字体预加载失败: $&#123;font.name&#125;`, error); &#125;&#125; 字体绘制实现OpenType.js的核心优势在于可以将文字转换为路径对象，然后通过Canvas API进行绘制。 1. 带阴影的字体绘制1234567891011121314151617181920212223242526272829303132333435drawTextWithOpenType(ctx, text, x, y, fontSize, color = &#x27;#1a1a1a&#x27;, fontWeight = &#x27;normal&#x27;) &#123; // 检查是否需要显示阴影 const shouldShowShadow = this.data.selectedFontId !== &#x27;stardew&#x27;; if (!this.fontType) &#123; // 降级到默认绘制方式 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); return; &#125; try &#123; // 字体阴影效果 if (shouldShowShadow) &#123; const shadowPath = this.fontType.getPath(text, x + 0, y + 2, fontSize); const shadowColor = this.colorToRgba(color, 0.4); shadowPath.fill = shadowColor; shadowPath.draw(ctx); &#125; // 使用opentype.js生成路径 const path = this.fontType.getPath(text, x, y, fontSize); path.fill = color; // 粗体效果实现 if (fontWeight === &#x27;bold&#x27;) &#123; this.drawBoldText(path, ctx, text, x, y, fontSize, color); &#125; else &#123; path.draw(ctx); &#125; &#125; catch (error) &#123; console.error(&#x27;opentype.js绘制失败:&#x27;, error); // 降级处理 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); &#125;&#125; 2. 粗体效果实现由于微信小程序环境的限制，在真机测试时还是无法直接使用字体的粗体变体（也没搞懂为什么）。通过多次绘制模拟粗体效果： 123456789101112131415161718// 真机兼容的粗体实现drawBoldText(path, ctx, text, x, y, fontSize, color) &#123; // 绘制原始路径 path.draw(ctx); // 创建偏移路径，模拟粗体效果 const path1 = this.fontType.getPath(text, x + 0.5, y, fontSize); path1.fill = color; path1.draw(ctx); const path2 = this.fontType.getPath(text, x, y + 0.5, fontSize); path2.fill = color; path2.draw(ctx); const path3 = this.fontType.getPath(text, x + 0.5, y + 0.5, fontSize); path3.fill = color; path3.draw(ctx);&#125; 3. 文本换行处理对于长文本，实现了自动换行功能： 123456789101112131415161718192021222324252627282930313233wrapTextWithOpenType(ctx, text, x, y, maxWidth, lineHeight, color = &#x27;#2F1B14&#x27;) &#123; if (!this.fontType) &#123; return this.wrapText(ctx, text, x, y, maxWidth, lineHeight, color); &#125; let line = &#x27;&#x27;; let currentY = y; for (let i = 0; i &lt; text.length; i++) &#123; const testLine = line + text[i]; // 使用默认字体测量宽度（因为opentype.js测量比较复杂） ctx.setFontSize(20); const testWidth = ctx.measureText(testLine).width; if (testWidth &gt; maxWidth &amp;&amp; i &gt; 0) &#123; // 绘制当前行 this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); line = text[i]; currentY += lineHeight; &#125; else &#123; line = testLine; &#125; &#125; // 绘制最后一行 if (line) &#123; this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); currentY += lineHeight; &#125; return currentY;&#125; 双层缓存系统设计文件缓存层为了减少网络请求和提高加载速度，实现了文件缓存： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 字体缓存系统class FontCache &#123; // 读取字体缓存 readFontCache(fontId) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.readFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, encoding: &#x27;utf8&#x27;, success: (res) =&gt; &#123; console.log(`从缓存读取字体: $&#123;fontId&#125;`); resolve(res.data); &#125;, fail: () =&gt; &#123; console.log(`缓存中未找到字体: $&#123;fontId&#125;`); resolve(null); &#125; &#125;); &#125;); &#125; // 写入字体缓存 writeFontCache(fontId, base64Data) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.writeFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, data: base64Data, encoding: &#x27;utf8&#x27;, success: () =&gt; &#123; console.log(`字体缓存写入成功: $&#123;fontId&#125;`); resolve(true); &#125;, fail: (err) =&gt; &#123; console.error(`体缓存写入失败: $&#123;fontId&#125;`, err); resolve(false); &#125; &#125;); &#125;); &#125; // 获取字体base64数据（带缓存） async fetchFontBase64(fontId, fontUrl) &#123; // 先尝试从缓存读取 const cache = await this.readFontCache(fontId); if (cache) &#123; return cache; &#125; // 缓存中没有，从网络下载 console.log(`从网络下载字体: $&#123;fontId&#125;`); return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: fontUrl, method: &#x27;GET&#x27;, responseType: &#x27;arraybuffer&#x27;, success: async (res) =&gt; &#123; try &#123; // 将arraybuffer转换为base64 const base64 = wx.arrayBufferToBase64(res.data); // 写入缓存 await this.writeFontCache(fontId, base64); console.log(`字体下载并缓存成功: $&#123;fontId&#125;, 大小: $&#123;res.data.byteLength&#125; bytes`); resolve(base64); &#125; catch (error) &#123; console.error(`字体转换base64失败: $&#123;fontId&#125;`, error); reject(error); &#125; &#125;, fail: (err) =&gt; &#123; console.error(`字体下载失败: $&#123;fontId&#125;`, err); reject(err); &#125; &#125;); &#125;); &#125;&#125; 内存缓存层最开始用上面的方法，切换还是太慢了，换一个字体要十秒钟。。。还是先加载到内存缓存快一些： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 内存缓存系统class MemoryCache &#123; constructor() &#123; this.fontCache = &#123;&#125;; &#125; // 预加载所有字体到内存缓存 async preloadAllFonts(availableFonts) &#123; console.log(&#x27;开始预加载所有字体...&#x27;); const preloadPromises = []; for (const font of availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125; &#125; // 快速切换字体 async fastSwitchFont(fontId, fontName) &#123; try &#123; console.log(`快速切换字体: $&#123;fontName&#125;...`); // 确保字体缓存对象存在 if (!this.fontCache) &#123; this.fontCache = &#123;&#125;; &#125; // 如果是系统默认字体 if (fontId === &#x27;system&#x27;) &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); console.log(`快速切换到系统默认字体`); return; &#125; // 检查内存缓存 if (this.fontCache[fontId]) &#123; console.log(`从内存缓存快速切换字体: $&#123;fontName&#125;`); this.fontType = this.fontCache[fontId].fontType; this.setData(&#123; fontLoaded: true &#125;); // 异步加载到系统字体（不阻塞切换） this.loadFontFaceFromBase64(fontName, this.fontCache[fontId].base64); return; &#125; // 如果内存缓存中没有，回退到正常加载 console.log(`内存缓存中未找到字体，回退到正常加载: $&#123;fontName&#125;`); await this.loadSelectedFont(); &#125; catch (error) &#123; console.error(`快速切换字体失败: $&#123;fontName&#125;`, error); // 回退到正常加载 await this.loadSelectedFont(); &#125; &#125;&#125; 九宫格边框实现为了实现星露谷风格的边框效果，使用了九宫格技术： 12345678910111213141516171819202122232425262728293031323334// 九宫格边框绘制drawBorder(ctx, width, height, borderWidth = 12) &#123; const slice = 75; // border-image slice const imgPath = &#x27;/imgs/aaa.png&#x27;; wx.getImageInfo(&#123; src: imgPath, success: (res) =&gt; &#123; const imgW = res.width; const imgH = res.height; const path = res.path; // 绘制九个部分 // 四个角 ctx.drawImage(path, 0, 0, slice, slice, 0, 0, borderWidth, borderWidth); // 左上 ctx.drawImage(path, imgW - slice, 0, slice, slice, width - borderWidth, 0, borderWidth, borderWidth); // 右上 ctx.drawImage(path, 0, imgH - slice, slice, slice, 0, height - borderWidth, borderWidth, borderWidth); // 左下 ctx.drawImage(path, imgW - slice, imgH - slice, slice, slice, width - borderWidth, height - borderWidth, borderWidth, borderWidth); // 右下 // 四个边 ctx.drawImage(path, slice, 0, imgW - 2 * slice, slice, borderWidth, 0, width - 2 * borderWidth, borderWidth); // 上 ctx.drawImage(path, slice, imgH - slice, imgW - 2 * slice, slice, borderWidth, height - borderWidth, width - 2 * borderWidth, borderWidth); // 下 ctx.drawImage(path, 0, slice, slice, imgH - 2 * slice, 0, borderWidth, borderWidth, height - 2 * borderWidth); // 左 ctx.drawImage(path, imgW - slice, slice, slice, imgH - 2 * slice, width - borderWidth, borderWidth, borderWidth, height - 2 * borderWidth); // 右 &#125; &#125;);&#125; 动态属性绘制对于卡片的属性部分，实现了动态绘制功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 绘制动态属性drawStats(ctx, startX, startY, width) &#123; const stats = this.data.itemStats.filter(stat =&gt; stat.name &amp;&amp; stat.value); if (stats.length === 0) return startY; let currentY = startY; let completedCount = 0; let hasAsyncIcons = false; // 设置属性文字颜色 ctx.setFillStyle(&#x27;#352f36&#x27;); stats.forEach((stat, index) =&gt; &#123; const statY = startY + (index * 36); if (stat.iconPath) &#123; hasAsyncIcons = true; // 异步加载图标 wx.getImageInfo(&#123; src: stat.iconPath, success: (iconRes) =&gt; &#123; // 绘制图标阴影 ctx.setGlobalAlpha(0.5); ctx.drawImage(iconRes.path, startX - 3, statY - 30 + 3, 35, 35); // 绘制图标主体 ctx.setGlobalAlpha(1.0); ctx.drawImage(iconRes.path, startX, statY - 30, 35, 35); // 绘制属性文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX + 40, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125;, fail: () =&gt; &#123; // 图标加载失败，使用默认文本 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125; &#125;); &#125; else &#123; // 没有图标，直接绘制文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); &#125; &#125;); return startY + (stats.length * 24);&#125; 性能优化策略字体加载优化123456789101112131415161718192021222324252627// 预加载策略async onLoad() &#123; // 初始化字体缓存对象 this.fontCache = &#123;&#125;; // 预加载所有字体到内存缓存 await this.preloadAllFonts(); // 加载当前选中的字体 await this.loadSelectedFont();&#125;// 并行预加载async preloadAllFonts() &#123; const preloadPromises = []; for (const font of this.data.availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125;&#125; 内存管理优化123456789101112131415161718192021222324// 字体缓存管理class FontCacheManager &#123; constructor() &#123; this.fontCache = &#123;&#125;; this.maxCacheSize = 10; // 最大缓存数量 &#125; // 添加字体到缓存 addFont(fontId, fontData) &#123; // 检查缓存大小 if (Object.keys(this.fontCache).length &gt;= this.maxCacheSize) &#123; // 移除最旧的缓存 const oldestKey = Object.keys(this.fontCache)[0]; delete this.fontCache[oldestKey]; &#125; this.fontCache[fontId] = fontData; &#125; // 清理缓存 clearCache() &#123; this.fontCache = &#123;&#125;; &#125;&#125; 错误处理与降级1234567891011121314151617181920212223242526272829// 完善的错误处理机制async loadSelectedFont() &#123; try &#123; // 尝试加载字体 await this.loadFontWithOpenType(); &#125; catch (error) &#123; console.error(&#x27;字体加载失败:&#x27;, error); // 降级处理 try &#123; await this.loadFontWithLoadFontFace(); &#125; catch (fallbackError) &#123; console.error(&#x27;降级加载也失败:&#x27;, fallbackError); // 使用系统默认字体 this.useSystemFont(); &#125; &#125;&#125;// 降级到系统字体useSystemFont() &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); wx.showToast(&#123; title: &#x27;使用系统默认字体&#x27;, icon: &#x27;none&#x27;, duration: 2000 &#125;);&#125; 第一次碰前端相关，写WXML和WXSS用Cursor真的省去了很多重复劳动！我只需要聚焦于底层逻辑还有优化就可以了，把组织容器布局交给AI来做就好。","tags":["小程序","前端"]},{"title":"C++左右值与引用","path":"/2025/08/29/C-左右值与引用/","content":"本笔记为【彻底搞懂C++移动语义/左值/右值/引用！！！】 https://www.bilibili.com/video/BV17ce7zLEzu/?p=2&amp;share_source=copy_web&amp;vd_source=92a7dafd94e8cc1bfc97784a3732ea8d的总结整理 左值和右值左值指的是一个指向特定内存的具有名称的值即具名对象。 如果一个值有名字，那么它就是左值。 右值为临时短暂的表达式或值，生命周期较短，没有一个稳定的、可识别的内存地址。 右值通常代表一个计算的中间结果，一个字面量或者一个即将被销毁的临时对象。 临时的，即用即弃的值，就是右值。 举例： 123int a = 1;int b = 2;int c = a+b; 其中，a,b,c都是左值，1和2都是没有名字的字面值，为右值。a+b的结果也是右值，为临时的中间变量值。 12x++;++x; 其中，x++是右值，编译器先生成一份x值的临时复制，然后才对x递增，返回的是没有自加之前的临时版本。 ++x是对x递增后，马上返回其自身，x和++x具有相同的地址，++x是一个左值。 ++x可以进行赋值操作。x++作为一个右值，赋值会报错。 1234int get_val(int val)&#123; return x;&#125; 其中，x也是一个右值，因为返回的不是x本身，而是x的一个临时复制。 12345678910int set_val(int val)&#123; int *p = &amp;val; x=val;&#125;int main()&#123; set_val(2);//此处的实参2是右值&#125; 进入函数后，形参val变成了左值，可以取地址。函数形参一定是左值，因为有名字。要注意：字符串字面量是一个左值，因为字符串字面量在C++中是一个常量字符数组，编译器会将其存储到程序的只读数据段中。程序运行开始到结束会一直存在。 左值引用我们使用指针可以对左值取地址，但是，指针指向的位置可被任意修改。 左值引用最常见的使用场景就是：希望函数能够修改传入的参数，虽然指针可以做到，但是引用会更清晰安全。 举例：值交换 1234567891011121314151617181920void swap_ptr(int *x, int *y)&#123; int temp = *x; *x= *y; *y= temp;&#125;void swap_ref(int&amp; x, int &amp;y)&#123; int temp=x; x=y; y=temp;&#125;int main()&#123; int a=1, b=2, c=3, d=4; swap_ptr(&amp;a,&amp;b); swap_ref(c,d);&#125; 可以发现引用更加简洁。 非常量左值的引用对象必须是左值。 但是常量左值引用，不仅可以引用左值，还能引用右值： 1const int &amp;x = 11; 但引用右值的作用没多大。 常量左值引用在于复制构造函数、复制赋值运算符的形参。 举例：类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &quot;Person.h&quot;Person::Person(const std::string&amp; nameVal, int ageVal): name(nameVal), age(ageVal)&#123; std::cout &lt;&lt; &quot;普通构造函数被调用 for: &quot; &lt;&lt; nameVal &lt;&lt; std::endl; &#125;Person::~Person()&#123; //std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;Person::Person(const Person&amp; other) : name(other.name), age(other.age) &#123; // 初始化 age std::cout &lt;&lt; &quot;拷贝构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl;&#125;Person&amp; Person::operator=(const Person&amp; other) &#123; std::cout &lt;&lt; &quot;拷贝赋值运算符被调用 from: &quot; &lt;&lt; other.name &lt;&lt; &quot; to: &quot; &lt;&lt; name &lt;&lt; std::endl; // 1. 检查自我赋值 (非常重要！) if (this == &amp;other) &#123; return *this; // 如果是自己给自己赋值，直接返回 &#125; name = other.name; age = other.age; return *this;&#125;void Person::printInfo() const &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;&#125;#include &quot;Person.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//hh// 一个接受常量引用的函数，演示其用法void printPersonInfo(const Person&amp; person) &#123; std::cout &lt;&lt; &quot;在 printPersonInfo 函数中: &quot;; person.printInfo(); // 因为 printInfo() 是 const 成员函数，所以可以在 const 对象上调用&#125;// 一个返回新对象的函数，用于演示Person createPerson(const char* name, int age) &#123; Person p(name, age); // 调用普通构造函数 return p; // 返回值可能会触发拷贝构造（或受RVO/NRVO优化影响）&#125;int main() &#123; std::cout &lt;&lt; &quot;当前控制台代码页: &quot; &lt;&lt; GetConsoleOutputCP() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;----- 创建对象 p1 -----&quot; &lt;&lt; std::endl; Person p1(&quot;Alice&quot;, 25); // 调用普通构造函数 std::cout &lt;&lt; &quot; ----- 通过拷贝构造创建 p2 -----&quot; &lt;&lt; std::endl; Person p2 = p1; // 调用拷贝构造函数 // p1 是一个左值，完美匹配 const Person&amp; 形参 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 通过拷贝赋值给 p2 -----&quot; &lt;&lt; std::endl; Person p3(&quot;Bob&quot;, 30); // 调用普通构造函数 p2 = p3; // 调用拷贝赋值运算符 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 传递常量对象 -----&quot; &lt;&lt; std::endl; const Person constP(&quot;Charlie&quot;, 40); // 一个常量对象 Person p4 = constP; // 成功调用拷贝构造函数，因为形参是 const Person&amp; p4.printInfo(); std::cout &lt;&lt; &quot; ----- 使用临时对象（右值） -----&quot; &lt;&lt; std::endl; p4 = Person(&quot;David&quot;, 50); // 先调用普通构造函数创建临时对象，再调用拷贝赋值运算符 p4.printInfo(); std::cout &lt;&lt; &quot; ----- 函数按常量引用传参 -----&quot; &lt;&lt; std::endl; printPersonInfo(p4); // p4 被以引用的方式传入，避免了一次拷贝 std::cout &lt;&lt; &quot; ----- 函数返回值（可能涉及拷贝） -----&quot; &lt;&lt; std::endl; Person p5 = createPerson(&quot;Eve&quot;, 60); p5.printInfo(); std::cout &lt;&lt; &quot; ----- Main 函数结束，开始析构 -----&quot; &lt;&lt; std::endl; return 0; // 所有对象离开作用域，析构函数按顺序被调用&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435----- 创建对象 p1 -----普通构造函数被调用 for: Alice----- 通过拷贝构造创建 p2 -----拷贝构造函数被调用 from: AliceName: Alice, Age: 25----- 通过拷贝赋值给 p2 -----普通构造函数被调用 for: Bob拷贝赋值运算符被调用 from: Bob to: AliceName: Bob, Age: 30----- 传递常量对象 -----普通构造函数被调用 for: Charlie拷贝构造函数被调用 from: Charlie----- 使用临时对象（右值） -----普通构造函数被调用 for: David拷贝赋值运算符被调用 from: David to: Charlie析构函数被调用 for: David at 000000BDF61BF888----- 函数按常量引用传参 -----在 printPersonInfo 函数中: Name: David, Age: 50----- 函数返回值（可能涉及拷贝） -----普通构造函数被调用 for: EveName: Eve, Age: 60----- Main 函数结束，开始析构 -----析构函数被调用 for: Eve at 000000BDF61BF5F8析构函数被调用 for: David at 000000BDF61BF5A8析构函数被调用 for: Charlie at 000000BDF61BF558析构函数被调用 for: Bob at 000000BDF61BF508析构函数被调用 for: Bob at 000000BDF61BF4B8析构函数被调用 for: Alice at 000000BDF61BF468Process finished with exit code 0. 复制构造函数的参数为什么必须是引用类型呢？ 12Person a;Person b = a; // 希望调用拷贝构造函数 如果没有引用，other是按值传参，为了把a的参数传到other，编译器需要先把a拷贝到other， 那拷贝 a 的时候，需要调用 拷贝构造函数 —— 可问题是这个拷贝构造函数就是我们正在定义的函数！ 于是就形成了一个无限递归调用，编译器根本无法完成参数传递。 因此，C++ 标准规定：拷贝构造函数必须以引用的形式接收参数，否则无法定义。 左值引用和右值引用都是新名字而已，所以都是左值。 右值引用和移动语义复习一下拷贝构造： 123456+----------------+ +----------------+| Person p1 | | Person p2 || this=0x1234 | | this=0x5678 || name -&gt; 0xAAAA | =====&gt; | name -&gt; 0xBBBB || &quot;Alice&quot; | | &quot;Alice&quot; |+----------------+ +----------------+ 说明： p1 的 name 指针指向堆内存 0xAAAA。 调用拷贝构造时，p2 重新分配了一块堆内存 0xBBBB，把 &quot;Alice&quot; 复制过去。 两个对象互不影响，拥有各自的资源。 移动构造： 1234567891011121314151617181920212223242526272829303132333435363738394041// 移动构造Person::Person(Person&amp;&amp; other) noexcept : name(other.name), age(other.age) &#123; other.name = nullptr; // 转移后置空 std::cout &lt;&lt; &quot;移动构造函数 from (对象地址=&quot; &lt;&lt; &amp;other &lt;&lt; &quot;, 旧name指针=&quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) → 新对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;;&#125;// 移动赋值Person&amp; Person::operator=(Person&amp;&amp; other) noexcept &#123; if (this == &amp;other) return *this; delete[] name; // 清理旧资源 name = other.name; // 接管资源 age = other.age; other.name = nullptr; std::cout &lt;&lt; &quot;移动赋值运算符 (接管指针 &quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) 到对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;; return *this;&#125;int main()&#123; ...... p2 = Person(&quot;Charlie&quot;, 40); // 移动赋值 ......&#125;构造前：+----------------+ | 临时Person tmp || this=0x9999 || name -&gt; 0xCCCC || &quot;Bob&quot; |+----------------+移动构造后：+----------------+ +----------------+| 临时Person tmp | | Person p3 || this=0x9999 | | this=0x8888 || name -&gt; null | =====&gt; | name -&gt; 0xCCCC || | | &quot;Bob&quot; |+----------------+ +----------------+ 说明： tmp 是一个临时对象，原本持有堆内存 0xCCCC。 移动构造时，p3 直接接管 tmp 的指针 0xCCCC。 tmp.name 被置为 nullptr，所以它析构时不会释放这块内存。 避免了深拷贝的开销。 总结： 1234567拷贝构造: 移动构造:p1(name-&gt;0xAAAA) tmp(name-&gt;0xCCCC) | | |----&gt; new 0xBBBB |----&gt; p3 接管指针 | copy &quot;Alice&quot; | tmp.name=null | |p2(name-&gt;0xBBBB) p3(name-&gt;0xCCCC) 拷贝 = 重新分配一块新内存，复制内容。 移动 = 直接偷走旧对象的指针，旧对象清空指针。 *为什么移动构造函数后面要写noexpect?(GPT生成总结)* 背景：STL 容器的元素移动 比如 std::vector 扩容时，它会把旧元素转移到新分配的内存里： 123std::vector&lt;Person&gt; v;v.push_back(Person(&quot;Alice&quot;, 20));v.push_back(Person(&quot;Bob&quot;, 30)); 当 vector 空间不够，需要重新分配时，它要把旧的元素（Alice）搬到新的内存。 此时有两个选择： 调用 移动构造函数（更快） 调用 拷贝构造函数（更安全） 如果移动构造函数可能抛异常 vector 在扩容时，搬到一半，结果某个元素的移动构造抛出了异常。 这时新内存里的部分对象构造完成，部分对象失败，旧内存里的对象可能已经被破坏（移动后被置空）。 整个容器就可能进入 不一致状态（既不能保证强异常安全，也不能 rollback）。 为了避免这种情况，标准库****要求：只有在移动构造函数被声明为 noexcept 时，容器才会使用它。否则容器会退而求其次，调用 拷贝构造函数（因为拷贝一般不会抛异常）。 因此在自定义类里实现移动构造函数时，加上 noexcept： 12345Person(Person&amp;&amp; other) noexcept : name(std::move(other.name)), age(other.age) &#123; std::cout &lt;&lt; &quot;移动构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl; other.age = 0;&#125; 总结 没有 noexcept STL 容器在需要移动元素时，可能会选择 拷贝构造，牺牲性能保证安全。 有 noexcept STL 容器可以放心大胆地使用移动构造，获得最大性能提升。 所以 noexcept 是一个 性能保证的承诺： 告诉编译器“移动构造不会抛异常”，容器才敢优化。","tags":["C++"]},{"title":"饼图练习","path":"/2025/08/24/饼图练习/","content":"① 表示比例 (Proportion / Share) — 8句 食品支出占家庭总支出的 30%。Food accounts for 30% in family consumption. 石油占比最大，为 40%。Oil makes up the biggest share, standing at 40%. 医疗费用仅占 5%。Only 5% is spent on medical services. 私家车占出行方式的 60%。Private car accounts for 60% of total transportation. 农业就业人口占比 25%。The agricultural workforce makes up 25% of total employment. 谷物占食品消费的 40%。Grain represent a 40% share of total food consumption. 公共汽车占比 20%。Public buses represent a 20% share of overall transportation. 住房花费占比最高，为 40%。Housing expenditure makes up the largest share, standing at 40%. ② 比较关系 (Comparison) — 8句 教育的比例是医疗的两倍。The propotion of education is twice as high as that of healthcare. 公共汽车的比例是火车的两倍。The share of buses is twice the proportion of trains. 娱乐和通讯的支出几乎持平。The expenditure on entertainment and communication are almost identical./ Spending on entertainment is nearly equal to that on communication. 煤炭的比例略高于天然气. The proportion of coal is slightly higher than that of natural gas. 自行车的比例最低，仅为 3%。Bicycle represents the lowest share, standing at 3%. 医疗费用比教育少 10 个百分点。Spending on healthcare is 10% points lower than that on education. 肉类消费比乳制品高出三倍。Consumption on meat is three times as much as that on dairy products. 蔬菜和水果的比例几乎相同。The share of vegetables is nearly equal to that of fruits. 表达“几乎持平”可以用： almost the same nearly equal almost identical roughly the same level ③ 趋势变化 (Trend / Change) — 8句 公交车的比例逐年下降。The proportion of bus usage decreased steadily each year. 可再生能源翻倍，从 5% 增加到 10%。The share of renewable energy doubled, rising from 5% to 10%. 农业的比例在十年间下降。The share of agricultural declined over the period of 10 years. 火车的比例保持稳定。The share of trains remained stable. 服务业逐年上升，超过了工业。The proportion of service rose each year, exceeding that of industrial sector. 医疗的比例下降了两个百分点。The share of healthcare declined by 2% points. 学习旅游增加了 5 个百分点。Studying tourism accounted for 5% points more than before. 娱乐支出翻了一倍。Entertainment expenditure doubled. ④ 总体特征 (Overall features) — 6句 整体来看，住房和食品主导了家庭预算。Overall, Spending on housing and food dominates the expenditure. 总体而言，化石燃料仍然占主导。Generally, fossil fuel still dominate energy consumption. 总体来看，私家车主导了交通方式。In general, private cars continue to dominate the transportation modes. 总体来看，服务业主导了就业结构。Generally, service sector dominated the employment structure. 观光旅游是最主要的旅游目的。Tourism for sightseeing accounts for the largest share. 总体而言，消费结构变化不大。Overall, the consumption of structure remained stable. “变化不大” → remained stable / showed little change / remained largely unchanged","tags":["英语"]},{"title":"反射机制与序列化","path":"/2025/08/17/反射机制与序列化/","content":"之前用Unity在定义变量时经常会在变量前面标记[SerializeField]，用于将private和protected属性的变量显示在inspector上（public变量会直接显示）。学习时没有细想这些都是什么。关于序列化也是只知道大概的作用。学习UE时碰到了反射系统，而序列化则是反射系统的一大应用场景。此篇笔记将学习记录序列化的概念，反射的概念以及UE的C++反射实现，以及在UE中，序列化又是如何通过反射实现的。 1. 什么是序列化计算机程序的基本运行周期可分为三个阶段：启动、运行和终止。当程序运行时，编译后的代码会被加载到内存中，程序运行过程中产生的变量和对象则存储在内存的栈区和堆区。然而，一旦程序终止运行，这些存储在内存中的临时数据都将丢失。为了持久化这些数据，我们需要在程序运行期间或终止前将其保存下来。这种需求常见于以下场景： 网络传输（如多人游戏中不同客户端间的状态同步） 游戏存档（保存玩家进度） 编辑器中对游戏对象的修改保存 简单来说，序列化 是将程序中的 对象（Object） 或 数据结构 转换为一种 可存储或可传输的格式（如二进制、JSON、XML等），以便在需要时能够重新恢复（反序列化）为原始对象的过程。 2. 什么是反射（Reflection）在UE中，每次修改完C++代码后都需要重新编译才能继续在编辑器中进行操作。这是因为编辑器需要获取代码中的变量和对象信息，以便在面板中提供可视化编辑功能。然而，C++编译过程会丢失许多对编辑器至关重要的元数据信息。C++的源码中的各种类型名变量名函数名文本人类可读，而编译器会直接将人类可读的代码源码编译为机器指令。编译器会丢弃什么呢？对于一个对象MyClass，运行时内存只需要知道某一块内存是哪种类型，并不需要知道名字字符串。对象成员health，只需要知道其在某一块内存的固定偏移量是多少。各种继承关系也会被处理为虚函数表（vtable），运行时通过vtable指针调用虚函数，而vtable本身不包含任何类名或父类名信息。简单来说，一切都被编译器转化为了各种地址信息，程序运行时只需要知道从哪块地址取出什么数据及指令即可。 程序在运行的时候如果想知道： 我自己有哪些类？ 这个类叫什么名字？继承自谁？ 类里面有哪些成员变量，叫什么？是什么类型？ 类里面有哪些成员函数？参数和返回值是什么？ 那么反射机制就是程序在运行时获取自身结构信息（类，属性，函数等）并能够操作他们的能力。 Unreal引擎的许多强大功能和高效工作流都严重依赖反射。没有它，以下事情要么极其困难，要么根本不可能： 序列化： 将对象的状态（属性值）保存到磁盘（如存盘文件.uasset）或通过网络发送。 引擎需要知道对象有哪些属性、它们的类型以及如何读取/写入它们的值。反射提供了这份“属性清单”和操作方法。 垃圾回收： Unreal使用自动内存管理（GC）来回收不再使用的UObject。 GC需要知道一个对象引用了哪些其他UObject（避免误删仍在使用的对象）。反射提供了属性之间的引用关系图（通过UPROPERTY()标记）。 蓝图与C++的互操作性： 这是Unreal最强大的特性之一。让设计师在蓝图中使用C++类、访问C++变量、调用C++函数。 蓝图系统需要在运行时知道C++类有哪些属性(UPROPERTY)暴露给蓝图编辑、有哪些函数(UFUNCTION)可以被蓝图调用、它们的参数是什么。反射提供了这份蓝图与C++交互的“接口说明书”。 编辑器细节面板： 在Unreal编辑器中选中一个Actor或Component时，右侧的“Details”面板会显示其可编辑的属性。 编辑器需要知道这个对象有哪些属性可以显示和编辑、它们的分类（Category）、显示名称、工具提示、取值范围等（通过UPROPERTY的元说明符如EditAnywhere, BlueprintReadWrite, Category=&quot;Movement&quot;等实现）。反射提供了构建这个UI所需的所有信息。 网络复制： 在多人游戏中，服务器需要将状态同步到客户端。 引擎需要知道哪些属性(UPROPERTY(Replicated))需要被复制、在什么条件下复制。反射提供了需要复制的属性列表和复制规则。 命令行动态调用： 通过控制台命令或蓝图调用特定对象的特定函数。 系统需要根据字符串形式的函数名和参数，在运行时找到匹配的函数并执行它。反射提供了函数名到实际函数指针的映射。 动态创建对象： 根据类名（字符串）在运行时创建对象实例（例如NewObject()或SpawnActor()内部查找）。 引擎需要根据提供的类名字符串，找到对应的UClass*，然后才能创建实例。反射维护了所有反射类的注册表。 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 3. UE C++中的反射机制随便打开一个在UE中创建的C++文件，比如MoveActor.h: 12345678910111213141516171819202122232425262728// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MoveActor.generated.h&quot;UCLASS()class RIDERTEST_API AMoveActor : public AActor&#123;\tGENERATED_BODY()\tpublic: // Sets default values for this actor&#x27;s properties\tAMoveActor();protected:\t// Called when the game starts or when spawned\tvirtual void BeginPlay() override;public: // Called every frame\tvirtual void Tick(float DeltaTime) override;\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\tfloat Speed;&#125;; 注意这三个地方：UCLASS()，GENERATED_BODY()，UPROPERTY(EditAnywhere,BlueprintReadWrite)","tags":["UE","C++","序列化","反射"]},{"title":"plantuml和gpt结合快速画图技巧","path":"/2024/10/01/plantuml和gpt结合快速画图/","content":"节省画图的时间——plantuml和gpt结合最近不是在写各种文档嘛。需求，总体以及详细设计里总是缺少不了各种图表。作为一个特别爱偷懒的东西，怎么能不好好利用一下Chatgpt呢？之前手动地去画图表，拖来拖去，自己又排版得不尽如人意，修改一个地方可能要连着一大片都要重新去画。当然，我们不能让gpt直接去给我们画一张图出来，我们需要一个介质语言——plantuml——这是一个非常灵活好用的工具，可以通过简单的语法描述去创建各种各样的图表。这里是这个工具的语言使用指南：plantuml语法手册，我们可以参照这些，尝试去画一些简单的图。 使用工具好的，接下来让我们列出需要用到的工具： Chatgpt（或者其他AI小助手都可以，Kimi也还不错，通义千问也还行，不过都是我Chatgpt崩掉时的备用品） 直接打开plantuml的在线服务器就好——快速开始plantuml在线服务器 别忘了你的脑子——别想着什么事都交给gpt去做哦~ 我们打开在线服务器快速开始plantuml在线服务器，可以看到我们的界面： 没错，这就是我们的第一个例子！非常简单的界面，上面输入内容，下面就会自动生成我们需要的图表！（箭头我写错了不好意思） 具体的语法文档查看plantuml语法手册就可以了！我认为里面已经讲得非常非常详细了。接下来我们用它和chatgpt来帮我们画图。 提示词写法提示词很简单，以下是我经常用的格式： 我现在正在写软件其中一个模块的总体设计文档（说明自己的使用场景），我的这个模块包含以下几个子模块;blablabla……这些子模块是这样交互的，这个模块和这个模块这样。。。那个模块和那个模块那样。。。。，我现在需要你帮我用plantuml，画出这些子模块之间的时序图/模块图。 当然你也不用这么麻烦，如果你之前已经跟gpt把整体的流程打磨核对得差不多了，它已经有相关记忆了，你也可以直接问它要： 我现在需要这个模块的流程图，请你用plantuml的语法格式给我画一份流程图。 由于项目的特殊性，问的时候尽量规避掉敏感词，可以用视频中的音频去替换，总之处理流程大体差不多，谁知道隐私泄露会不会有问题呢 下面演示一下： 这个时候chatgpt会详细得返回一段代码： 给这段代码复制粘贴到我们的plantuml在线服务器上，便可以直接画出图来！ 如果你觉得不满意，可以再让gpt生成一份，但要明确指出你哪不满意。 如果你觉得这样的图不错，你也可以继续在上面这个界面修改文字，细化一些细节，或者更改图标的主题。 最后你可以将画好的图导出成PNG或者SVG，非常方便！一分钱不花！还没有水印！ 如果你之前和gpt已经聊过你要写的那个模块的内容并且帮助gpt理清了逻辑，那么你可能会得到更好的，更细节的图，比如下面这样： 画完了之后可以再参照plantuml的文档，可以加一些自己想加的东西进去，比如note便利贴之类的让图表功能更清楚。 总之，别只让gpt给你写！自己要先理清楚逻辑，你才能知道gpt画的图哪里出了问题！自己一定也要动脑子！","tags":["小技巧"]},{"path":"/about/index.html","content":"鲍波波这是个人简介 Baobobo qq: 1091992414 滕王阁序王勃时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。重九日节选"},{"title":"Daily","path":"/Daily/index.html","content":"2024.11.18今天还没干啥"}]