[{"title":"new和delete（一）new与构造函数与各种初始化大乱炖","path":"/2026/01/26/new和delete/","content":"还是得勇敢直面我不会的东西。 上一篇整理了一些malloc和free相关的知识点。今天主要来看new和delete。 问起new和delete，我目前能说出来的有以下这些：new操作是在malloc申请到内存后，在申请到的内存上去调用对象的构造函数去构造对象（对于new一个自定义类型是这样的），其他细节暂不清楚。new操作失败会抛出异常，但是申请内存失败抛出的异常还是构造函数失败抛出的异常暂不清楚。new一个内置类型的过程暂不清楚（没有构造函数可调用）。new[]这种new一个数组的过程也很模糊。delete就更模糊了，只知道new和delete最好成对调用，new[]和delete[]也要成对调用。 下面的一些代码使用了https://gcc.godbolt.org/的compiler explorer，编译器版本为： x64 msvc v19.latest 所以，汇编的代码可不是AI生成的，只是让AI帮忙解读而已。实验结果都是运行过的，并非AI生成的。所以可信！ 问题一：new操作的本质简单写了一个类，成员变量是一个int变量和一个string变量： 12345678910111213141516// Type your code here, or load an example.#include &lt;string&gt;class A&#123; public: int count; std::string name; A()=default; ~A()=default;&#125;;int main()&#123; A* a1=new A();&#125; 编译出来的汇编代码长这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546this$ = 48A::A(void) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+8], rcx sub rsp, 40 ; 00000028H mov rax, QWORD PTR this$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rsp, 40 ; 00000028H ret 0A::A(void) ENDP ; A::A$T1 = 32tv70 = 40a1$ = 48main PROC$LN5: push rdi sub rsp, 64 ; 00000040H mov ecx, 40 ; 00000028H call void * operator new(unsigned __int64) ; operator new mov QWORD PTR $T1[rsp], rax cmp QWORD PTR $T1[rsp], 0 je SHORT $LN3@main mov rdi, QWORD PTR $T1[rsp] xor eax, eax mov ecx, 40 ; 00000028H rep stosb mov rcx, QWORD PTR $T1[rsp] call A::A(void) ; A::A mov QWORD PTR tv70[rsp], rax jmp SHORT $LN4@main$LN3@main: mov QWORD PTR tv70[rsp], 0$LN4@main: mov rax, QWORD PTR tv70[rsp] mov QWORD PTR a1$[rsp], rax xor eax, eax add rsp, 64 ; 00000040H pop rdi ret 0main ENDP 一点点来看，首先来看main函数里的流程：（读汇编代码美美交给AI来看） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889; ==============================================; 符号定义：main 函数中的局部变量偏移量; ==============================================$T1 = 32 ; 临时变量1：存储 operator new 返回的原始指针tv70 = 40 ; 临时变量2：存储构造函数调用后的结果指针a1$ = 48 ; 局部变量 a1 在栈上的位置; ==============================================; main 函数; ==============================================main PROC ; 开始 main 函数$LN5: ; 标签：代码块开始 ; 保存寄存器（遵循调用约定） push rdi ; 保存 rdi 寄存器（调用者保存寄存器） ; 设置栈帧 sub rsp, 64 ; 在栈上分配 64 字节空间 ; ====================================== ; 步骤1：调用 operator new 分配内存 ; ====================================== mov ecx, 40 ; 设置参数：要分配的大小 = 40 字节 ; ecx = sizeof(A) = sizeof(int) + padding + sizeof(std::string) ; = 4 + 4 + 32 = 40 call void * operator new(unsigned __int64) ; 调用 operator new 函数 ; 保存分配的内存地址 mov QWORD PTR $T1[rsp], rax ; 将返回值（内存地址）保存到栈上 $T1 位置 ; ====================================== ; 步骤2：检查内存分配是否成功 ; ====================================== cmp QWORD PTR $T1[rsp], 0 ; 比较分配结果是否为 NULL je SHORT $LN3@main ; 如果为 NULL（分配失败），跳转到失败处理 ; ====================================== ; 步骤3：分配成功，清零分配的内存（零初始化） ; ====================================== mov rdi, QWORD PTR $T1[rsp] ; rdi = 目标地址（将要清零的内存起始位置） xor eax, eax ; eax = 0（要填充的值） ; xor eax, eax 比 mov eax, 0 更快 mov ecx, 40 ; ecx = 计数器（要清零的字节数 = 40） rep stosb ; 重复执行：将 al(0) 存储到 [rdi]，然后 rdi++ ; 等价于 memset(ptr, 0, 40) ; 这是零初始化：因为使用了 new A() 而不是 new A ; ====================================== ; 步骤4：在清零的内存上调用构造函数 ; ====================================== mov rcx, QWORD PTR $T1[rsp] ; 将原始指针放入 rcx（构造函数参数 this） call A::A(void) ; 调用构造函数 A::A() ; 注意：构造函数只初始化了 std::string ; int count 已经在步骤3中被清零为0 ; 保存构造函数返回的 this 指针 mov QWORD PTR tv70[rsp], rax ; 将构造函数返回值（this）保存到栈上 ; 跳转到成功路径的合并点 jmp SHORT $LN4@main ; 无条件跳转到 $LN4@main ; ======================================; 分支：内存分配失败的处理; ======================================$LN3@main: ; 标签：分配失败 mov QWORD PTR tv70[rsp], 0 ; 设置结果为 NULL 指针 ; ======================================; 合并点：成功和失败路径的汇合处; ======================================$LN4@main: ; 标签：代码合并点 ; 将结果赋值给局部变量 a1 mov rax, QWORD PTR tv70[rsp] ; 从栈上加载结果到 rax mov QWORD PTR a1$[rsp], rax ; 保存到局部变量 a1 ; 设置 main 函数返回值 xor eax, eax ; eax = 0（main 函数返回 0） ; 清理栈帧并恢复寄存器 add rsp, 64 ; 释放栈上分配的 64 字节空间 pop rdi ; 恢复 rdi 寄存器 ; 函数返回 ret 0 ; 从 main 函数返回main ENDP ; main 函数结束 看下来这个步骤很清晰。见到了一个调用 operator new 函数,其实也就是new这个运算符的实现。 下面摘自new 和 delete 运算符 | Microsoft Learn new 运算符编译器将如下语句转换为对函数 operator new 的调用： C++ 1char *pch = new char[BUFFER_SIZE]; 如果请求的存储空间为零字节，**operator new** 将返回指向不同对象的指针。 也就是说，重复调用 operator new 会返回不同的指针。 如果分配请求的内存不足，**operator new** 会引发 std::bad_alloc 异常。 或者，如果使用了 placement 形式 nullptr，或者链接在非引发的 支持中，它将返回 new(std::nothrow)。operator new 有关详细信息，请参阅分配失败行为。 下表中描述了 operator new 函数的两个范围。 operator new 函数的范围 运算符 Scope ::operator new 全局 class-name**::operator new** 类 operator new 的第一个自变量必须为 size_t 类型，且返回类型始终为 **void\\***。 在使用 operator new 运算符分配内置类型的对象、不包含用户定义的 new 函数的类类型的对象和任何类型的数组时，将调用全局 operator new 函数。 在使用 new 运算符分配类类型的对象时（其中定义了 **operator new**），将调用该类的 **operator new**。 为类定义的 operator new 函数是静态成员函数（不能是虚函数），该函数隐藏此类类型的对象的全局 operator new 函数。 考虑 new 用于分配内存并将内存设为给定值的情况： C++ 123456789101112131415161718192021222324#include &lt;malloc.h&gt;#include &lt;memory.h&gt;class Blanks&#123;public: Blanks()&#123;&#125; void *operator new( size_t stAllocateBlock, char chInit );&#125;;void *Blanks::operator new( size_t stAllocateBlock, char chInit )&#123; void *pvTemp = malloc( stAllocateBlock ); if( pvTemp != 0 ) memset( pvTemp, chInit, stAllocateBlock ); return pvTemp;&#125;// For discrete objects of type Blanks, the global operator new function// is hidden. Therefore, the following code allocates an object of type// Blanks and initializes it to 0xa5int main()&#123; Blanks *a5 = new(0xa5) Blanks; return a5 != 0;&#125; 用括号包含的提供给 new 的自变量将作为 Blanks::operator new 自变量传递给 chInit。 但是，全局 operator new 函数将被隐藏，从而导致以下代码生成错误： C++ 1Blanks *SomeBlanks = new Blanks; 编译器在类声明中支持成员数组 new 和 delete 运算符。 例如： C++ 1234567891011121314151617class MyClass&#123;public: void * operator new[] (size_t) &#123; return 0; &#125; void operator delete[] (void*) &#123; &#125;&#125;;int main()&#123; MyClass *pMyClass = new MyClass[5]; delete [] pMyClass;&#125; 分配失败行为C++ 标准库中的 new 函数支持自 C++98 以来在 C++ 标准中指定的行为。 如果分配请求的内存不足，**operator new** 会引发 std::bad_alloc 异常。 较旧的 C++ 代码会为失败的分配返回 null 指针。 如果你的代码需要非引发版本的 **new**，请将程序链接到 *nothrownew.obj*。 nothrownew.obj 文件将全局 operator new 替换为分配失败时返回 nullptr 的版本。 operator new 不再引发 std::bad_alloc。 有关 nothrownew.obj 和其他链接器选项文件的详细信息，请参阅链接选项。 不能将检查全局 operator new 异常的代码与检查同一个应用程序中的 null 指针的代码混合使用。 但是，仍可以创建不同行为的类本地 **operator new**。 这种可能性意味着编译器在默认情况下必须以防御方式行事，并在 new 调用中包含对 null 指针返回的检查。 有关优化这些编译器检查的方法的详细信息，请参阅 /Zc:throwingnew。 我找到了MSVC 调试版本（_DEBUG）的 operator new 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// clang-format off: clang-format 19 doesn&#x27;t understand _CRTIMP2_PURE_IMPORT and will poorly format the following codeextern &quot;C++&quot; struct _CRTIMP2_PURE_IMPORT _Crt_new_delete &#123; // _CRTIMP2_PURE_IMPORT: 导出修饰符，表示这个结构从 DLL 导入 // _Crt_new_delete: 结构名，用于标记 CRT（C 运行时）分配的内存块 // 这个类只在 _DEBUG 模式下提供，用于调试版本的内存管理 #ifdef _DEBUG // 仅在调试版本中启用这些调试版本的操作符 // 标准的 operator new（可能抛出 std::bad_alloc 异常） void* __CLRCALL_OR_CDECL operator new(size_t _Size) &#123; // replace operator new // 1. 首先调用 nothrow 版本尝试分配内存 void* _Ptr = operator new(_Size, nothrow); // 2. 如果分配失败（返回 nullptr） if (!_Ptr) &#123; _Xbad_alloc(); // 内部函数，会抛出 std::bad_alloc 异常 // 注意：这个函数不会返回，它会抛出异常 &#125; // 3. 分配成功，返回指针 return _Ptr; &#125; // nothrow 版本的 operator new（不会抛出异常） void* __CLRCALL_OR_CDECL operator new(size_t _Size, const nothrow_t&amp;) noexcept &#123; // replace nothrow operator new // 关键：调用调试版本的 malloc // _malloc_dbg 参数解释： // 1. _Size &gt; 0 ? _Size : 1: C++标准要求 new(0) 返回有效指针 // 2. _CRT_BLOCK: 标记为 CRT 内部内存块类型 // 3. __FILE__: 源文件名（调试信息） // 4. __LINE__: 行号（调试信息） return _malloc_dbg(_Size &gt; 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__); // _malloc_dbg 最终会调用 malloc，但添加了： // - 分配额外的调试头（存储大小、文件名、行号等） // - 添加保护字节（检测缓冲区溢出） // - 链接到内存泄漏检测系统 &#125; // 标准的 operator delete（释放内存） void __CLRCALL_OR_CDECL operator delete(void* _Ptr) noexcept &#123; // replace operator delete // 直接调用 C 运行时的 free 函数 // _CSTD free: 引用标准 C 库的 free 函数 _CSTD free(_Ptr); // 注意：这里没有调用 _free_dbg，因为： // 1. 调试信息已经由 _malloc_dbg 记录 // 2. free 会自动处理调试版本的释放 &#125; // nothrow 版本的 operator delete（与 nothrow new 配对） void __CLRCALL_OR_CDECL operator delete(void* _Ptr, const nothrow_t&amp;) noexcept &#123; // replace nothrow operator delete // 简单地转发到标准的 operator delete operator delete(_Ptr); &#125; // 定位 new（placement new） - 在已有内存上构造对象 void* __CLRCALL_OR_CDECL operator new(size_t, void* _Ptr) noexcept &#123; // imitate True Placement New // 不分配新内存，直接返回传入的指针 return _Ptr; // 用途：在预分配的内存上构造对象 // 示例：new(buffer) MyClass(); &#125; // 定位 delete（placement delete） - 与定位 new 配对 void __CLRCALL_OR_CDECL operator delete(void*, void*) noexcept &#123;&#125; // imitate True Placement Delete // 空实现，因为定位 new 没有分配内存，所以不需要释放 // 只用于异常安全：如果定位 new 后的构造函数抛出异常，会调用这个#endif // _DEBUG // 调试版本结束标记&#125;;// clang-format on 再顺藤摸瓜看看_malloc_dbg这个函数： 找到了crtdbg.h这个文件，有一堆宏： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef _DEBUG #define _calloc_dbg(c, s, t, f, l) calloc(c, s) #define _expand_dbg(p, s, t, f, l) _expand(p, s) #define _free_dbg(p, t) free(p) #define _malloc_dbg(s, t, f, l) malloc(s) #define _msize_dbg(p, t) _msize(p) #define _realloc_dbg(p, s, t, f, l) realloc(p, s) #define _recalloc_dbg(p, c, s, t, f, l) _recalloc(p, c, s) #define _aligned_free_dbg(p) _aligned_free(p) #define _aligned_malloc_dbg(s, a, f, l) _aligned_malloc(s, a) #define _aligned_msize_dbg(p, a, o) _aligned_msize(p, a, o) #define _aligned_offset_malloc_dbg(s, a, o, f, l) _aligned_offset_malloc(s, a, o) #define _aligned_offset_realloc_dbg(p, s, a, o, f, l) _aligned_offset_realloc(p, s, a, o) #define _aligned_offset_recalloc_dbg(p, c, s, a, o, f, l) _aligned_offset_recalloc(p, c, s, a, o) #define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a) #define _aligned_recalloc_dbg(p, c, s, a, f, l) _aligned_recalloc(p, c, s, a) #define _freea_dbg(p, t) _freea(p) #define _malloca_dbg(s, t, f, l) _malloca(s) #define _dupenv_s_dbg(ps1, size, s2, t, f, l) _dupenv_s(ps1, size, s2) #define _fullpath_dbg(s1, s2, le, t, f, l) _fullpath(s1, s2, le) #define _getcwd_dbg(s, le, t, f, l) _getcwd(s, le) #define _getdcwd_dbg(d, s, le, t, f, l) _getdcwd(d, s, le) #define _getdcwd_lk_dbg(d, s, le, t, f, l) _getdcwd(d, s, le) #define _mbsdup_dbg(s, t, f, l) _mbsdup(s) #define _strdup_dbg(s, t, f, l) _strdup(s) #define _tempnam_dbg(s1, s2, t, f, l) _tempnam(s1, s2) #define _wcsdup_dbg(s, t, f, l) _wcsdup(s) #define _wdupenv_s_dbg(ps1, size, s2, t, f, l) _wdupenv_s(ps1, size, s2) #define _wfullpath_dbg(s1, s2, le, t, f, l) _wfullpath(s1, s2, le) #define _wgetcwd_dbg(s, le, t, f, l) _wgetcwd(s, le) #define _wgetdcwd_dbg(d, s, le, t, f, l) _wgetdcwd(d, s, le) #define _wgetdcwd_lk_dbg(d, s, le, t, f, l) _wgetdcwd(d, s, le) #define _wtempnam_dbg(s1, s2, t, f, l) _wtempnam(s1, s2)#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv // #ifdef _CRTDBG_MAP_ALLOC #define calloc(c, s) _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _expand(p, s) _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define free(p) _free_dbg(p, _NORMAL_BLOCK) #define malloc(s) _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _msize(p) _msize_dbg(p, _NORMAL_BLOCK) #define realloc(p, s) _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _recalloc(p, c, s) _recalloc_dbg(p, c, s, _NORMAL_BLOCK, __FILE__, __LINE__) #define _aligned_free(p) _aligned_free_dbg(p) #define _aligned_malloc(s, a) _aligned_malloc_dbg(s, a, __FILE__, __LINE__) #define _aligned_msize(p, a, o) _aligned_msize_dbg(p, a, o) #define _aligned_offset_malloc(s, a, o) _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__) #define _aligned_offset_realloc(p, s, a, o) _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__) #define _aligned_offset_recalloc(p, c, s, a, o) _aligned_offset_recalloc_dbg(p, c, s, a, o, __FILE__, __LINE__) #define _aligned_realloc(p, s, a) _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__) #define _aligned_recalloc(p, c, s, a) _aligned_recalloc_dbg(p, c, s, a, __FILE__, __LINE__) #define _freea(p) _freea_dbg(p, _NORMAL_BLOCK)#define _malloca(s) _malloca_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) 看起来眼花缭乱。但精简一下就是： 1234567891011121314151617#ifndef _DEBUG // 如果不是调试版本 // 所有 _dbg 函数直接映射到普通版本 #define _malloc_dbg(s, t, f, l) malloc(s) // ... 其他类似#else // 如果是调试版本 #ifdef _CRTDBG_MAP_ALLOC // 如果启用了完整的内存调试映射 // 这里重定向了所有标准内存函数到调试版本 #define malloc(s) _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__) #define free(p) _free_dbg(p, _NORMAL_BLOCK) // ... 其他类似 #endif // _CRTDBG_MAP_ALLOC#endif // _DEBUG 如果忽略调试，我们就单纯看malloc(s)这个函数。终于见到了熟悉的malloc。malloc的函数特别纯粹： 12345void* malloc(size_t size) &#123; // 1. 向操作系统请求一块内存 // 2. 管理这块内存（记录大小等信息） // 3. 返回给用户可用的指针&#125; 这里再仔细看看malloc的行为： 写一个简单的使用malloc的： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1. 分配一个整数的大小 int* ptr = (int*)malloc(sizeof(int)); if (ptr == NULL) &#123; printf(&quot;内存分配失败！ &quot;); return 1; &#125; // 2. 使用分配的内存 *ptr = 42; printf(&quot;分配的整数: %d &quot;, *ptr); // 3. 释放内存 free(ptr); ptr = NULL; // 避免悬垂指针 return 0;&#125; 汇编为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133# License: MSVC Proprietary# The use of this compiler is only permitted for internal evaluation purposes and is otherwise governed by the MSVC License Agreement.# See https://visualstudio.microsoft.com/license-terms/vs2022-ga-community/; ==============================================; 数据段：存储字符串常量; ==============================================; 字符串1：中文编码的&quot;内存分配失败！&quot; + 换行符 + null终止符$SG6371 DB 0e5H, 086H, 085H, 0e5H, 0adH, 098H, 0e5H, 088H, 086H, 0e9H DB 085H, 08dH, 0e5H, 0a4H, 0b1H, 0e8H, 0b4H, 0a5H, 0efH, 0bcH, 081H DB 0aH, 00H ; 对应 UTF-8 编码的&quot;内存分配失败！ \\0&quot; ; 这是调试版本的中文错误提示 ORG $+1 ; 地址对齐指令，确保下一条指令在正确地址; 字符串2：中文&quot;分配的整数: &quot; + 格式字符串 &quot;%d&quot; + 换行符 + null$SG6372 DB 0e5H, 088H, 086H, 0e9H, 085H, 08dH, 0e7H, 09aH, 084H, 0e6H DB 095H, 0b4H, 0e6H, 095H, 0b0H, &#x27;: %d&#x27;, 0aH, 00H ; 对应 UTF-8 编码的&quot;分配的整数: %d \\0&quot;; ==============================================; 全局变量：stdio 选项存储; ==============================================unsigned __int64 `__local_stdio_printf_options&#x27;::`2&#x27;::_OptionsStorage DQ 01H DUP (?); 这是一个全局变量，用于存储 printf 的选项（如缓冲区大小等）; DQ 01H DUP (?) 表示分配一个 8 字节（quad word）未初始化的空间; ==============================================; 栈帧布局定义; ==============================================ptr$ = 32 ; 局部变量 ptr 在栈上的偏移量是 32 字节; ==============================================; main 函数开始; ==============================================main PROC$LN4: ; 标签：代码块开始 ; 函数序言（prologue）：设置栈帧 sub rsp, 56 ; 00000038H ; 在栈上分配 56 字节空间（局部变量 + 对齐） ; 为什么要 56 字节？ ; - 32字节：预留空间（可能用于参数传递） ; - 8字节：ptr 变量 ; - 16字节：对齐到16字节边界（Windows x64 调用约定要求） ; ====================================== ; 步骤1：调用 malloc 分配内存 ; ====================================== mov ecx, 4 ; 参数1：size = 4 字节 ; Windows x64 调用约定：前4个参数在 RCX, RDX, R8, R9 ; 这里 malloc 只需要一个参数，所以放在 RCX 的低32位 ECX call QWORD PTR __imp_malloc ; 调用 malloc ; __imp_malloc 是导入函数地址（从 DLL 导入） ; QWORD PTR 表示这是一个64位指针 ; ====================================== ; 步骤2：保存返回的指针 ; ====================================== mov QWORD PTR ptr$[rsp], rax ; 将返回值保存到栈上的 ptr 变量 ; malloc 的返回值（分配的内存地址）在 RAX 中 ; ptr$[rsp] = rsp + 32（上面定义的偏移量） ; ====================================== ; 步骤3：检查分配是否成功 ; ====================================== cmp QWORD PTR ptr$[rsp], 0 ; 比较 ptr 是否为 NULL jne SHORT $LN2@main ; 如果不为 NULL，跳转到成功处理 ; jne = Jump if Not Equal（如果不等于0） ; ====================================== ; 分支：分配失败的处理 ; ====================================== lea rcx, OFFSET FLAT:$SG6371 ; 加载字符串地址到 RCX ; LEA = Load Effective Address（加载有效地址） ; OFFSET FLAT: 表示相对于数据段基址的偏移 ; 准备调用 printf 的第一个参数 call printf ; 调用 printf 输出错误信息 ; 这里没有 __imp_ 前缀，可能是静态链接或内联 mov eax, 1 ; 设置返回值 1（表示错误） jmp SHORT $LN1@main ; 跳转到函数结尾 ; ======================================; 标签：分配成功的处理; ======================================$LN2@main: ; ====================================== ; 步骤4：使用分配的内存（写入值） ; ====================================== mov rax, QWORD PTR ptr$[rsp] ; 加载 ptr 到 RAX mov DWORD PTR [rax], 42 ; 将 42 写入指针指向的位置 ; DWORD PTR [rax] 表示将 RAX 作为指针，写入32位值 ; 42 的十六进制是 2AH ; ====================================== ; 步骤5：读取并打印这个值 ; ====================================== mov rax, QWORD PTR ptr$[rsp] ; 再次加载 ptr（可能被优化掉，但这里没优化） mov edx, DWORD PTR [rax] ; 读取刚写入的值到 EDX ; EDX 是 printf 的第二个参数寄存器 lea rcx, OFFSET FLAT:$SG6372 ; 加载格式字符串到 RCX（第一个参数） call printf ; 调用 printf ; ====================================== ; 步骤6：释放内存 ; ====================================== mov rcx, QWORD PTR ptr$[rsp] ; 将 ptr 加载到 RCX（free 的参数） call QWORD PTR __imp_free ; 调用 free ; ====================================== ; 步骤7：置空指针（避免悬垂指针） ; ====================================== mov QWORD PTR ptr$[rsp], 0 ; 将 ptr 设为 NULL ; ====================================== ; 步骤8：设置返回值 0（成功） ; ====================================== xor eax, eax ; EAX = 0（返回 0） ; XOR 自己是最快的清零方式 ; ======================================; 标签：函数返回点（两个分支的汇合处）; ======================================$LN1@main: ; 函数结尾（epilogue）：恢复栈帧 add rsp, 56 ; 释放栈空间 ret 0 ; 返回main ENDP new中的构造函数先考虑可能出现的情况。会变化的有以下这些：new的是内置类型对象还是自定义类型对象。如果是自定义类型对象，使用new A；还是new A（）有零初始化的问题。以及有无用户显式定义了构造函数。 无显式初始化写一个测试代码看一看，是否有构造函数的影响且初始化采用new X的不带各种括号的形式： 123456789101112131415161718192021222324252627282930struct A &#123; int x; A() &#123; std::cout &lt;&lt; &quot;A constructed&quot; &lt;&lt; std::endl; &#125; // 有用户定义构造函数&#125;;struct B &#123; int x; // 没有构造函数&#125;;struct C &#123; int x; C() = default; // 显式默认构造函数&#125;;int main() &#123; std::cout &lt;&lt; &quot;Testing A (has ctor):&quot; &lt;&lt; std::endl; A* a = new A; // 会输出 std::cout &lt;&lt; &quot; Testing B (no ctor):&quot; &lt;&lt; std::endl; B* b = new B; // 不会输出 std::cout &lt;&lt; &quot; Testing C (defaulted ctor):&quot; &lt;&lt; std::endl; C* c = new C; // 不会输出 delete a; delete b; delete c; return 0;&#125; 运行结果： 123456Testing A (has ctor):A constructedTesting B (no ctor):Testing C (defaulted ctor): 一个一个来看： 第一部分：A::A() 构造函数分析12345678910111213141516171819A::A(void) PROC$LN3: mov QWORD PTR [rsp+8], rcx ; 保存 this 指针 sub rsp, 40 ; 分配栈空间 ; 输出 &quot;A constructed&quot; lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;A constructed&quot; mov rcx, QWORD PTR __imp_std::cout ; RCX = std::cout call std::operator&lt;&lt; ; 调用 operator&lt;&lt; ; 输出 std::endl lea rdx, OFFSET FLAT:std::endl ; RDX = endl 函数地址 mov rcx, rax ; RCX = cout（上一条的返回值） call QWORD PTR __imp_std::basic_ostream::operator&lt;&lt; mov rax, QWORD PTR this$[rsp] ; 返回 this 指针 add rsp, 40 ; 恢复栈 ret 0A::A(void) ENDP A 的构造函数是真实存在的函数，包含实际的代码（输出语句）。 第二部分：main 函数分析创建对象 A（有构造函数）1234567891011121314151617181920212223242526272829; 输出 &quot;Testing A (has ctor):&quot;lea rdx, OFFSET FLAT:$SG35287 ; RDX = 字符串地址mov rcx, QWORD PTR __imp_std::cout ; RCX = coutcall std::operator&lt;&lt;; ... 输出 endl; 分配 A 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T1[rsp], rax ; 保存返回指针cmp QWORD PTR $T1[rsp], 0 ; 检查分配是否成功je SHORT $LN3@main ; 如果失败，跳转; 关键：调用构造函数！mov rcx, QWORD PTR $T1[rsp] ; RCX = this 指针call A::A(void) ; 调用构造函数 A::A()mov QWORD PTR tv80[rsp], rax ; 保存结果jmp SHORT $LN4@main; 分配失败处理$LN3@main:mov QWORD PTR tv80[rsp], 0 ; 存储 nullptr; 保存到变量 a$LN4@main:mov rax, QWORD PTR tv80[rsp]mov QWORD PTR a$[rsp], rax ; 保存到 a 对于类 A，有明显的 call A::A(void) 指令，这就是构造函数的调用。 创建对象 B（没有构造函数）123456789; 输出 &quot;Testing B (no ctor):&quot;; ... 类似前面的输出代码; 分配 B 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T3[rsp], rax ; 保存返回指针mov rax, QWORD PTR $T3[rsp] ; 加载指针mov QWORD PTR b$[rsp], rax ; 直接保存到 b 关键差异： 没有空指针检查分配后直接保存指针，没有 cmp 和 je 指令 没有构造函数调用 没有 call B::B(void) 之类的指令 分配后直接使用，指针直接存入变量 创建对象 C（默认构造函数）123456789; 输出 &quot;Testing C (defaulted ctor):&quot;; ... 输出代码; 分配 C 对象mov ecx, 4 ; 分配 4 字节call void * operator new ; 调用 operator newmov QWORD PTR $T4[rsp], rax ; 保存返回指针mov rax, QWORD PTR $T4[rsp] ; 加载指针mov QWORD PTR c$[rsp], rax ; 直接保存到 c 与 B 完全一样,C() = default; 和没有构造函数在汇编层面没有区别。 值初始化刚刚的实验的new的方式是不带任何括号的。下面看看new X()这种带括号的值初始化： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;struct A &#123; int x; A() &#123; std::cout &lt;&lt; &quot;A constructed&quot; &lt;&lt; std::endl; &#125;&#125;;struct B &#123; int x; // 没有构造函数&#125;;struct C &#123; int x; C() = default; // 显式默认&#125;;int main() &#123; std::cout &lt;&lt; &quot;Testing A (has ctor) with parentheses:&quot; &lt;&lt; std::endl; A* a = new A(); // 值初始化 - 会调用构造函数 std::cout &lt;&lt; &quot; Testing B (no ctor) with parentheses:&quot; &lt;&lt; std::endl; B* b = new B(); // 值初始化 - 会进行零初始化 std::cout &lt;&lt; &quot; Testing C (defaulted ctor) with parentheses:&quot; &lt;&lt; std::endl; C* c = new C(); // 值初始化 - 会进行零初始化 // 为了演示差异，输出值 std::cout &lt;&lt; &quot; Checking values:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a-&gt;x = &quot; &lt;&lt; a-&gt;x &lt;&lt; std::endl; // 构造函数可能设定了值 std::cout &lt;&lt; &quot;b-&gt;x = &quot; &lt;&lt; b-&gt;x &lt;&lt; std::endl; // 应该为0（零初始化） std::cout &lt;&lt; &quot;c-&gt;x = &quot; &lt;&lt; c-&gt;x &lt;&lt; std::endl; // 应该为0（零初始化） delete a; delete b; delete c; return 0;&#125; 测试结果： 1234567891011Testing A (has ctor) with parentheses:A constructedTesting B (no ctor) with parentheses:Testing C (defaulted ctor) with parentheses:Checking values:a-&gt;x = -842150451b-&gt;x = 0c-&gt;x = 0 情况1：new A() - 有用户定义构造函数asm 1234567891011121314151617181920212223242526; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T3[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T3[rsp], 0je SHORT $LN3@main ; 如果失败，跳转; 调用构造函数mov rcx, QWORD PTR $T3[rsp] ; RCX = this 指针call A::A(void) ; 调用构造函数mov QWORD PTR tv80[rsp], rax ; 保存结果jmp SHORT $LN4@main; 分配失败处理$LN3@main:mov QWORD PTR tv80[rsp], 0 ; 存储 nullptr; 保存到变量 a$LN4@main:mov rax, QWORD PTR tv80[rsp]mov QWORD PTR $T4[rsp], raxmov rax, QWORD PTR $T4[rsp]mov QWORD PTR a$[rsp], rax ; 保存到 a 关键点：对于有构造函数的类 A，new A() 的行为是： 分配内存 检查分配成功 调用构造函数 保存指针 特别注意：没有清零操作。因为类 A 有用户定义的构造函数，编译器依赖构造函数来初始化对象。 情况2：new B() - 没有构造函数123456789101112131415161718192021222324252627; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T1[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T1[rsp], 0je SHORT $LN5@main ; 如果失败，跳转; 清零内存mov rdi, QWORD PTR $T1[rsp] ; RDI = 目标地址xor eax, eax ; EAX = 0mov ecx, 4 ; ECX = 4字节rep stosb ; 清零4字节内存mov rax, QWORD PTR $T1[rsp]mov QWORD PTR tv91[rsp], rax ; 保存结果jmp SHORT $LN6@main; 分配失败处理$LN5@main:mov QWORD PTR tv91[rsp], 0 ; 存储 nullptr; 保存到变量 b$LN6@main:mov rax, QWORD PTR tv91[rsp]mov QWORD PTR b$[rsp], rax ; 保存到 b 关键点：对于没有构造函数的类 B，new B() 的行为是： 分配内存 检查分配成功 清零内存（rep stosb） 保存指针 这就是值初始化的核心：new B() 触发了零初始化，即使类 B 没有构造函数。 情况3：new C() - 默认构造函数asm 123456789101112131415161718192021222324252627; 分配内存mov ecx, 4 ; 分配4字节call void * operator new ; 调用 operator newmov QWORD PTR $T2[rsp], rax ; 保存指针; 检查分配是否成功cmp QWORD PTR $T2[rsp], 0je SHORT $LN7@main ; 如果失败，跳转; 清零内存（与B完全相同）mov rdi, QWORD PTR $T2[rsp] ; RDI = 目标地址xor eax, eax ; EAX = 0mov ecx, 4 ; ECX = 4字节rep stosb ; 清零4字节内存mov rax, QWORD PTR $T2[rsp]mov QWORD PTR tv139[rsp], rax ; 保存结果jmp SHORT $LN8@main; 分配失败处理$LN7@main:mov QWORD PTR tv139[rsp], 0 ; 存储 nullptr; 保存到变量 c$LN8@main:mov rax, QWORD PTR tv139[rsp]mov QWORD PTR c$[rsp], rax ; 保存到 c 类 C 的代码与类 B 完全相同。C() = default; 和没有构造函数在 new C() 的情况下行为完全一致。 混淆的点：列表初始化和成员初始化列表说实话，我有点搞混这两个概念了。重新梳理一遍： 写一个测试代码看看： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;class Demo &#123; std::string data; int id; public: // 构造函数1：有成员初始化列表 Demo() : data(&quot;default&quot;), id(0) &#123; std::cout &lt;&lt; &quot;Constructor 1: member init list &quot;; &#125; // 构造函数2：没有成员初始化列表 Demo(int i) &#123; data = &quot;assigned&quot;; id = i; std::cout &lt;&lt; &quot;Constructor 2: assignment in body &quot;; &#125; // 构造函数3：混合 Demo(const std::string&amp; s) : data(s) &#123; id = 42; // 内置类型，区别不大 std::cout &lt;&lt; &quot;Constructor 3: mixed &quot;; &#125;&#125;;int main() &#123; // 外部语法决定调用哪个构造函数 Demo* d1 = new Demo(); // 调用Demo() - 有初始化列表 Demo* d2 = new Demo&#123;&#125;; // 调用Demo() - 有初始化列表 Demo* d3 = new Demo(100); // 调用Demo(int) - 没有初始化列表 Demo* d4 = new Demo&#123;100&#125;; // 调用Demo(int) - 没有初始化列表 Demo* d5 = new Demo&#123;&quot;test&quot;&#125;; // 调用Demo(string) - 有部分初始化列表 delete d1; delete d2; delete d3; delete d4; delete d5; return 0;&#125; 运行结果如下： 1234567891011121314Demo* d1 = new Demo()Constructor 1: member init list========================Demo* d2 = new Demo&#123;&#125;Constructor 1: member init list========================Demo* d3 = new Demo(100);Constructor 2: assignment in body========================Demo* d4 = new Demo&#123; 100 &#125;Constructor 2: assignment in body========================Demo* d5 = new Demo&#123;&quot;test&quot; &#125;Constructor 3: mixed 详细分析：三个构造函数的汇编对比构造函数1分析：Demo::Demo(void) - 有成员初始化列表1234567891011121314151617181920212223242526Demo::Demo(void) PROC$LN4: mov QWORD PTR [rsp+8], rcx ; 保存 this 指针 sub rsp, 40 ; 分配栈空间 ; === 成员初始化列表开始 === mov rax, QWORD PTR this$[rsp] ; RAX = this lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;default&quot; 字符串地址 mov rcx, rax ; RCX = this（data成员的地址） call std::basic_string::basic_string(char const*) ; 直接构造data！ ; === 成员初始化列表结束 === ; 初始化 id mov rax, QWORD PTR this$[rsp] ; RAX = this mov DWORD PTR [rax+32], 0 ; this-&gt;id = 0 ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; ; RDX = 输出字符串 mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(void) ENDP 关键点：data 成员通过直接调用构造函数初始化，这是最高效的方式。 构造函数2分析：Demo::Demo(int) - 没有成员初始化列表12345678910111213141516171819202122232425262728293031323334Demo::Demo(int) PROC$LN4: mov DWORD PTR [rsp+16], edx ; 保存参数 i mov QWORD PTR [rsp+8], rcx ; 保存 this sub rsp, 40 ; === 没有成员初始化列表！data默认构造 === mov rax, QWORD PTR this$[rsp] ; RAX = this mov rcx, rax ; RCX = this（data地址） call std::basic_string::basic_string(void) ; 默认构造函数！ ; data现在是一个空字符串 ; === 构造函数体开始：赋值操作 === mov rax, QWORD PTR this$[rsp] ; RAX = this lea rdx, OFFSET FLAT:`string&#x27; ; RDX = &quot;assigned&quot; mov rcx, rax ; RCX = &amp;data call std::basic_string::operator= ; 赋值操作！ ; 这里调用了 operator=，不是构造函数 ; 初始化 id mov rax, QWORD PTR this$[rsp] mov ecx, DWORD PTR i$[rsp] ; ECX = 参数 i mov DWORD PTR [rax+32], ecx ; this-&gt;id = i ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(int) ENDP 关键差异： 多一次函数调用：先调用默认构造函数，再调用 operator= 效率更低：std::string 被构造了两次（默认构造 + 赋值） 构造函数3分析：Demo::Demo(const string&amp;) - 混合方式1234567891011121314151617181920212223242526Demo::Demo(std::basic_string&lt;char,...&gt; const &amp;) PROC$LN4: mov QWORD PTR [rsp+16], rdx ; 保存参数 s 的引用 mov QWORD PTR [rsp+8], rcx ; 保存 this sub rsp, 40 ; === 成员初始化列表：data使用拷贝构造 === mov rax, QWORD PTR this$[rsp] ; RAX = this mov rdx, QWORD PTR s$[rsp] ; RDX = 参数 s（源字符串） mov rcx, rax ; RCX = this（目标地址） call std::basic_string::basic_string(string const&amp;) ; 拷贝构造！ ; === 构造函数体：初始化 id === mov rax, QWORD PTR this$[rsp] mov DWORD PTR [rax+32], 42 ; this-&gt;id = 42 ; 输出信息 lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::cout call std::operator&lt;&lt; ; 返回 this mov rax, QWORD PTR this$[rsp] add rsp, 40 ret 0Demo::Demo(std::basic_string&lt;char,...&gt; const &amp;) ENDP 关键点：data 通过拷贝构造函数直接初始化，这是高效的。 main 函数分析：五种创建方式1. d1 = new Demo() - 默认构造函数123456789mov ecx, 40 ; sizeof(Demo) = 40 (32+8，考虑对齐)call void * operator newmov QWORD PTR $T2[rsp], raxcmp QWORD PTR $T2[rsp], 0je SHORT $LN3@main ; 检查分配失败mov rcx, QWORD PTR $T2[rsp]call Demo::Demo(void) ; 调用构造函数1 2. d2 = new Demo&#123;&#125; - 列表初始化（空列表）1234567; 与 d1 完全相同！mov ecx, 40call void * operator newcmp rax, 0je ...mov rcx, raxcall Demo::Demo(void) ; 同样调用构造函数1 3. d3 = new Demo(100) - 直接初始化12345mov ecx, 40call void * operator newmov edx, 100 ; 参数：i = 100mov rcx, raxcall Demo::Demo(int) ; 调用构造函数2 4. d4 = new Demo&#123;100&#125; - 列表初始化123456; 与 d3 完全相同！mov ecx, 40call void * operator newmov edx, 100 ; 参数：i = 100mov rcx, raxcall Demo::Demo(int) ; 同样调用构造函数2 5. d5 = new Demo&#123;&quot;test&quot;&#125; - 列表初始化（字符串）这是最复杂的情况： 123456789101112131415161718192021222324252627; 1. 分配内存mov ecx, 40call void * operator newmov QWORD PTR $T6[rsp], rax; 2. 创建临时字符串 &quot;test&quot;lea rdx, OFFSET FLAT:$SG35705 ; RDX = &quot;test&quot;lea rcx, QWORD PTR $T17[rsp] ; RCX = 临时字符串位置call std::basic_string::basic_string(char const*) ; 构造临时字符串; 3. 标记需要清理临时字符串mov eax, DWORD PTR $T1[rsp]or eax, 1mov DWORD PTR $T1[rsp], eax; 4. 调用构造函数3lea rdx, QWORD PTR $T17[rsp] ; RDX = 临时字符串的引用mov rcx, QWORD PTR $T6[rsp] ; RCX = 新分配的Demo对象call Demo::Demo(string const&amp;) ; 调用构造函数3; 5. 清理临时字符串mov eax, DWORD PTR $T1[rsp]and eax, 1test eax, eaxje SHORT $LN30@mainlea rcx, QWORD PTR $T17[rsp]call std::basic_string::~basic_string ; 析构临时字符串 对比 new Demo() 和 new Demo&#123;&#125; 的汇编完全一样在这个例子中，两者都调用 Demo::Demo(void)，生成相同的代码。 new Demo(100) 和 new Demo&#123;100&#125; 的汇编完全一样两者都调用 Demo::Demo(int)，生成相同的代码。 构造函数2的效率问题清晰可见对比构造函数1和2： 构造函数1：1次字符串构造函数调用 构造函数2：2次函数调用（默认构造 + operator=） 临时对象的处理new Demo&#123;&quot;test&quot;&#125; 需要创建临时字符串，然后通过引用传递给构造函数，最后清理临时对象。 根据文章内容，您对C++中new和delete的探索非常深入！您已经发现了不同初始化方式的细微差别以及构造函数实现方式对性能的影响。基于您的分析，我重新整理了总结部分，并优化了对比表格，使其更清晰准确。 总结 通过实验分析，可以得出以下关键结论： new的本质：new表达式分为两步：首先调用operator new分配内存，然后根据需要调用构造函数。对于没有用户定义构造函数的类型，编译器会优化掉构造函数调用。 初始化差异： new T（默认初始化）：对有构造函数的类型调用构造函数；对无构造函数的类型不初始化。 new T()（值初始化）：对有构造函数的类型调用构造函数并可能进行零初始化；对无构造函数的类型进行零初始化。 new T&#123;&#125;（列表初始化）：行为与直接初始化类似，但禁止窄化转换。 构造函数效率：使用成员初始化列表直接在内存中构造对象，比在构造函数体内赋值更高效，避免了先默认构造再赋值的开销。 内存分配：operator new最终会调用malloc，在调试版本中会添加额外的调试信息用于内存泄漏检测。 错误处理：默认情况下new在分配失败时抛出std::bad_alloc异常，但可以通过new(std::nothrow)使用不抛出版本。 分类 语法 零初始化 构造函数调用 示例 内置类型 默认初始化 new int ❌ 否 无 int* p = new int; // 随机值 值初始化 new int() ✅ 是 无 int* p = new int(); // 0 列表初始化 new int&#123;&#125; ✅ 是 无 int* p = new int&#123;&#125;; // 0 平凡类型（无构造函数） 默认初始化 new POD ❌ 否 无 POD* p = new POD; // 成员随机值 值初始化 new POD() ✅ 是 无 POD* p = new POD(); // 成员零初始化 列表初始化 new POD&#123;&#125; ✅ 是 无 POD* p = new POD&#123;&#125;; // 成员零初始化 非平凡类型（有构造函数） 默认初始化 new Class ❌ 否 ✅ 调用默认构造函数 Class* c = new Class; // 调用Class() 值初始化 new Class() ⚠️ 可能¹ ✅ 调用默认构造函数 Class* c = new Class(); // 调用Class() 列表初始化 new Class&#123;&#125; ❌ 否 ✅ 调用默认构造函数 Class* c = new Class&#123;&#125;; // 调用Class() 构造函数差异 成员初始化列表 : member(value) ❌ 否 直接构造成员 最高效，避免额外赋值 构造函数体内赋值 member = value ❌ 否 先默认构造再赋值 效率较低，多一次赋值操作 说明： 值初始化对于有构造函数的类：根据编译器实现，new Class()可能在调用构造函数前先进行零初始化。MSVC在调试版本中会执行零初始化，但这不是C++标准要求的。 性能建议：对于类成员变量，优先使用成员初始化列表，避免在构造函数体内赋值，特别是对于std::string、std::vector等非平凡类型。 内存管理：new/delete必须配对使用，new[]/delete[]必须配对使用，混用会导致未定义行为。 通过对C++中new表达式和构造函数实现方式的深入分析，可以清楚地认识到：外部初始化语法与类内部构造函数的实现方式是两个独立且正交的概念。 当我们在代码中使用new T、new T()或new T&#123;&#125;等不同语法创建对象时，这些外部语法只负责选择调用哪个构造函数以及决定是否进行零初始化，它们无法改变类内部已经定义好的构造方式。是否在构造过程中先调用成员变量的默认构造函数，完全取决于类设计者在编写构造函数时是选择使用成员初始化列表还是在构造函数体内进行赋值操作。 使用成员初始化列表的构造函数会直接调用成员变量带参数的构造函数，一步到位地完成初始化，避免了不必要的默认构造步骤。而将初始化操作放在构造函数体内的方式，则会强制编译器先调用成员变量的默认构造函数创建一个临时对象，然后再通过赋值运算符将值赋给该对象，这种额外的开销与外部使用何种new语法毫无关系。 无论外部采用new MyClass、new MyClass()还是new MyClass&#123;&#125;的语法，只要内部构造函数使用成员初始化列表，就不会调用成员变量的默认构造函数；反之，如果内部构造函数在函数体内赋值，就一定会先调用默认构造函数。这一构造过程的差异是类设计阶段决定的，与对象创建时使用的外部语法无关。 零初始化的发生确实与外部语法密切相关，而与类内部构造函数的实现方式相对独立。当使用new T()进行值初始化时，对于没有用户定义构造函数的平凡类型，编译器会在分配内存后执行零初始化操作，将所有成员设置为零值。这种零初始化发生在构造函数调用之前，是内存分配后立即执行的底层操作。 有趣的是，对于有用户定义构造函数的类，即使使用new T()语法，C++标准也不强制要求进行零初始化。不过在实际编译中，特别是MSVC的调试版本，编译器可能会在调用用户定义的构造函数之前插入零初始化的代码，但这属于编译器的实现细节而非语言标准的要求。 相比之下，成员初始化列表与构造函数体内赋值的区别在于对象构造的路径不同，而零初始化则是更前置的内存准备阶段。无论类内部采用哪种构造方式，只要该类没有用户定义的构造函数且使用值初始化语法new T()，都会触发零初始化。但如果类有用户定义的构造函数，零初始化就可能被跳过，直接进入构造函数执行阶段。 因此，零初始化主要受两个因素影响：一是类是否有用户定义的构造函数，二是外部是否使用值初始化语法。对于希望确保成员初始化为零值的场景，程序员需要明确使用new T()或new T&#123;&#125;语法，并且了解这仅对无用户定义构造函数的类型保证有效。对于有构造函数的类，零初始化的责任应完全由构造函数承担，通过成员初始化列表明确设置每个成员的初始值是比较安全的做法。 {}初始化（统一初始化或列表初始化）在C++11中引入，旨在提供一种统一的初始化语法，但它与()初始化存在多方面的重要区别。窄化转换的禁止只是其中最明显的一点，但还有更本质的行为差异。 当使用{}初始化时，编译器会优先考虑std::initializer_list构造函数。这意味着如果类定义了接受std::initializer_list参数的构造函数，{}初始化将调用这个构造函数，而()初始化则会调用其他匹配的构造函数。这种优先级差异可能导致完全不同的对象构造路径。 对于聚合类型（没有用户定义构造函数、没有私有或受保护的非静态数据成员、没有基类、没有虚函数的类），{}初始化允许直接初始化各个成员，这是一种简洁而高效的初始化方式。而()初始化对聚合类型的行为则不同，它可能需要进行转换或者根本不可用。 在值的初始化方面，new T{}会进行值初始化，对于内置类型和没有构造函数的类，这意味着零初始化。虽然new T()也有类似行为，但{}提供了更一致的语法，避免了与函数声明混淆的经典问题。 此外，{}初始化还解决了C++中最令人烦恼的解析问题。在复杂表达式中，{}能够明确区分对象初始化和函数声明，而()则可能产生歧义。 啊啊啊啊，这时候又要问，这位std::initializer_list又是谁？ 在C++中，std::initializer_list和成员初始化列表虽然名称相似，但本质上是两个截然不同的概念，理解它们的区别对于掌握现代C++初始化语义至关重要。 std::initializer_list是C++11标准库中定义的一种特殊模板类型，它作为构造函数参数使用，专门用于接收花括号初始化器中的值序列。当类定义了接受std::initializer_list参数的构造函数时，使用花括号&#123;&#125;进行初始化会优先匹配这个构造函数，这使得对象可以从一组值直接初始化。这种设计使得像std::vector&lt;int&gt; v&#123;1, 2, 3&#125;这样的语法成为可能，其中花括号内的值被整体传递给std::initializer_list构造函数。 而成员初始化列表是构造函数定义本身的组成部分，它位于构造函数参数列表之后、函数体之前，采用冒号引导的语法形式。成员初始化列表的用途是在进入构造函数体之前直接初始化类的各个成员变量，避免了先默认构造再赋值的性能开销。这是一种优化手段，确保成员变量从一开始就被正确初始化。 这两种机制虽然都与初始化相关，但作用层面完全不同。std::initializer_list关注的是如何将外部提供的一组值传递给对象，属于接口设计的一部分；而成员初始化列表关注的是对象内部成员变量的构造方式，属于实现优化的范畴。前者影响的是对象创建时用户能使用的语法形式，后者影响的是对象构造过程中的性能表现。 在实际编程中，一个类的构造函数完全可以同时使用这两种机制：它既可以接受std::initializer_list参数来支持列表初始化，同时在实现内部使用成员初始化列表来高效地初始化成员变量。这种组合使得C++的初始化机制既灵活又高效，既提供了友好的用户接口，又保证了良好的运行时性能。 整理到这里，我终于理解了为什么有的人会专门写一本书来讲C++的初始化了，太可怕了这也。 下一篇再整理free和delete吧，这也太可怕了。 太可怕了。","tags":["C++"]},{"title":"malloc失败假装没事谁信（malloc内存分配相关总结整理）","path":"/2026/01/24/我真的很讨厌malloc失败假装没事/","content":"今天首先很讨厌自己学了也有一阵C++了但是感觉如果让我说的话还是支支吾吾不知从何说起。感觉就是所有关键词知识点都在抢占大脑输出通道，没有逻辑章法。 第二个讨厌的就是malloc失败了假装自己没事，原因就是只返回一个void*类型，还得我们自己做一次检查。就像买了房子只给了钥匙，然后发现这钥匙是NULL用不了。 先倒出来脑子里有的，再一点点整理。 new/delete和malloc/free都可以进行内存分配和释放，区别在于new/delete是C++里的一个运算符，而malloc则是C库里的一个函数。这里先点一下题，这个性质也就决定了，new既然作为内置实现的一个运算符，任何new过程中出现的失败都会使得new这个操作失败并抛出异常，默认会抛出 std::bad_alloc 异常。而malloc作为函数，它只会返回一个void*指针，不会抛出异常操作。至于这块地址能不能用，用户还得自己检查一遍。 malloc和free：malloc和free是C语言内存管理的基石。我在本科的时候写C最讨厌的就是这两位，因为抄起来相对较长，malloc这个名字看起来又不是什么正经英语。malloc，全名：memory allocation（这下看起来正经了）和free来自C语言，C++也就继承了这两个函数，这两位隶属于C标准库。一会再整理new和delete，那两位是靠malloc来实现的。 为什么不叫memaloc？之前一直以为是ma+loc，今天定睛一看嘿原来是m+alloc 当调用malloc(size_t size)时，操作系统和运行时库会进行一系列复杂的操作。具体如下：malloc首先会从进程的堆中寻找足够大的连续空闲内存块。如果找到了合适的，它就会把这个内存块标记为已分配，然后，返回指向内存块起始地址的指针。 但是，作为C++程序员，以及那群面试官中老登们，成功固然令人欣喜，失败则意味着能有更多考察我的知识点（）。malloc什么时候会失败？ 第一个原因很简单，就是内存不足。进程请求的内存总量，超过了系统能提供的物理内存和虚拟内存之和时，分配就会失效。 第二个也很好想到，就是连续的内存不够，内存太碎片了，这时候也会失效。 第三个是关于地址空间的。进程的虚拟地址空间如果全占完了，即使物理内存还剩很多也没用。（32位系统进程是4GB的虚拟地址空间）。 第四个是内存分配器损坏，由于程序错误比如缓冲区溢出，重复释放等（这个有疑问）。 当空间不够时，malloc会返回NULL来表示分配失败。我们必须检查这个返回值。对空指针解引用是未定义行为（段错误）。 与malloc相对应的就是free。free(void* ptr)负责释放之前分配的内存。由内存分配器将被释放的内存块标记为空闲。 free也会失败。首先free不返回任何值，这里的失败主要指的是程序的行为出错。最经典的就是重复释放，对一块内存多次调用free也会导致未定义行为。内存分配器会认为这块内存已经被释放，再次释放时可能破坏内存管理数据结构。 什么是破坏内存管理的数据结构： 许多分配器在分配的内存块前面存储元数据（大小、状态、链接指针等）。 当程序第一次调用free释放内存时，内存分配器会在这块内存区域的头部或尾部找到它自己之前记录的管理数据。这些数据至少包括这块内存的大小，以及一个表示该内存是否已被分配的状态标志。分配器会将这个状态标志改为“空闲”。之后，分配器通常会把这整块内存（包括用户数据区域和管理数据区域）视为一个空闲块，并将其添加到一个用于跟踪所有空闲内存的数据结构中。这个数据结构常见的形式是链表或树。例如，如果是链表，分配器会在这个空闲块的管理数据区写入指向链表中下一个空闲块和上一个空闲块的指针。 这里会出现几种破坏情况： 第一种情况是，在两次free之间，没有其他代码改动过这块内存。此时管理数据中的状态可能已经是“空闲”。当分配器试图再次将其标记为“空闲”时，这个操作本身可能无意义，但也可能破坏其他用于内部记账的标志。更重要的是，分配器会再次执行“将空闲块插入数据结构”的操作。这会导致同一个内存块在空闲链表或树中出现两次。当后续进行内存分配时，分配器可能会把这个块分配出去，但它在链表中还有一个副本。之后对这个副本的任何操作，比如尝试从链表中移除它，都会访问到可能已被用户数据覆盖的内存区域（现在它是已分配状态），从而导致读取或写入错误的内存地址。 第二种更常见且更复杂的情况是，在两次free之间，这块内存可能已经被重新分配出去，用于其他用途。新的数据可能已经写入了原来的用户区域，甚至可能覆盖了部分原始的管理数据（如果新的使用方式允许写入足够多的数据）。当第二次free执行时，分配器读取的管理数据是无效的或被篡改过的。例如，它读到一个被用户数据篡改过的“内存块大小”值。分配器会根据这个错误的大小值去计算哪里是这块内存的尾部，以及哪些是相邻的内存块，进而去修改那些它认为是“相邻块”头部的管理数据。这直接破坏了其他正在使用的内存中的数据，而这些数据可能属于程序的变量、对象或其他关键结构。 第二种释放失败的原因我称之为多管闲事。比如试图释放栈上的变量、全局变量或通过 new 分配的内存。 第三种就是完全想当然地去释放。如果我释放的不是原始分配给我的指针，而是我对这个指针做了点运算，比如，我就想释放我申请内存的后半部分。这么想想好像非常符合情理。但最后释放可能就会出错。因为内存分配器依赖这个原始指针精确值来定位内存块的管理信息。任何指针运算都会破坏这个前提，导致分配器操作错误的内存地址，进而损坏内存管理数据或用户数据。 关于返回值以及void* malloc 返回一个 void* 类型的指针，void* 字面意思是”指向 void 的指针”，但更准确的理解是”通用指针”或”无类型指针”。 内存本身只是字节序列，没有内在的类型信息。编译器需要知道如何解释这些字节。例如，同样的 4 个字节，可以被解释为整数、浮点数、4 个字符，或者只是一个内存地址。void* 表示”这里有一块内存，但不知道它应该被解释为什么类型”。 这时候理解了当时为什么觉得抄malloc函数很麻烦：比如 进行 int* ptr = (int*)malloc(sizeof(int)); 时，发生了两件事： malloc 分配了一块适当大小的原始内存，返回 void* 还要通过类型转换告诉编译器这块内存当作整数来使用 一句里出现了三个int，让本科时候的我抄得一头雾水。 关于new和delete，我后面专门开一篇来学习整理，因为那个感觉和自定义类型相关性较高，重点在对象的创建和释放上。底层还是malloc这些。","tags":["C++"]},{"title":"LRU把最老的赶出门犯法吗","path":"/2026/01/21/LRU把最老的赶出门犯法吗/","content":"今天来学学LRU在UE5.6引擎里的实现，之前会写大致的LRU算法，也没太关注内存有没有泄漏什么的。顺带学学C++的RAII，深入理解一下。 代码文件在此： 1Engine/Source/Runtime/Core/Public/Containers/LRUCache.h 一点一点看吧。 首先，这份代码先写了一个TLruCache的键比较器模板 12345678910111213141516171819/** * Default comparer for keys in TLruCache. * * @param KeyType The type of keys to compare. */template&lt;typename KeyType&gt;struct DefaultKeyComparer&#123;\t[[nodiscard]] static FORCEINLINE bool Matches(KeyType A, KeyType B)\t&#123; return (A == B);\t&#125;\t/** Calculates a hash index for a key. */\t[[nodiscard]] static FORCEINLINE uint32 GetKeyHash(KeyType Key)\t&#123; return GetTypeHash(Key);\t&#125;&#125;; Matches(KeyType A, KeyType B)主要判断两个键是否相等。[[nodiscard]]是C++17的属性，提醒用户必须使用返回值。FORCEINLINE就是UE的宏，如其名，强制内联以提升性能。这里用了return (A == B);也就是说KeyType类型必须实现==比较运算符。 GetKeyHash就是计算键的哈希值。 然后进入正题，TLruCache。首先把一堆接口函数折叠起来，看看私有成员： 123456789101112131415161718192021class TLruCache&#123;public:...public:...public:...protected:...public:...private:\t/** Set of entries for fast lookup. */\tTSet&lt;FCacheEntry*, FKeyFuncs&gt; LookupSet;\t/** Least recent item in the cache. */\tFCacheEntry* LeastRecent;\t/** Most recent item in the cache. */\tFCacheEntry* MostRecent;\t/** Maximum number of elements in the cache. */\tint32 MaxNumElements;&#125; 先了解一下私有成员：LookupSet就是一个哈希表，用来存储FCacheEntry*指针。LeastRecent应该就是指向最旧条目的那个指针。MostRecent就是最新的了。至于FCacheEntry为什么起这名呢？一会翻到了再看。 类的开头就是FCacheEntry结构体的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** An entry in the LRU cache. */\tstruct FCacheEntry\t&#123; /** The entry&#x27;s lookup key. */ KeyType Key; /** The less recent entry in the linked list. */ FCacheEntry* LessRecent; /** The more recent entry in the linked list. */ FCacheEntry* MoreRecent; /** The entry&#x27;s value. */ ValueType Value; /** * Create and initialize a new instance. * * @param InKey The entry&#x27;s key. * @param InValue The entry&#x27;s value. */ [[nodiscard]] FCacheEntry(const KeyType&amp; InKey, const ValueType&amp; InValue) : Key(InKey) , LessRecent(nullptr) , MoreRecent(nullptr) , Value(InValue) &#123; &#125; /** * Create a new instance with a default key value. * * @param InKey The entry&#x27;s key. */ [[nodiscard]] FCacheEntry(const KeyType&amp; InKey) : Key(InKey) , LessRecent(nullptr) , MoreRecent(nullptr) &#123; &#125; /** Add this entry before the given one. */ FORCEINLINE void LinkBefore(FCacheEntry* Other) &#123; LessRecent = Other; if (Other != nullptr) &#123; Other-&gt;MoreRecent = this; &#125; &#125; /** Remove this entry from the list. */ FORCEINLINE void Unlink() &#123; if (LessRecent != nullptr) &#123; LessRecent-&gt;MoreRecent = MoreRecent; &#125; if (MoreRecent != nullptr) &#123; MoreRecent-&gt;LessRecent = LessRecent; &#125; LessRecent = nullptr; MoreRecent = nullptr; &#125;\t&#125;;\t/** Lookup set key functions. */\tstruct FKeyFuncs : public BaseKeyFuncs&lt;FCacheEntry*, KeyType&gt;\t&#123; [[nodiscard]] FORCEINLINE static const KeyType&amp; GetSetKey(const FCacheEntry* Entry) &#123; return Entry-&gt;Key; &#125; [[nodiscard]] FORCEINLINE static bool Matches(KeyType A, KeyType B) &#123; return KeyComp::Matches(A, B); &#125; [[nodiscard]] FORCEINLINE static uint32 GetKeyHash(KeyType Key) &#123; return KeyComp::GetKeyHash(Key); &#125;\t&#125;; 先看 FCacheEntry 结构体。它是一个双向链表节点，包含四个成员：Key 和 Value 存储键值对数据；LessRecent 和 MoreRecent 是两个指针，用于链接节点。LessRecent 指向时间更早的节点（类似平常写的pre，next指针），MoreRecent 指向时间更晚的节点。链表的方向是从最新到最旧，每个节点通过这两个指针形成双向链接。 结构体提供了两个构造函数。第一个构造函数同时接收键和值，用于完整初始化条目，链表指针都设为 nullptr。第二个构造函数只接收键，用于需要延迟初始化值的场景（如 AddUninitialized_GetRef），此时值会使用默认构造或由调用者后续设置。 LinkBefore 方法将当前节点插入到指定节点之前。它先设置当前节点的 LessRecent 指向目标节点，如果目标节点存在，再将目标节点的 MoreRecent 指向当前节点。这样就把当前节点插入到了更靠近链表头部的位置。需要注意，这里只建立了局部连接，如果当前节点原本在链表中的其他位置，调用前通常需要先调用 Unlink 断开原有连接。 Unlink 方法将当前节点从双向链表中移除。它先检查前驱和后继节点，如果前驱存在，将前驱的 MoreRecent 指向当前节点的后继；如果后继存在，将后继的 LessRecent 指向当前节点的前驱。这样即使移除了当前节点，链表的其他部分仍然保持连接。最后将当前节点的两个指针都设为 nullptr，完成解除链接。上面这个插入删除操作就是链表结点的插入删除，没有什么高深的地方。只不过，这种操作在面试写的时候都是把插入删除方法封装在Node结点外面的，这里直接放在了结点的Struct里面，通过传递指针完成操作。 接下来是 FKeyFuncs 结构体，它继承自 BaseKeyFuncs&lt;FCacheEntry*, KeyType&gt;。这个适配器的作用是让 TSet 能够存储 FCacheEntry* 指针，同时使用 KeyType 作为查找键。TSet 需要从存储的元素中提取键，但存储的是指针类型，查找用的是键类型，所以需要这个适配器来桥接。 FKeyFuncs 提供了三个静态方法。GetSetKey 方法从 FCacheEntry* 指针中提取键，直接返回 Entry-&gt;Key，这样 TSet 就知道如何从存储的指针中获取键了。Matches 方法比较两个键是否相等，它委托给模板参数 KeyComp 的 Matches 方法，这样支持了自定义键比较逻辑。GetKeyHash 方法计算键的哈希值，同样委托给 KeyComp 的 GetKeyHash 方法，用于哈希表的定位和查找。 当 TSet 需要查找某个键时，它会使用 FKeyFuncs 来进行操作。TSet 遍历哈希桶中的 FCacheEntry* 指针，对每个指针调用 GetSetKey 得到对应的键，然后调用 Matches 方法比较该键与查找的键是否相等。如果相等就返回该指针。这样 TSet 就能存储指针类型，但用键类型进行查找，实现了类型转换的适配。 LRU所需的数据结构如上，定义完毕。 先把第一个public翻开，看看里面是什么： 12345678910111213141516171819202122232425262728public:\t/** Default constructor (empty cache that cannot hold any values). */\t[[nodiscard]] TLruCache() : LeastRecent(nullptr) , MostRecent(nullptr) , MaxNumElements(0)\t&#123;\t&#125;\t/** * Create and initialize a new instance. * * @param InMaxNumElements The maximum number of elements this cache can hold. */\t[[nodiscard]] TLruCache(int32 InMaxNumElements) : LeastRecent(nullptr) , MostRecent(nullptr) , MaxNumElements(InMaxNumElements)\t&#123; Empty(InMaxNumElements);\t&#125;\t/** Destructor. */\t~TLruCache()\t&#123; Empty();\t&#125; 构造函数和析构函数都比较好理解，就不展开看了。 再下面就是各种插入删除结点的接口，实现的思路和平常一样。 用工业级的代码与我们平常写的做一个对比。平常面试写的时候，类型单一，限制很多。见：https://leetcode.cn/problems/lru-cache-lcci/description/ 简易LRU实现将键类型固定为 int，UE引擎的LRU缓存采用模板设计，KeyType 可以是任意类型。这是适配器存在的原因之一，但不是唯一原因。 简易实现使用 unordered_map&lt;int, Node*&gt;，哈希表直接以 int 作为键进行存储和查找，类型匹配，无需额外转换。即便改为模板类以支持多种键类型，例如 unordered_map&lt;KeyType, Node*&gt;，类型仍然匹配，因为键类型就是模板参数，哈希表可以直接处理。 UE引擎的实现采用了不同的设计。它使用 TSet&lt;FCacheEntry*, FKeyFuncs&gt;，哈希表中存储的是 FCacheEntry* 指针，但查找时使用的是 KeyType，从而造成类型不匹配：存储的是指针类型，查找传入的是键类型，两者在类型系统上无法直接对应。为解决这个问题，UE 引入了 FKeyFuncs 适配器。适配器提供 GetSetKey 方法，告知哈希表如何从存储的 FCacheEntry* 指针中提取 KeyType 类型的键。当调用 LookupSet.Find(Key) 时，哈希表会遍历存储的指针，对每个指针调用 GetSetKey 提取键，再与传入的键比较，从而找到匹配的条目。 除了解决类型不匹配问题，适配器还承担了支持模板灵活性的职责。由于 UE 的 LRU 缓存是模板类，KeyType 可以是 int、string、自定义结构体等任意类型。不同键类型可能需要不同的比较和哈希方式，因此适配器还提供 Matches 和 GetKeyHash 方法，这些方法委托给模板参数 KeyComp 处理，使得可以自定义键类型的比较和哈希逻辑。这种设计虽然增加了代码复杂度，但提供了更大的灵活性，能够适应各种不同的键类型和使用场景。 总结来说，适配器的存在主要源于两个因素：一是存储指针但用键查找导致的类型不匹配问题，二是模板设计带来的类型灵活性需求。即使简易版本改成模板支持多种键类型，只要使用 unordered_map&lt;KeyType, Node*&gt; 这种类型匹配的设计仍然不需要适配器。UE 版本需要适配器主要是因为它选择了“存储指针 + 用键查找”这种设计模式，这种模式在提供灵活性的同时也带来了类型系统上的挑战，适配器就是用来解决这些问题。","tags":["UE","C++"]},{"title":"进程和线程到底有什么区别","path":"/2026/01/20/进程和线程到底有什么区别/","content":"说来惭愧。每次看到这个问题，就只能想到“进程拥有资源，线程拥有cpu”之类一点不严谨的描述，两年前学的408现在忘得差不多了，导致每次看到这些问题，总感觉有万匹飞奔的载着408知识的野马从我的大脑皮层轻轻掠过。 首先，想得确实没错。进程是资源分配的基本单位。资源有什么？第一个一定是有自己的虚拟地址空间，独立的虚拟内存，然后就是文件描述符表，环境变量，信号处理表等等，通过PCB记录资源的状态。主要目的就是提供一个隔离开的执行环境，一个进程停止或崩溃不会影响到其他进程。 线程，是cpu调度的基本单位。同一个进程内的线程是共享进程内的资源的。每个线程又有什么资源？线程需要有自己的id，程序计数器，寄存器集合以及自己的栈空间（重点），由TLB（线程控制块）来记录这些调度所需的信息。 注意，C++中，一个线程的崩溃可能会导致整个进程的终止。（可以引出线程的健壮性没有进程的高） 这是因为操作系统以进程为基本管理单元：所有线程共享同一地址空间和资源，当一个线程因段错误或未捕获异常等致命错误崩溃时，会触发进程级别的信号（如SIGSEGV），操作系统为避免数据不一致或资源泄漏，默认会终止整个进程。虽然可以通过信号处理或线程隔离技术尝试局部处理，但本质上操作系统将进程视为不可分割的整体，一个线程的致命错误被视为整个进程的失效。 在游戏开发中，选择多进程还是多线程是一个基于隔离性、性能、复杂性和稳定性等多维度考量的架构决策。其核心逻辑是将需要紧密协作、高频数据共享、且对延迟极度敏感的核心游戏循环置于多线程模型之下；而将那些需要独立生命周期、强故障隔离、或涉及外部安全性的边界系统部署为多进程。 游戏的核心运行时引擎几乎无一例外地重度依赖多线程，这是由现代游戏的性能需求决定的。游戏帧循环（Game Loop）是一个严格的实时系统，必须在大约16.6毫秒（对应60帧/秒）内完成逻辑更新、动画计算、物理模拟、场景管理、渲染命令提交等一系列繁重工作。为了将这些工作分摊到多个CPU核心上，引擎会采用精细的多线程分工。例如，主线程（通常称为游戏线程）负责驱动游戏逻辑、脚本执行和动画状态机；一个或多个渲染线程负责处理图形API调用、资源状态管理和命令缓冲区；独立的音频线程负责解码、混音和三维音效处理；庞大的后台线程池则用于处理异步资源加载、着色器编译、数据解压、以及通过任务并行系统（如虚幻引擎的Task Graph、Unity的Job System）来并行执行大量的同质计算，如视锥体剔除、粒子系统更新、蒙皮矩阵计算等。这些线程之间需要毫秒级的同步和极高频的内存数据交换（如传递变换矩阵、可见物体列表），使用线程共享内存是唯一能满足这种性能要求的方式。 然而在游戏开发和运行的特定边界场景下，多进程架构则展现出不可替代的价值。首要场景是开发工具链与运行时分离。游戏编辑器（如Unreal Editor、Unity Editor）通常运行一个独立的游戏进程（Play-in-Editor）来预览游戏效果。这种进程级隔离至关重要：当测试的游戏崩溃时，它只会带走这个预览进程，而宝贵的编辑器工作状态（如正在编辑的关卡、未保存的资源）得以完好无损，极大提升了开发效率和稳定性，并支持安全的热重载功能。第二个关键场景是安全与反作弊。在在线多人游戏中，反外挂模块（如反作弊客户端）通常以一个高权限的独立进程运行，通过进程间通信监控游戏主进程的内存和操作。这种隔离增加了恶意软件进行代码注入和数据篡改的难度。第三个场景是模块化与可维护性。一些大型游戏或引擎允许将相对独立的功能模块（如特定的物理模拟器、语音聊天服务、视频录制工具）作为插件进程运行。这样单个插件的崩溃或更新无需重启整个游戏主进程。在服务器端架构中，多进程也更为常见。一个大型多人在线游戏的服务器集群可能由多个专有进程组成，例如独立的登录认证进程、世界逻辑进程、数据库代理进程等，这种分离有助于资源管理、独立扩展和故障隔离。 后面可以开始了解一下UE多线程的一些概念了： [原创]UE基础—多线程（一） - 凌泽的文章 - 知乎https://zhuanlan.zhihu.com/p/553957069 现代C++的内存模型和高性能的多线程编程：https://skyscribe.github.io/post/2019/11/04/cpp-memory-model-and-order/","tags":["C++","OS"]},{"title":"如何只在栈上或只在堆上创建类","path":"/2026/01/20/如何只在栈上或只在堆上创建类/","content":"如何只允许在堆上创建类？第一种思路，就是构造函数私有化，如下： 1234567891011121314#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;private:\tOnlyOnHeap()=default;&#125;;int main()&#123;\tOnlyOnHeap o1;&#125; 如果尝试在栈上构建此对象，则会报错，信息如下： 1&quot;OnlyOnHeap::OnlyOnHeap()&quot; (已声明 所在行数:7，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnHeap.h&quot;) 不可访问 但是，此时如果想实现在堆上构造，new也用不了了。此时只能写一个显式的静态函数去调用私有的构造函数去创建类并返回类的指针，如下： 12345678910111213#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;private:\tOnlyOnHeap()=default;&#125;; 此时就可以通过create函数去间接在堆上构造这个类了。 此时发现一个问题：如果使用赋值，还是可以赋值到一个栈上的对象并且不报错： 12OnlyOnHeap *o1=OnlyOnHeap::Create();OnlyOnHeap o2 = *o1;//没有报错 此时还需要禁用拷贝构造和拷贝赋值函数： 123456789101112131415#pragma onceclass OnlyOnHeap&#123;public:\t~OnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\tOnlyOnHeap()=default;&#125;; 换一种思路。如果要禁用在栈上构造对象，程序退出栈的时候会自动调用栈上类的析构函数。编译器会把析构函数插入到程序中，可以把析构函数设为private，是否可行？如下： 123456789101112131415161718192021#pragma onceclass OnlyOnHeap&#123;public:\tOnlyOnHeap() = default;\tstatic OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\t~OnlyOnHeap() = default;&#125;;int main()&#123; OnlyOnHeap o1;//尝试在栈上创建对象&#125; 此时报错： 1&quot;OnlyOnHeap::~OnlyOnHeap() noexcept&quot; (已声明 所在行数:18，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnHeap.h&quot;) 不可访问 所以，私有化析构函数也可以防止程序在栈上创建类。 最佳实践的写法如下，核心就是手写创建和销毁，间接去调用new和delete去管理堆上的内存。 1234567891011121314151617181920212223#pragma onceclass OnlyOnHeap&#123;public: static OnlyOnHeap* Create()\t&#123; return new OnlyOnHeap();\t&#125;\tvoid destory()\t&#123; delete this;\t&#125;\tOnlyOnHeap(const OnlyOnHeap&amp;) = delete;\tOnlyOnHeap&amp; operator=(const OnlyOnHeap&amp;) = delete;private:\tOnlyOnHeap() = default;\t~OnlyOnHeap() = default;&#125;; 如何只允许在栈上创建类？这个就好写多了。平时在堆上创建类有两种方法，一种是用new，一种是malloc。 禁止使用new，就把new的运算符禁用即可，别忘了数组也要禁用。 123456789101112#pragma onceclass OnlyOnStack&#123;public:\tOnlyOnStack()=default;\t~OnlyOnStack() = default;\tvoid* operator new(size_t) = delete;\tvoid* operator new[](size_t) = delete;\tvoid* operator new(size_t, void* p)=delete; void* operator new[](size_t, void* p) = delete; 如果是malloc来创建对象。这里理解一下如何通过malloc分配的内存在堆上创建对象： 1void* memory = malloc(sizeof(MyClass)); // 仅仅分配原始内存 malloc函数只分配一堆字节内存空间，并不会调用类的构造函数，返回的是一个void*指针。 如果我们用new操作的话，过程如下： 1234MyClass* obj = new MyClass();// 1. void* memory = operator new(sizeof(MyClass)); // 分配内存// 2. obj = static_cast&lt;MyClass*&gt;(memory);// 3. obj-&gt;MyClass(); // 调用构造函数（编译器隐式调用） 一般如果显式地写malloc，后面是这么构造对象的： 123456// 其实也就是手动完成上面三步void* memory = malloc(sizeof(MyClass)); // 1. 分配内存（替代operator new）MyClass* obj = new(memory) MyClass(); // 2. 构造对象// 使用对象...obj-&gt;~MyClass(); // 3. 手动析构free(memory); // 4. 释放内存 所以还要禁用掉placement new，也就是 1void* operator new(size_t, void* p)=delete; 此时如果尝试在堆上创建类： 1OnlyOnStack* os = new OnlyOnStack(); 就会报错： 1无法引用 函数 &quot;OnlyOnStack::operator new(size_t)&quot; (已声明 所在行数:9，所属文件:&quot;E:\\UnrealWorld\\Cpp\\LearnMordenCpp\\OnlyOnStack.h&quot;) -- 它是已删除的函数","tags":["C++"]},{"title":"多继承类的虚函数表会有几张？","path":"/2026/01/12/多继承类的虚函数表会有几张？/","content":"对于多继承类的理解，我一直感到疑惑。为什么要使用多继承呢？为什么不用组合呢？这个疑惑一会儿再来解答。今天先来探索一下多继承类下，虚函数表与虚函数表指针在内存布局的情况。 在运行任何测试代码之前，我先提出我目前的理解。如果先不考虑有菱形继承的情况。我们有一个电动车ElectricCar类，它继承了两个类：一个是Vehicle交通工具类（电动车是交通工具），一个是Electronic电子设备类（不得不说确实是电子设备）。它的内存布局我目前的理解长这样： 123456Vehicle的虚函数表指针Vehicle的成员对象（int，string等）Electronic的虚函数表指针Electronic的成员对象ElectricCar的虚函数表指针ElectricCar的成员对象 按照我目前的理解，为了实现多态（也就是可以用基类的指针指向派生类的对象）的话，好像必须要保留每一个基类对象的虚函数表指针。 口说无凭。来看看代码测试： 首先定义了三个基类，分别是交通工具类，电子设备类和导航类（工程里还是用组合好） 123456789101112131415161718192021222324252627282930313233343536373839404142class Vehicle &#123;public: virtual void vehicle_start() &#123; cout &lt;&lt; &quot;Vehicle::vehicle_start()&quot; &lt;&lt; endl; &#125; virtual void vehicle_stop() &#123; cout &lt;&lt; &quot;Vehicle::vehicle_stop()&quot; &lt;&lt; endl; &#125; virtual ~Vehicle() &#123; cout &lt;&lt; &quot;Vehicle destructor&quot; &lt;&lt; endl; &#125;&#125;;class Electronic &#123;public: virtual void electronic_powerOn() &#123; cout &lt;&lt; &quot;Electronic::electronic_powerOn()&quot; &lt;&lt; endl; &#125; virtual void electronic_powerOff() &#123; cout &lt;&lt; &quot;Electronic::electronic_powerOff()&quot; &lt;&lt; endl; &#125; virtual ~Electronic() &#123; cout &lt;&lt; &quot;Electronic destructor&quot; &lt;&lt; endl; &#125;&#125;;class Navigable &#123;public: virtual void navigable_setDestination() &#123; cout &lt;&lt; &quot;Navigable::navigable_setDestination()&quot; &lt;&lt; endl; &#125; virtual ~Navigable() &#123; cout &lt;&lt; &quot;Navigable destructor&quot; &lt;&lt; endl; &#125;&#125;; 又定义了派生类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 派生类1：电动车（继承自Vehicle和Electronic）class ElectricCar : public Vehicle, public Electronic &#123;public: // 重写Vehicle的虚函数 virtual void vehicle_start() override &#123; cout &lt;&lt; &quot;ElectricCar::vehicle_start() [静音启动]&quot; &lt;&lt; endl; &#125; // 重写Electronic的虚函数 virtual void electronic_powerOn() override &#123; cout &lt;&lt; &quot;ElectricCar::electronic_powerOn() [智能启动]&quot; &lt;&lt; endl; &#125; // 新增的虚函数 virtual void electricCar_charge() &#123; cout &lt;&lt; &quot;ElectricCar::electricCar_charge() [专用充电]&quot; &lt;&lt; endl; &#125; virtual ~ElectricCar() &#123; cout &lt;&lt; &quot;ElectricCar destructor&quot; &lt;&lt; endl; &#125;&#125;;// 派生类2：智能电动车（继承自三个基类）class SmartElectricCar : public Vehicle, public Electronic, public Navigable &#123;public: // 重写Vehicle的虚函数 virtual void vehicle_start() override &#123; cout &lt;&lt; &quot;SmartElectricCar::vehicle_start() [语音控制启动]&quot; &lt;&lt; endl; &#125; // 重写Electronic的虚函数 virtual void electronic_powerOff() override &#123; cout &lt;&lt; &quot;SmartElectricCar::electronic_powerOff() [延时关机]&quot; &lt;&lt; endl; &#125; // 重写Navigable的虚函数 virtual void navigable_setDestination() override &#123; cout &lt;&lt; &quot;SmartElectricCar::navigable_setDestination() [AI推荐路线]&quot; &lt;&lt; endl; &#125; // 新增的虚函数 virtual void smartElectricCar_autoPilot() &#123; cout &lt;&lt; &quot;SmartElectricCar::smartElectricCar_autoPilot() [自动驾驶]&quot; &lt;&lt; endl; &#125; virtual ~SmartElectricCar() &#123; cout &lt;&lt; &quot;SmartElectricCar destructor&quot; &lt;&lt; endl; &#125;&#125;; 首先来测试不同类的大小 12345678void testVTablePointers() &#123; cout &lt;&lt; &quot;======= 测试不同类的对象大小 ======= &quot;; cout &lt;&lt; &quot;sizeof(Vehicle): &quot; &lt;&lt; sizeof(Vehicle) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(Electronic): &quot; &lt;&lt; sizeof(Electronic) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(Navigable): &quot; &lt;&lt; sizeof(Navigable) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(ElectricCar): &quot; &lt;&lt; sizeof(ElectricCar) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(SmartElectricCar): &quot; &lt;&lt; sizeof(SmartElectricCar) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;&#125; 测试结果： 1234567======= 测试不同类的对象大小 =======sizeof(Vehicle): 8 bytessizeof(Electronic): 8 bytessizeof(Navigable): 8 bytessizeof(ElectricCar): 16 bytessizeof(SmartElectricCar): 24 bytes 在64位系统中，一个指针通常为8字节。从测试结果可以看出：ElectricCar有2个vptr，所以有16字节SmartElectricCar有3个vptr，所以有24字节 接着看一看多继承下的指针转换 我一直认为，当一个基类指针指向派生类时，这个基类指针的地址就是派生类最头的那个虚函数表指针的地址。但这好像只适用于单继承。 1234567891011121314151617181920// 测试多继承下的指针转换void testPointerCasting() &#123; cout &lt;&lt; &quot; ======= 测试多继承下的指针转换 ======= &quot;; ElectricCar electricCar; cout &lt;&lt; &quot; 1. ElectricCar对象地址: &quot; &lt;&lt; &amp;electricCar &lt;&lt; endl; // 转换为不同基类指针 Vehicle* vehiclePtr = &amp;electricCar; Electronic* electronicPtr = &amp;electricCar; cout &lt;&lt; &quot;2. Vehicle* 指针值: &quot; &lt;&lt; vehiclePtr &lt;&lt; endl; cout &lt;&lt; &quot;3. Electronic* 指针值: &quot; &lt;&lt; electronicPtr &lt;&lt; endl; // 计算偏移量 cout &lt;&lt; &quot;4. 两个指针的差值: &quot; &lt;&lt; reinterpret_cast&lt;char*&gt;(electronicPtr) - reinterpret_cast&lt;char*&gt;(vehiclePtr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;&#125; 测试结果： 12345678910======= 测试多继承下的指针转换 =======1. ElectricCar对象地址: 000000CC36AFF8682. Vehicle* 指针值: 000000CC36AFF8683. Electronic* 指针值: 000000CC36AFF8704. 两个指针的差值: 8 字节ElectricCar destructorElectronic destructorVehicle destructor 可以看出，和单继承不同。多继承时，不同的基类子对象在派生类中位置不同。Vehicle子对象在ElectricCar的开始位置而Electronic子对象在Vehicle子对象之后。正因如此，二者的指针地址并不一样，他们各自指向了自己的那个子对象位置的开头。相差的8字节便是一个虚函数表指针的大小。 现在可以认为，两个派生类的内存布局如下： 123456789101112131415ElectricCar对象布局： [vptr_Vehicle] → Vehicle虚函数表 [Vehicle数据成员] [vptr_Electronic] → Electronic虚函数表 [Electronic数据成员] [ElectricCar新增数据成员] SmartElectricCar对象布局： [vptr_Vehicle] → Vehicle虚函数表 [Vehicle数据成员] [vptr_Electronic] → Electronic虚函数表 [Electronic数据成员] [vptr_Navigable] → Navigable虚函数表 [Navigable数据成员] [SmartElectricCar新增数据成员] 一个很重要的点：当通过基类指针调用虚函数时，编译器会自动调整this指针。 用一个直观的多继承的内存布局图： 123456789101112131415161718地址 内容 大小0x628C0FF328 ┌─────────────────────┐ │ Base1的vptr │ 8字节0x628C0FF330 ├─────────────────────┤ │ Base1::b1_data=100 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF338 ├─────────────────────┤ │ Base2的vptr │ 8字节 0x628C0FF340 ├─────────────────────┤ │ Base2::b2_data=200 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF348 ├─────────────────────┤ │ Derived::d_data=300 │ 4字节 ├─────────────────────┤ │ 填充字节 │ 4字节0x628C0FF350 └─────────────────────┘ Derived d;Base2* pb2 = &d; // pb2指向0x628C0FF338，而不是内存最头的0x628C0FF328 调用pb2-&gt;b2_func()时，主要的步骤如下： 通过pb2找到Base2的vptr 通过vptr找到虚函数表 调用正确的函数 函数内部的this指针就是pb2（指向Base2子对象） 虚函数表里到底有什么？既然每个基类都有自己的虚函数表指针，那么这些虚函数表里到底存储了什么内容呢？ 对于ElectricCar类，它有两个虚函数表： Vehicle的虚函数表：存储Vehicle的虚函数地址 Electronic的虚函数表：存储Electronic的虚函数地址 但是，当ElectricCar重写了某些虚函数时，这些虚函数表里的内容会发生变化。让我写个测试来验证一下： 12345678910111213141516171819202122232425262728// 测试虚函数表的内容void testVTableContent() &#123; cout &lt;&lt; &quot; ======= 测试虚函数表内容 ======= &quot;; ElectricCar electricCar; // 获取Vehicle虚函数表 typedef void(*FuncPtr)(); void** vtable_vehicle = *(void***)&amp;electricCar; cout &lt;&lt; &quot;Vehicle虚函数表内容：&quot; &lt;&lt; endl; cout &lt;&lt; &quot; [0] vehicle_start: &quot; &lt;&lt; vtable_vehicle[0] &lt;&lt; endl; cout &lt;&lt; &quot; [1] vehicle_stop: &quot; &lt;&lt; vtable_vehicle[1] &lt;&lt; endl; cout &lt;&lt; &quot; [2] ~Vehicle: &quot; &lt;&lt; vtable_vehicle[2] &lt;&lt; endl; // 获取Electronic虚函数表（需要偏移8字节） void** vtable_electronic = *(void***)((char*)&amp;electricCar + 8); cout &lt;&lt; &quot; Electronic虚函数表内容：&quot; &lt;&lt; endl; cout &lt;&lt; &quot; [0] electronic_powerOn: &quot; &lt;&lt; vtable_electronic[0] &lt;&lt; endl; cout &lt;&lt; &quot; [1] electronic_powerOff: &quot; &lt;&lt; vtable_electronic[1] &lt;&lt; endl; cout &lt;&lt; &quot; [2] ~Electronic: &quot; &lt;&lt; vtable_electronic[2] &lt;&lt; endl; // 调用验证 cout &lt;&lt; &quot; 通过函数指针调用验证：&quot; &lt;&lt; endl; ((FuncPtr)vtable_vehicle[0])(); // 应该调用ElectricCar::vehicle_start ((FuncPtr)vtable_electronic[0])(); // 应该调用ElectricCar::electronic_powerOn&#125; 测试结果会显示，Vehicle虚函数表中的vehicle_start指向的是ElectricCar::vehicle_start，而不是Vehicle::vehicle_start。这说明派生类重写的虚函数会替换基类虚函数表中的对应项。 但是，ElectricCar新增的虚函数electricCar_charge()会放在哪里呢？答案是：它会被添加到第一个基类（Vehicle）的虚函数表中。这是因为派生类新增的虚函数需要能够通过派生类指针调用，而第一个基类指针通常指向对象的起始位置。 多继承时，派生类自己的虚函数放在哪里？（引用自博客园某篇，忘复制地址了） 为什么派生类的虚函数是追加在第一张虚表的后面？ 请看下面的一段汇编（没学过汇编，不献丑）结论： 派生类的虚函数是追加在第一张虚表的后面。当需要使用派生类的虚函数是，用第一张表的虚函数表指针指向派生类的虚函数即可。（个人观点）下面的汇编也应该是这样：1，找到虚函数表的起始地址，2.找到派生类的虚函数偏移，3.使用虚函数表指针指向派生类的虚函数。 123456789101112Copy Highlighter-hljs\tderiveA *pda = &amp;da;00A7A02E lea eax,[ebp-28h] 00A7A031 mov dword ptr [ebp-34h],eax pda-&gt;print();00A7A034 mov eax,dword ptr [ebp-34h] 00A7A037 mov edx,dword ptr [eax] 00A7A039 mov esi,esp 00A7A03B mov ecx,dword ptr [ebp-34h] 00A7A03E mov eax,dword ptr [edx+4] 00A7A041 call eax 00A7A043 cmp esi,esp 00A7A045 call 00A714C4 构造函数和析构函数的调用顺序12345678910111213141516171819202122232425// 添加一些数据成员来观察构造顺序class Vehicle &#123;public: int vehicle_id; Vehicle() : vehicle_id(1) &#123; cout &lt;&lt; &quot;Vehicle constructor&quot; &lt;&lt; endl; &#125; &#125;;class Electronic &#123;public: int electronic_id; Electronic() : electronic_id(2) &#123; cout &lt;&lt; &quot;Electronic constructor&quot; &lt;&lt; endl; &#125; &#125;;void testConstructionOrder() &#123; cout &lt;&lt; &quot; ======= 测试构造和析构顺序 ======= &quot;; cout &lt;&lt; &quot;创建ElectricCar对象：&quot; &lt;&lt; endl; ElectricCar ec; cout &lt;&lt; &quot; 销毁ElectricCar对象：&quot; &lt;&lt; endl;&#125; 测试结果： 12345678910======= 测试构造和析构顺序 =======创建ElectricCar对象：Vehicle constructorElectronic constructorElectricCar constructor销毁ElectricCar对象：ElectricCar destructorElectronic destructorVehicle destructor 可以看出： 构造顺序：按照继承列表的顺序，从左到右依次构造基类，最后构造派生类 析构顺序：与构造顺序完全相反，先析构派生类，然后从右到左析构基类 函数名冲突：二义性问题多继承最容易遇到的问题就是函数名冲突。如果两个基类有同名的函数（即使参数不同），派生类在调用时就会产生二义性。 12345678910111213141516171819202122class Vehicle &#123;public: void start() &#123; cout &lt;&lt; &quot;Vehicle::start()&quot; &lt;&lt; endl; &#125;&#125;;class Electronic &#123;public: void start() &#123; // 同名函数！ cout &lt;&lt; &quot;Electronic::start()&quot; &lt;&lt; endl; &#125;&#125;;class ElectricCar : public Vehicle, public Electronic &#123;public: void test() &#123; // start(); // 错误！二义性，不知道调用哪个 Vehicle::start(); // 正确：明确指定基类 Electronic::start(); // 正确：明确指定基类 &#125;&#125;; 解决方法有几种： 使用作用域解析符：Vehicle::start() 或 Electronic::start() 在派生类中重写：在派生类中定义一个start()函数，内部调用需要的基类版本 使用using声明：using Vehicle::start; 将某个基类的函数引入派生类作用域 12345class ElectricCar : public Vehicle, public Electronic &#123;public: using Vehicle::start; // 引入Vehicle::start到当前作用域 // 现在可以直接调用start()，会调用Vehicle::start()&#125;; 为什么要用多继承？为什么不用组合？现在来解答我一开始的疑惑。 多继承的适用场景： 接口实现：当一个类需要实现多个接口时，多继承是自然的选择。比如Java的接口、C++的纯虚基类。 1234567891011121314151617// 接口类class IReadable &#123;public: virtual void read() = 0;&#125;;class IWritable &#123;public: virtual void write() = 0;&#125;;// 文件类实现两个接口class File : public IReadable, public IWritable &#123;public: void read() override &#123; /* ... */ &#125; void write() override &#123; /* ... */ &#125;&#125;; 混入（Mixin）模式：提供可复用的功能片段。 12345678910111213141516// 混入类：提供序列化功能class Serializable &#123;public: virtual string serialize() = 0;&#125;;// 混入类：提供日志功能class Loggable &#123;public: virtual void log() = 0;&#125;;// 业务类通过多继承获得这些功能class User : public Serializable, public Loggable &#123; // ...&#125;; “是一个”关系的多重性：当派生类确实是多个基类的特化时。 比如我们的ElectricCar，它确实”是一个”Vehicle，也”是一个”Electronic。这种情况下，多继承在语义上是合理的。 总结 多继承类有几个虚函数表？ 答案：有几个基类（有虚函数的），就有几个虚函数表指针。 内存布局：每个基类子对象在派生类中都有独立的内存区域，包括自己的虚函数表指针。 指针转换：不同基类指针指向派生类对象时，地址可能不同，编译器会自动调整。 this指针调整：通过不同基类指针调用虚函数时，this指针会自动调整到正确的子对象位置。 构造/析构顺序：按继承列表顺序构造，逆序析构。 二义性处理：同名函数冲突需要用作用域解析符或using声明解决。 但这里没有提到多继承下虚析构的一些细节，后面再说吧。","tags":["C++","面向对象"]},{"title":"又谈右值引用与移动构造函数","path":"/2025/12/24/又谈右值与移动构造函数/","content":"感觉又来谈谈右值引用了，这次带上了移动构造函数一起谈。初学移动构造函数时，我看到的大致能总结成这么一句话：资源的转移而非拷贝。由于我初学C++（之前写算法题不能算学了C++），很多隐藏的东西我很难搞懂，很多描述令我抓耳挠腮：有的描述说，右值引用可以延长对象的生命周期。怎么个延长法？本来在栈上的东西出了作用域就无了，延长的是谁的生命周期？对于移动构造函数来说，延长的是整个临时对象的生命周期吗？ 答案在C++ Primer里说的其实已经挺清楚了： 与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。StrVec的析构函数在first_free上调用deallocate。如果我们忘记了改变s.first_free，则销毁移后源对象就会释放掉我们刚刚移动的内存。 此处要注意两点：一是右值引用让编译器知道，这个引用（就是一个存地址的指针）绑定的是一个临时对象，该对象在之后不会被用到，那么编译器就可以安全地转移资源。 什么是资源？一个类A有如下成员变量： 123456class A&#123;private: int i; std::string s;&#125; 由于我实在头脑不清晰。我在最开始理解移动构造的时候，认为这种简单类型i也要进行移动。如果这个对象创建到了栈上，比如这样： 12345int main()&#123;\tA a1(1,&quot;a1&quot;);...&#125; 那么i这个变量也应该在栈上。那既然如此，我愚蠢地认为，出现了一个右值引用，引用到了栈上的这个i的变量。那函数结束后，作用域结束，该函数的栈都空了，哪去找这个i的变量引用？ 1234A(A&amp;&amp; other) noexcept : a(other.a), s(std::move(other.s)) &#123; std::cout &lt;&lt; &quot;Move Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; other.a = 0; &#125; 但是对于string来说比较好理解。string这个字符串实际是建立在堆上的，这里实际上拿的是一个指针。那么右值引用就告诉编译器，这是块后面不会再用到的资源，可以进行转移。于是把这个指针指向的地址（这个地址在堆）复制到新的对象里就好了。不需要在堆里再做资源的拷贝。但一定要注意。在退出移动构造函数之前，如果是自己定义的持有资源的对象，一定要将其清零。不然原对象会销毁我们已经移交了控制权的那块资源。此处string没有做是因为：std::move(other.s)来初始化新对象的s，这会调用std::string的移动构造函数），所以other.s已经被std::string的移动构造函数置为空字符串 那么这种简单变量怎么办呢？ 这时候愚蠢的我发现，移动构造函数可以我们自己写，一般直接赋值即可，也就是简单的拷贝操作： 12345678910// 移动赋值 A&amp; operator=(A&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; a = other.a; s = std::move(other.s); other.a = 0; std::cout &lt;&lt; &quot;Move Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; 这就解决了我的疑惑。我总是认为移动，就是都得移动！一点拷贝都不要沾！实际上是个非常片面、错误的想法。所以，移动构造函数主要利于持有资源的对象（简单理解为指针就行，就是避免把指针指向的东西再拷贝一遍，减少内存开销）。如果对象就只有一堆简单变量而已，那么写的移动构造函数和拷贝构造就没什么区别了。 再回到左右值，右值引用。 我真的很害怕这种文字游戏，用高级概念来解释高级概念，只会让头脑本就不清晰的我变得更笨。 把这些名词放到一遍。本质上，就是编译器对这些地址存放的东西打标记。编译器关心什么呢？它要知道的是：表达式有值类别(value category)以及类型系统附带生命周期信息。 我一开始会把“右值引用”和“右值本身”混为一谈，觉得 T&amp;&amp; 就意味着“这是一个右值”。其实更准确的理解是：右值引用并不是右值本身，而是一种给右值起别名的能力。右值对象通常是临时值，它本身可以直接绑定到右值引用上，例如： 1A&amp;&amp; r = A(); 在编译器眼里，这段代码等价于：先创建了一个临时对象 A()，然后给它取了一个名字 r，于是这个临时对象就有了一个别名。但需要注意的是，这个对象依然被编译器标记为“可被消耗的对象”，也就是允许对它进行资源转移。所以接下来完全可以写： 1A b = std::move(r); 这意味着右值引用可以捕获一个“将要销毁的对象”，并把这种“可以被破坏性使用”的标记继续传递下去。std::move 的本质其实非常简单，它甚至可以写成这样： 1234template&lt;class T&gt;T&amp;&amp; move(T&amp; t) &#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125; 它并不执行任何移动操作，只是把一个左值转换成右值引用类型，从而告诉编译器允许对它进行移动语义上的优化。真正的移动行为仍然发生在移动构造函数或移动赋值运算符中。 接下来有一个很容易误解的地方：右值引用变量本身是左值。 123A&amp;&amp; x = A();A y = x; // 这里会调用拷贝A z = std::move(x); // 这里才会调用移动 原因很简单：只要一个对象有名字，它就被编译器视为可寻址对象，因此具有左值语义；但它的类型却是 T&amp;&amp;，这意味着我们可以显式地把它再转换回右值类别。因此可以总结为：右值引用变量，其实是一个“绑定到右值上的左值”。它只是提供了一条绑定右值的渠道，而不是永久地把该对象钉死为右值。从优化角度看，右值引用最大的价值在于给编译器一个静态承诺：这个对象的生命周期即将结束，因此可以放心地转移资源，避免额外拷贝。 用一句话来说，右值引用代表的是：生命周期和使用方式上的承诺。编译器据此可以跨函数传递“允许破坏源对象”的权限，从而减少堆分配、避免深拷贝、优化容器重分配，并允许在返回大对象时仍然保持零开销。在拷贝构造函数中，编译器必须保证语义不变，因此不能破坏源对象（随便拿到别的对象拥有的资源并改变就是破坏了），只能重新开辟空间并复制内容；而在移动构造函数中，编译器已经得到了“可以破坏源对象”的授权，于是资源可以直接转移，爱怎么破坏就怎么破坏（），源对象只需要被置为空即可。那这么理解右值引用比较好，它把允许破坏源对象这件事情合法化并显式化，同时也给了编译器充分的优化空间。 这个网站好用啊：https://godbolt.org/ 写了个测试代码，可以看看汇编在干什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;string&gt;class A &#123;public: int a; std::string s; // 普通构造 A(int la, std::string ls) : a(la), s(std::move(ls)) &#123; std::cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; // 拷贝构造 A(const A&amp; other) : a(other.a), s(other.s) &#123; std::cout &lt;&lt; &quot;Copy Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; // 移动构造 A(A&amp;&amp; other) noexcept : a(other.a), s(std::move(other.s)) &#123; std::cout &lt;&lt; &quot;Move Construct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; other.a = 0; &#125; // 拷贝赋值 A&amp; operator=(const A&amp; other) &#123; if (this != &amp;other) &#123; a = other.a; s = other.s; std::cout &lt;&lt; &quot;Copy Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; // 移动赋值 A&amp; operator=(A&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; a = other.a; s = std::move(other.s); other.a = 0; std::cout &lt;&lt; &quot;Move Assign: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return *this; &#125; ~A() &#123; std::cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; s &lt;&lt; &quot;, a=&quot; &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;&#125;;// 返回值测试A return_by_value() &#123; A temp(100, &quot;temp&quot;); return temp; // NRVO/移动构造&#125;// 返回引用测试A&amp; return_by_ref(A&amp; obj) &#123; return obj;&#125;// 返回右值引用测试A&amp;&amp; return_by_rvalue_ref(A&amp; obj) &#123; return std::move(obj);&#125;int main() &#123; std::cout &lt;&lt; &quot;=== 创建 a1 === &quot;; A a1(1, &quot;a1&quot;); std::cout &lt;&lt; &quot; === 拷贝构造 a2(a1) === &quot;; A a2(a1); std::cout &lt;&lt; &quot; === 移动构造 a3(std::move(a1)) === &quot;; A a3(std::move(a1)); std::cout &lt;&lt; &quot; === 拷贝赋值 a2 = a3 === &quot;; a2 = a3; std::cout &lt;&lt; &quot; === 移动赋值 a3 = std::move(a2) === &quot;; a3 = std::move(a2); std::cout &lt;&lt; &quot; === 返回值测试 === &quot;; A a4 = return_by_value(); std::cout &lt;&lt; &quot; === 返回引用测试 === &quot;; A&amp; ref_a = return_by_ref(a3); std::cout &lt;&lt; &quot;ref_a.s = &quot; &lt;&lt; ref_a.s &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot; === 返回右值引用测试 === &quot;; A a5 = return_by_rvalue_ref(a3); std::cout &lt;&lt; &quot; === End of main === &quot;;&#125; 执行结果： 12345678910111213141516171819202122232425262728293031323334E:\\UnrealWorld\\project\\Learncpp\\x64\\Debug\\Learncpp.exe=== 创建 a1 ===Construct: a1, a=1=== 拷贝构造 a2(a1) ===Copy Construct: a1, a=1=== 移动构造 a3(std::move(a1)) ===Move Construct: a1, a=1=== 拷贝赋值 a2 = a3 ===Copy Assign: a1, a=1=== 移动赋值 a3 = std::move(a2) ===Move Assign: a1, a=1=== 返回值测试 ===Construct: temp, a=100=== 返回引用测试 ===ref_a.s = a1=== 返回右值引用测试 ===Move Construct: a1, a=1=== End of main ===Destruct: a1, a=1Destruct: temp, a=100Destruct: , a=0Destruct: , a=0Destruct: , a=0Process finished with exit code 0. 汇编长这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505# License: MSVC Proprietary# The use of this compiler is only permitted for internal evaluation purposes and is otherwise governed by the MSVC License Agreement.# See https://visualstudio.microsoft.com/license-terms/vs2022-ga-community/$SG35785 DB &#x27;temp&#x27;, 00H ORG $+3$SG35831 DB &#x27;=== &#x27;, 0e5H, 088H, 09bH, 0e5H, 0bbH, 0baH, &#x27; a1 ===&#x27;, 0aH DB 00H ORG $+1$SG35832 DB &#x27;a1&#x27;, 00H ORG $+1$SG35833 DB 0aH, &#x27;=== &#x27;, 0e6H, 08bH, 0b7H, 0e8H, 0b4H, 09dH, 0e6H, 09eH DB 084H, 0e9H, 080H, 0a0H, &#x27; a2(a1) ===&#x27;, 0aH, 00H ORG $+2$SG35834 DB 0aH, &#x27;=== &#x27;, 0e7H, 0a7H, 0bbH, 0e5H, 08aH, 0a8H, 0e6H, 09eH DB 084H, 0e9H, 080H, 0a0H, &#x27; a3(std::move(a1)) ===&#x27;, 0aH, 00H ORG $+7$SG35835 DB 0aH, &#x27;=== &#x27;, 0e6H, 08bH, 0b7H, 0e8H, 0b4H, 09dH, 0e8H, 0b5H DB 08bH, 0e5H, 080H, 0bcH, &#x27; a2 = a3 ===&#x27;, 0aH, 00H ORG $+1$SG35836 DB 0aH, &#x27;=== &#x27;, 0e7H, 0a7H, 0bbH, 0e5H, 08aH, 0a8H, 0e8H, 0b5H DB 08bH, 0e5H, 080H, 0bcH, &#x27; a3 = std::move(a2) ===&#x27;, 0aH, 00H ORG $+6$SG35837 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 080H DB 0bcH, 0e6H, 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; ===&#x27;, 0aH, 00H ORG $+6$SG35838 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 0bcH DB 095H, 0e7H, 094H, 0a8H, 0e6H, 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; &#x27; DB &#x27;===&#x27;, 0aH, 00H ORG $+3$SG35839 DB 0aH, 00H ORG $+6$SG35840 DB &#x27;ref_a.s = &#x27;, 00H ORG $+5$SG35841 DB 0aH, &#x27;=== &#x27;, 0e8H, 0bfH, 094H, 0e5H, 09bH, 09eH, 0e5H, 08fH DB 0b3H, 0e5H, 080H, 0bcH, 0e5H, 0bcH, 095H, 0e7H, 094H, 0a8H, 0e6H DB 0b5H, 08bH, 0e8H, 0afH, 095H, &#x27; ===&#x27;, 0aH, 00H ORG $+5$SG35842 DB 0aH, &#x27;=== End of main ===&#x27;, 0aH, 00H`string&#x27; DB &#x27;Destruct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Move Assign: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Copy Assign: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Move Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Copy Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;Construct: &#x27;, 00H ; `string&#x27;`string&#x27; DB &#x27;, a=&#x27;, 00H ; `string&#x27;`string&#x27; DB 0aH, 00H ; `string&#x27;tv79 = 32this$ = 64la$ = 72ls$ = 80A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) PROC ; A::A, COMDAT$LN5: mov QWORD PTR [rsp+24], r8 mov DWORD PTR [rsp+16], edx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov ecx, DWORD PTR la$[rsp] mov DWORD PTR [rax], ecx mov rcx, QWORD PTR ls$[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv79[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv79[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rcx, QWORD PTR ls$[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ENDP ; A::Atv78 = 32this$ = 64other$ = 72A::A(A const &amp;) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv78[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv78[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(A const &amp;) ENDP ; A::Atv80 = 32this$ = 64other$ = 72A::A(A &amp;&amp;) PROC ; A::A, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv80[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv80[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rax, QWORD PTR other$[rsp] mov DWORD PTR [rax], 0 mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A::A(A &amp;&amp;) ENDP ; A::Atv76 = 32this$ = 64other$ = 72A &amp; A::operator=(A const &amp;) PROC ; A::operator=, COMDAT$LN4: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR other$[rsp] cmp QWORD PTR this$[rsp], rax je $LN2@operator mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator=(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator= mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv76[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv76[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1$LN2@operator: mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A &amp; A::operator=(A const &amp;) ENDP ; A::operator=tv79 = 32this$ = 64other$ = 72A &amp; A::operator=(A &amp;&amp;) PROC ; A::operator=, COMDAT$LN5: mov QWORD PTR [rsp+16], rdx mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR other$[rsp] cmp QWORD PTR this$[rsp], rax je $LN2@operator mov rax, QWORD PTR this$[rsp] mov rcx, QWORD PTR other$[rsp] mov ecx, DWORD PTR [rcx] mov DWORD PTR [rax], ecx mov rax, QWORD PTR other$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt;(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;) ; std::move&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&gt; mov rcx, QWORD PTR this$[rsp] add rcx, 8 mov rdx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator=(std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &amp;&amp;) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::operator= mov rax, QWORD PTR other$[rsp] mov DWORD PTR [rax], 0 mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv79[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv79[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1$LN2@operator: mov rax, QWORD PTR this$[rsp] add rsp, 56 ; 00000038H ret 0A &amp; A::operator=(A &amp;&amp;) ENDP ; A::operator=tv71 = 32this$ = 64A::~A(void) PROC ; A::~A, COMDAT$LN4: mov QWORD PTR [rsp+8], rcx sub rsp, 56 ; 00000038H mov rax, QWORD PTR this$[rsp] add rax, 8 mov QWORD PTR tv71[rsp], rax lea rdx, OFFSET FLAT:`string&#x27; mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv71[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR this$[rsp] mov edx, DWORD PTR [rcx] mov rcx, rax call QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int) lea rdx, OFFSET FLAT:`string&#x27; mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 mov rax, QWORD PTR this$[rsp] add rax, 8 mov rcx, rax call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(void) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::~basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; npad 1 add rsp, 56 ; 00000038H ret 0A::~A(void) ENDP ; A::~A$T1 = 32$T2 = 40tv83 = 48$T3 = 56temp$ = 88__$ArrayPad$ = 128__$ReturnUdt$ = 160A return_by_value(void) PROC ; return_by_value$LN7: mov QWORD PTR [rsp+8], rcx sub rsp, 152 ; 00000098H mov rax, QWORD PTR __security_cookie xor rax, rsp mov QWORD PTR __$ArrayPad$[rsp], rax mov DWORD PTR $T1[rsp], 0 lea rax, QWORD PTR $T3[rsp] mov QWORD PTR $T2[rsp], rax lea rdx, OFFSET FLAT:$SG35785 mov rcx, QWORD PTR $T2[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(char const * const) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov QWORD PTR tv83[rsp], rax mov r8, QWORD PTR tv83[rsp] mov edx, 100 ; 00000064H lea rcx, QWORD PTR temp$[rsp] call A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ; A::A npad 1 lea rdx, QWORD PTR temp$[rsp] mov rcx, QWORD PTR __$ReturnUdt$[rsp] call A::A(A &amp;&amp;) ; A::A mov eax, DWORD PTR $T1[rsp] or eax, 1 mov DWORD PTR $T1[rsp], eax lea rcx, QWORD PTR temp$[rsp] call A::~A(void) ; A::~A mov rax, QWORD PTR __$ReturnUdt$[rsp] mov rcx, QWORD PTR __$ArrayPad$[rsp] xor rcx, rsp call __security_check_cookie add rsp, 152 ; 00000098H ret 0A return_by_value(void) ENDP ; return_by_valueobj$ = 8A &amp; return_by_ref(A &amp;) PROC ; return_by_ref mov QWORD PTR [rsp+8], rcx mov rax, QWORD PTR obj$[rsp] ret 0A &amp; return_by_ref(A &amp;) ENDP ; return_by_refobj$ = 48A &amp;&amp; return_by_rvalue_ref(A &amp;) PROC ; return_by_rvalue_ref$LN3: mov QWORD PTR [rsp+8], rcx sub rsp, 40 ; 00000028H mov rcx, QWORD PTR obj$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; add rsp, 40 ; 00000028H ret 0A &amp;&amp; return_by_rvalue_ref(A &amp;) ENDP ; return_by_rvalue_ref$T1 = 32tv165 = 40ref_a$ = 48tv148 = 56$T2 = 64a3$ = 96a2$ = 136a1$ = 176a5$ = 216a4$ = 256__$ArrayPad$ = 296main PROC$LN9: sub rsp, 312 ; 00000138H mov rax, QWORD PTR __security_cookie xor rax, rsp mov QWORD PTR __$ArrayPad$[rsp], rax lea rdx, OFFSET FLAT:$SG35831 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 lea rax, QWORD PTR $T2[rsp] mov QWORD PTR $T1[rsp], rax lea rdx, OFFSET FLAT:$SG35832 mov rcx, QWORD PTR $T1[rsp] call std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(char const * const) ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; mov QWORD PTR tv165[rsp], rax mov r8, QWORD PTR tv165[rsp] mov edx, 1 lea rcx, QWORD PTR a1$[rsp] call A::A(int,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35833 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, QWORD PTR a1$[rsp] lea rcx, QWORD PTR a2$[rsp] call A::A(A const &amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35834 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a1$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; mov rdx, rax lea rcx, QWORD PTR a3$[rsp] call A::A(A &amp;&amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35835 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, QWORD PTR a3$[rsp] lea rcx, QWORD PTR a2$[rsp] call A &amp; A::operator=(A const &amp;) ; A::operator= lea rdx, OFFSET FLAT:$SG35836 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a2$[rsp] call A &amp;&amp; std::move&lt;A &amp;&gt;(A &amp;) ; std::move&lt;A &amp;&gt; mov rdx, rax lea rcx, QWORD PTR a3$[rsp] call A &amp; A::operator=(A &amp;&amp;) ; A::operator= lea rdx, OFFSET FLAT:$SG35837 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a4$[rsp] call A return_by_value(void) ; return_by_value npad 1 lea rdx, OFFSET FLAT:$SG35838 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a3$[rsp] call A &amp; return_by_ref(A &amp;) ; return_by_ref mov QWORD PTR ref_a$[rsp], rax mov rax, QWORD PTR ref_a$[rsp] add rax, 8 mov QWORD PTR tv148[rsp], rax lea rdx, OFFSET FLAT:$SG35840 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; mov rcx, QWORD PTR tv148[rsp] mov rdx, rcx mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;) ; std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; lea rdx, OFFSET FLAT:$SG35839 mov rcx, rax call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rdx, OFFSET FLAT:$SG35841 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; lea rcx, QWORD PTR a3$[rsp] call A &amp;&amp; return_by_rvalue_ref(A &amp;) ; return_by_rvalue_ref mov rdx, rax lea rcx, QWORD PTR a5$[rsp] call A::A(A &amp;&amp;) ; A::A npad 1 lea rdx, OFFSET FLAT:$SG35842 mov rcx, QWORD PTR __imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; std::cout call std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp;,char const *) ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; npad 1 lea rcx, QWORD PTR a5$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a4$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a3$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a2$[rsp] call A::~A(void) ; A::~A npad 1 lea rcx, QWORD PTR a1$[rsp] call A::~A(void) ; A::~A npad 1 xor eax, eax mov rcx, QWORD PTR __$ArrayPad$[rsp] xor rcx, rsp call __security_check_cookie add rsp, 312 ; 00000138H ret 0main ENDP","tags":["C++"]},{"title":"细拆二分法","path":"/2025/10/25/细拆二分法/","content":"这两周学到了二分相关，思想听起来颇为简单，实际写起来漏洞百出，如果是面向测试案例编程的话，经常胡乱+1-1，随机尝试&gt;或者&gt;=，拆了东墙补西墙，怎么堵都堵不明白。细节太多了，各种写法层出不穷，开区间的，闭区间的，左开右闭的，左闭右开的。找目标值的，找两端目标值位置的，找插入位置的，找最小的，找最大的，就是各种变了花样地找。所以还是一步步搞搞清楚，目前的总结只是从我刷到的六道题中总结的，但感觉万变不离其宗。所以来拿表格总结演示一下。 我的日常写法跟随大众写左闭右开，也就是说最后的答案基本是从left得到的。（虽然最后的退出条件是两者相等，但是为了统一还是用left。） 首先确定一些必要的条件： 由于计算mid时，为了防止溢出，经常使用这一句： 1mid=left+(right-left)/2; 所以，如果窗口长度为偶数，mid计算出来为偏向左边的索引。很符合左闭右开的规则。 举例： left=3，right=6，mid=3+（6-3）/2=4.5=4。 left=0，right=1，mid=0+（1-0）/2=0.5=0。 想找的值比所有都大： left=length-1, right=length, mid=length-1+(length-length+1)/2=length-1+0.5=length-1; left=mid+1=length, 退出循环，进行最后的判断。 想找的值比所有都小： left=0, right=1,mid=0+(1-0)/2=0.5=0 right=mid=0,此时left=right，退出循环，判断索引0是否为想要的值即可。 给的target不在里面怎么办举个例子，此处具体数值只用small和big代表，防止陷入对数值的计算。 1 3 5 7 9 找6 left先到5，right还是9，然后right成为7，找不到的情况下，left和right肯定相邻，并且left为small，right为big。 为了细致表达，考虑完整的三种情况： 第一种：找不到的数的大小处于数组中间： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，mid right 此时，left&lt;right，还可以跑一次循环，left需要往右移动，变成： index 0 。。。 。。。 x x+1 。。。 len-1 number smaller bigger point left，right 此时，left=right，退出循环。最后，我们得到的left所指的这个数就是大于target的最小索引 第二种情况，target比所有数都小，right会不断往左移动，最后还是会和left相邻： index 0 1 。。。 number bigger bigger point left，mid right 此时，由于mid比target大，right还需要往左移，变成： index 0 1 。。。 number bigger bigger point left，mid，right 此时，left=right，退出循环。left值不是我们想要的值，此时left就是大于target值的最小索引。 第三种情况，target比所有数都大，left会不断向右移动，最后和right相邻： index 0 。。。 len-2 len-1 len number smaller nullptr！ point left，mid right 此时left还需要右移，得到： index 0 。。。 。。。 len-2 len-1 len number smaller nullptr！ point left，right 此时left和right相等，退出循环。检查left的值，超出len-1，说明target比所有数都大。 至此，可以稍微总结一下找不到target的情况下，算出来的left： left就是大于target的最小索引，left左边绝对比target小。 left直接跑出长度范围了，那么没别的意义，left-1即len-1即为最大值。 如果想求大于/小于target的最小/最大索引，但有重复target怎么办？上面推导的情况，也就是target不出现/只出现一次时，小于/大于target的最小索引/最大索引其实根据推导的结论也能直接得到了。但是大部分的题目不长这么简单，它会出现很多重复的target，这时候就需要计算边界了。 一般的题目我们都不会知道target会不会存在于数组中。为了保险起见，下面会做完整的推理。 如果存在，并且有很多个，那么就需要计算边界了。首先计算左边界： 计算左边界的时候，如果得到了nums[mid]==target，也不能就此退出，需要继续寻找左边还有没有，这时候就需要让right向左挤压。 首先要想清楚一点，就是left只有在nums[mid]&lt;target的时候才会移动。所以，nums[left]第一次和target相等后，就不会再动了，然后right步步紧逼，最后形成以下局面 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid right 再来一次循环，right再向左移动 index 0 i-1 i i+1 。。。 len-1 number x x 。。。 x point left，mid，right 此时，退出循环，left即为我们要找的最左边。 有很多题都会用到求最左侧的索引。比如2529这道题，找到比0小的，0有可能存在也有可能不存在。如果0存在，那么我们计算出left后，要检查left-1是否存在，如果存在，那么left左边都是比0小的，left-1就是小于0的最大索引。 如果0不存在，又回到了最初那个target不存在的情况，即left本身就为小于target值的最大索引。 -2，-1，3 那么如何求最右侧的索引呢？思路差不多，也就是让left向右步步紧逼。也要搞清楚一点，right的值只会在target&lt;nums[mid]才会移动到mid上。如图，最后都会走向如此局面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left,mid right 此时left还需要右移，得到下面： index 0 i-1 i i+1 i+k i+k+1 。。。 len-1 number x 。。。 x bigger point left，right 此时left=right，而我们发现left所指的是x后面那个数，所以最后我们要返回left-1。 而其实，left即为大于target的最小索引。 那么如果target不存在呢？那我们又回到了最初的那种情况：left即为大于target的最小索引，小于left都比它小。 所以可以发现，如果想求大于target的值的多少，拿到left即可了，left的左边绝对都比tartget小。 那么搞明白这些，也就差不多了。 至于边际条件，搞清楚left的取值范围是[0,len]，注意一下为0时和为len时的情况即可。 回到题目总结：先记住： lower_bound：第一个 ≥ target 的位置 upper_bound：第一个 &gt; target 的位置 lc34 在排序数组中查找元素的第一个和最后一个位置思路： 第一个位置：lower_bound(target) 最后一个位置：upper_bound(target) - 1 特殊情况：检查元素是否存在 lc35 搜索插入位置：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 思路： 找第一个 ≥ target 的位置 解法：直接 lower_bound(target) lc 744 寻找比目标字母大的最小字母：给你一个字符数组 letters，该数组按非递减顺序排序，以及一个字符 target。letters 里至少有两个不同的字符。 返回 letters 中大于 target 的最小的字符。如果不存在这样的字符，则返回 letters 的第一个字符。 思路： 找第一个&gt;target的字母，即用upper_bound。 lc 2529 正整数和负整数的最大计数给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。 换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。 注意：0 既不是正整数也不是负整数。 思路： 负数数量：第一个 ≥ 0 的位置 = lower_bound(0) 正数数量：总数 - 第一个 &gt; 0 的位置 = n - upper_bound(0) 取两者最大值 lc 2300 咒语和药水的成功对数给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。 同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。 请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。 思路： 对每个spell，找第一个 ≥ success/spell 的药水 解法：m - left_bound(success/spell) lc 1385 两个数组间的距离值给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。 「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d 。 思路 检查 [x-d, x+d] 区间是否为空 解法：找第一个 ≥ x-d 的位置，检查是否 &gt; x+d 决策指南 要找什么 使用的函数 例子 第一个 ≥ target 的 lower_bound 插入位置 第一个 &gt; target 的 upper_bound 下一个更大元素 最后一个 = target 的 upper_bound - 1 元素结束位置 最后一个 &lt; target 的 lower_bound - 1 前一个较小元素 统计 target 出现次数 upper_bound - lower_bound 频率统计 注意数组越界和空数组的情况！ 直接用STL每次自己写寻找边界索引很麻烦，了解原理后直接上STL： 123456789#include &lt;algorithm&gt;using namespace std;// 在 [first, last) 范围内查找lower_bound(first, last, value); // 第一个 ≥ value 的位置upper_bound(first, last, value); // 第一个 &gt; value 的位置equal_range(first, last, value); // 返回 pair&lt;lower_bound, upper_bound&gt;binary_search(first, last, value); // 返回 bool，是否存在 基础用法： 12345678910vector&lt;int&gt; nums = &#123;1, 3, 5, 7, 9&#125;;// lower_bound: 第一个 ≥ 4 的位置auto it1 = lower_bound(nums.begin(), nums.end(), 4);// it1 指向 5，索引 = it1 - nums.begin() = 2// upper_bound: 第一个 &gt; 5 的位置 auto it2 = upper_bound(nums.begin(), nums.end(), 5);// it2 指向 7，索引 = 3","tags":["C++","算法","二分查找"]},{"title":"谈谈右值与右值引用","path":"/2025/10/10/谈谈右值/","content":"之前学习了C++的左值右值，但只留在了对于概念的理解上面。今天学习了一下移动构造函数，临时对象/将亡值即将被销毁时会唤起移动构造函数。还有一个std::move()，它的主要作用是将一个左值转换为右值引用，从而强制使用移动构造函数或移动赋值运算符。所以这个std::move()只是进行了一个类型转换而已，并不会触发移动操作。使用std::move（）后，我们就可以调用接受右值引用的函数。 1234template&lt;typename T&gt;constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) noexcept &#123; return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);&#125; 再回顾一下左右值的定义： 左值：通常指的是有名字的变量或者持久对象，可以取它的地址。右值：通常是临时对象，比如函数返回的临时对象、字面量（除了字符串字面量，它实际上是左值）等。 右值引用：使用两个&amp;&amp;表示，例如 int&amp;&amp;。右值引用可以绑定到右值，但不能绑定到左值。 我看有些教程说右值不能取地址，我一直对此非常疑惑：右值为什么不能取地址？既然存在，那肯定在内存/寄存器里，那么右值引用又是什么？ 通过右值引用，我们可以延长右值的生命周期，右值引用本身是一个左值，因为它有名字。所以我们可以对右值引用取地址，这个地址就是被引用的右值对象的地址。 主要需要搞清楚两个问题： 右值引用是一个左值？是 右值引用是否在内存中创建了一个新对象，复制了即将销毁的右值？ 不是的。右值引用并不创建新对象，它只是引用了那个右值（临时对象）。但是，由于右值引用本身是一个左值，所以当使用右值引用时，实际上是在直接操作那个临时对象。 123456int main() &#123; MyString&amp;&amp; rref = MyString(&quot;Hello&quot;); // 右值引用绑定到临时对象 // 这里，临时对象的生命周期被延长到与rref相同 // 没有创建新对象，也没有复制数据，rref就是临时对象的别名 return 0;&#125; 在这个例子中，用一个右值引用rref绑定了一个临时对象。根据C++规则，这样做会延长临时对象的生命周期，使其与右值引用的生命周期相同。所以，在main函数结束前，这个临时对象都不会被销毁。这里没有发生拷贝，也没有移动，只是给临时对象起了一个别名。 BUT 看看到现在，还是用高层的概念去解释一个新的概念。如果一直在高层徘徊，就会产生很多疑问：临时对象是在内存中存储吗？int&amp;&amp;a=2, 2的地址不能被取到，那为什么用右值引用就能取了？那是不是意味着编译器在中间就是开了一个临时对象呢？又有说表达式结束，临时对象就会被销毁。那么如果还是按照刚刚那些高层概念解释，对象都被销毁了，右值引用还在引用什么呢？ 还是下到汇编看看。终于在知乎找到了一篇文章，终于在汇编层面解答了我上面的问题： https://zhuanlan.zhihu.com/p/389978619?share_code=IPKeoBHAwX3u&amp;utm_psn=1960118829079307210 下面是答案： int &amp;&amp;a=0; 其中a是一个右值引用。 这个汇编代码等价于一个左值引用（底层看就是指针常量）引用了一个匿名变量，此匿名变量在C++中不可见，但其实该变量存在于栈上。总结来说，右值引用的底层就是一个指针指向了一个匿名变量。那么如果对右值引用重新赋值修改，改的就是匿名变量的值。","tags":["C++"]},{"title":"顶层const与底层const","path":"/2025/10/09/顶层const与底层const/","content":"理清 C++ 中顶层 const 和底层 const 的概念，感觉理解起来有些混乱。 具体讲解看的是《C++ Primer》。 核心概念顶层 const (top-level const)：对象本身是常量底层 const (low-level const)：指针/引用指向的对象是常量 具体例子1. 顶层 const 的例子123int a = 10;const int b = 20; // b 是顶层 const（b 本身是常量）int *const p1 = &amp;a; // p1 是顶层 const（指针本身是常量） 特点： 对象本身的值不能改变 对于指针：指针的指向不能改变，但指向的内容可以改变 1234int a = 10, b = 20;int *const p = &amp;a; // 顶层 const// p = &amp;b; // 错误！指针指向不能改变*p = 30; // 正确！指向的内容可以改变 2. 底层 const 的例子1234int a = 10;const int *p1 = &amp;a; // p1 是底层 constint const *p2 = &amp;a; // p2 也是底层 const（两种写法等价）const int &amp;r = a; // r 是底层 const 特点： 指针/引用指向的对象是常量 指针的指向可以改变，但不能通过指针修改指向的对象 1234int a = 10, b = 20;const int *p = &amp;a; // 底层 constp = &amp;b; // 正确！指针指向可以改变// *p = 30; // 错误！不能通过指针修改指向的对象 3. 同时包含的情况12const int *const p = &amp;a; // 左边是底层 const，右边是顶层 const// 读作：p 是一个常量指针，指向一个常量整数 记忆技巧方法1：看 const 的位置123int *const p; // const 在 * 右边 → 顶层 constconst int *p; // const 在 * 左边 → 底层 const int const *p; // const 在 * 左边 → 底层 const 方法2：从右向左读12int *const p; // 从右往左：p 是 const 指针，指向 intconst int *p; // 从右往左：p 是指针，指向 const int 实际应用中的区别1. 拷贝操作的限制123456789int a = 10;const int b = 20;// 顶层 const 不影响拷贝int c = b; // 正确：可以忽略顶层 constconst int *p1 = &amp;a; // 底层 constint *p2 = p1; // 错误！不能忽略底层 constconst int *p3 = p1; // 正确：底层 const 可以保留 2. 函数重载12345void func(int *p); // #1void func(const int *p); // #2 重载，底层 const 不同void func(int p); // #3void func(const int p); // #4 错误！顶层 const 不能重载 这里需要用函数值传递仔细说明一下： const不会改变参数的类型，因此不能作为函数重载的依据。会忽略掉顶层const 函数进行传参时，传的都是值的副本，对副本是否加const，不会改变参数类型。 12void fun1(int x);void fun1(const int x);//报错 Redundant ‘fun1’ declaration [readability-redundant-declaration]E:\\UnrealWorld\\project\\Learncpp\\Learncpp\\main.cpp:5:6: note: previously declared here 3. 引用的情况引用天生就是”顶层 const”（因为引用一旦绑定就不能改变），所以我们只关心底层 const： 123int a = 10;int &amp;r1 = a; // 普通引用const int &amp;r2 = a; // 底层 const 引用 总结 类型 示例 const 类型 什么不能改变 常量整数 const int a 顶层 const a 的值 常量指针 int *const p 顶层 const p 的指向 指向常量的指针 const int *p 底层 const 通过 p 修改指向的对象 常量引用 const int &amp;r 底层 const 通过 r 修改绑定的对象 核心区别： 顶层 const：我本身是常量 底层 const：我指向/引用的对象是常量","tags":["C++"]},{"title":"星露谷卡片生成器技术要点记录及解决方案","path":"/2025/09/04/星露谷卡片生成器技术要点记录及解决方案/","content":"我开发了一个星露谷风格的卡片生成器小程序，遇到最麻烦的问题就是字体的处理。微信小程序的字体处理存在诸多限制，尤其是真机环境兼容性问题，有时候在开发工具上一切都好，一上手机啥效果也没了。为了解决这些问题，主要参考了https://juejin.cn/post/7252175375105916965#heading-7这篇文章的解决办法。 微信小程序字体加载限制问题：wx.loadFontFace没有缓存机制，用户每次打开小程序，都要重新下载字体文件。我买的阿里云oss的下行流量包，如果每次都要重新下载字体文件，有点小贵。。。 解决方案： 使用wx.loadFontFace API加载字体 将字体文件转换为base64格式存储 实现字体缓存机制，避免重复下载 12345678910111213141516// 使用loadFontFace加载字体async loadFontFaceFromBase64(fontName, base64) &#123; return new Promise((resolve) =&gt; &#123; wx.loadFontFace(&#123; family: fontName, global: true, source: `data:font/ttf;base64,$&#123;base64&#125;`, scopes: [&#x27;webview&#x27;, &#x27;native&#x27;], success: () =&gt; resolve(true), fail: (err) =&gt; &#123; console.error(`字体加载失败: $&#123;fontName&#125;`, err); resolve(false); &#125; &#125;); &#125;);&#125; OpenType.js 集成如果直接用canvas画下载好的字体，在开发工具上显示是正常的，但在真机测试的时候，渲染出的canvas的字体退回到了系统自带。微信团队好像还是没有解决这个问题。遂参考他人用OpenType.js库解决。 字体解析与缓存OpenType.js是一个强大的字体处理库，可以将字体文件解析为可操作的JavaScript对象。 1234567891011121314151617181920212223// 字体解析核心代码async preloadSingleFont(font) &#123; try &#123; // 从缓存读取base64数据 const base64 = await this.fetchFontBase64(font.id, font.url); // 将base64转换为ArrayBuffer const arrayBuffer = wx.base64ToArrayBuffer(base64); // 使用opentype.js解析字体 const fontType = await opentype.parse(arrayBuffer); // 缓存字体对象 this.fontCache[font.id] = &#123; fontType: fontType, base64: base64 &#125;; console.log(`字体预加载成功: $&#123;font.name&#125;`); &#125; catch (error) &#123; console.error(`字体预加载失败: $&#123;font.name&#125;`, error); &#125;&#125; 字体绘制实现OpenType.js的核心优势在于可以将文字转换为路径对象，然后通过Canvas API进行绘制。 1. 带阴影的字体绘制1234567891011121314151617181920212223242526272829303132333435drawTextWithOpenType(ctx, text, x, y, fontSize, color = &#x27;#1a1a1a&#x27;, fontWeight = &#x27;normal&#x27;) &#123; // 检查是否需要显示阴影 const shouldShowShadow = this.data.selectedFontId !== &#x27;stardew&#x27;; if (!this.fontType) &#123; // 降级到默认绘制方式 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); return; &#125; try &#123; // 字体阴影效果 if (shouldShowShadow) &#123; const shadowPath = this.fontType.getPath(text, x + 0, y + 2, fontSize); const shadowColor = this.colorToRgba(color, 0.4); shadowPath.fill = shadowColor; shadowPath.draw(ctx); &#125; // 使用opentype.js生成路径 const path = this.fontType.getPath(text, x, y, fontSize); path.fill = color; // 粗体效果实现 if (fontWeight === &#x27;bold&#x27;) &#123; this.drawBoldText(path, ctx, text, x, y, fontSize, color); &#125; else &#123; path.draw(ctx); &#125; &#125; catch (error) &#123; console.error(&#x27;opentype.js绘制失败:&#x27;, error); // 降级处理 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); &#125;&#125; 2. 粗体效果实现由于微信小程序环境的限制，在真机测试时还是无法直接使用字体的粗体变体（也没搞懂为什么）。通过多次绘制模拟粗体效果： 123456789101112131415161718// 真机兼容的粗体实现drawBoldText(path, ctx, text, x, y, fontSize, color) &#123; // 绘制原始路径 path.draw(ctx); // 创建偏移路径，模拟粗体效果 const path1 = this.fontType.getPath(text, x + 0.5, y, fontSize); path1.fill = color; path1.draw(ctx); const path2 = this.fontType.getPath(text, x, y + 0.5, fontSize); path2.fill = color; path2.draw(ctx); const path3 = this.fontType.getPath(text, x + 0.5, y + 0.5, fontSize); path3.fill = color; path3.draw(ctx);&#125; 3. 文本换行处理对于长文本，实现了自动换行功能： 123456789101112131415161718192021222324252627282930313233wrapTextWithOpenType(ctx, text, x, y, maxWidth, lineHeight, color = &#x27;#2F1B14&#x27;) &#123; if (!this.fontType) &#123; return this.wrapText(ctx, text, x, y, maxWidth, lineHeight, color); &#125; let line = &#x27;&#x27;; let currentY = y; for (let i = 0; i &lt; text.length; i++) &#123; const testLine = line + text[i]; // 使用默认字体测量宽度（因为opentype.js测量比较复杂） ctx.setFontSize(20); const testWidth = ctx.measureText(testLine).width; if (testWidth &gt; maxWidth &amp;&amp; i &gt; 0) &#123; // 绘制当前行 this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); line = text[i]; currentY += lineHeight; &#125; else &#123; line = testLine; &#125; &#125; // 绘制最后一行 if (line) &#123; this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); currentY += lineHeight; &#125; return currentY;&#125; 双层缓存系统设计文件缓存层为了减少网络请求和提高加载速度，实现了文件缓存： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 字体缓存系统class FontCache &#123; // 读取字体缓存 readFontCache(fontId) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.readFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, encoding: &#x27;utf8&#x27;, success: (res) =&gt; &#123; console.log(`从缓存读取字体: $&#123;fontId&#125;`); resolve(res.data); &#125;, fail: () =&gt; &#123; console.log(`缓存中未找到字体: $&#123;fontId&#125;`); resolve(null); &#125; &#125;); &#125;); &#125; // 写入字体缓存 writeFontCache(fontId, base64Data) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.writeFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, data: base64Data, encoding: &#x27;utf8&#x27;, success: () =&gt; &#123; console.log(`字体缓存写入成功: $&#123;fontId&#125;`); resolve(true); &#125;, fail: (err) =&gt; &#123; console.error(`体缓存写入失败: $&#123;fontId&#125;`, err); resolve(false); &#125; &#125;); &#125;); &#125; // 获取字体base64数据（带缓存） async fetchFontBase64(fontId, fontUrl) &#123; // 先尝试从缓存读取 const cache = await this.readFontCache(fontId); if (cache) &#123; return cache; &#125; // 缓存中没有，从网络下载 console.log(`从网络下载字体: $&#123;fontId&#125;`); return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: fontUrl, method: &#x27;GET&#x27;, responseType: &#x27;arraybuffer&#x27;, success: async (res) =&gt; &#123; try &#123; // 将arraybuffer转换为base64 const base64 = wx.arrayBufferToBase64(res.data); // 写入缓存 await this.writeFontCache(fontId, base64); console.log(`字体下载并缓存成功: $&#123;fontId&#125;, 大小: $&#123;res.data.byteLength&#125; bytes`); resolve(base64); &#125; catch (error) &#123; console.error(`字体转换base64失败: $&#123;fontId&#125;`, error); reject(error); &#125; &#125;, fail: (err) =&gt; &#123; console.error(`字体下载失败: $&#123;fontId&#125;`, err); reject(err); &#125; &#125;); &#125;); &#125;&#125; 内存缓存层最开始用上面的方法，切换还是太慢了，换一个字体要十秒钟。。。还是先加载到内存缓存快一些： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 内存缓存系统class MemoryCache &#123; constructor() &#123; this.fontCache = &#123;&#125;; &#125; // 预加载所有字体到内存缓存 async preloadAllFonts(availableFonts) &#123; console.log(&#x27;开始预加载所有字体...&#x27;); const preloadPromises = []; for (const font of availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125; &#125; // 快速切换字体 async fastSwitchFont(fontId, fontName) &#123; try &#123; console.log(`快速切换字体: $&#123;fontName&#125;...`); // 确保字体缓存对象存在 if (!this.fontCache) &#123; this.fontCache = &#123;&#125;; &#125; // 如果是系统默认字体 if (fontId === &#x27;system&#x27;) &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); console.log(`快速切换到系统默认字体`); return; &#125; // 检查内存缓存 if (this.fontCache[fontId]) &#123; console.log(`从内存缓存快速切换字体: $&#123;fontName&#125;`); this.fontType = this.fontCache[fontId].fontType; this.setData(&#123; fontLoaded: true &#125;); // 异步加载到系统字体（不阻塞切换） this.loadFontFaceFromBase64(fontName, this.fontCache[fontId].base64); return; &#125; // 如果内存缓存中没有，回退到正常加载 console.log(`内存缓存中未找到字体，回退到正常加载: $&#123;fontName&#125;`); await this.loadSelectedFont(); &#125; catch (error) &#123; console.error(`快速切换字体失败: $&#123;fontName&#125;`, error); // 回退到正常加载 await this.loadSelectedFont(); &#125; &#125;&#125; 九宫格边框实现为了实现星露谷风格的边框效果，使用了九宫格技术： 12345678910111213141516171819202122232425262728293031323334// 九宫格边框绘制drawBorder(ctx, width, height, borderWidth = 12) &#123; const slice = 75; // border-image slice const imgPath = &#x27;/imgs/aaa.png&#x27;; wx.getImageInfo(&#123; src: imgPath, success: (res) =&gt; &#123; const imgW = res.width; const imgH = res.height; const path = res.path; // 绘制九个部分 // 四个角 ctx.drawImage(path, 0, 0, slice, slice, 0, 0, borderWidth, borderWidth); // 左上 ctx.drawImage(path, imgW - slice, 0, slice, slice, width - borderWidth, 0, borderWidth, borderWidth); // 右上 ctx.drawImage(path, 0, imgH - slice, slice, slice, 0, height - borderWidth, borderWidth, borderWidth); // 左下 ctx.drawImage(path, imgW - slice, imgH - slice, slice, slice, width - borderWidth, height - borderWidth, borderWidth, borderWidth); // 右下 // 四个边 ctx.drawImage(path, slice, 0, imgW - 2 * slice, slice, borderWidth, 0, width - 2 * borderWidth, borderWidth); // 上 ctx.drawImage(path, slice, imgH - slice, imgW - 2 * slice, slice, borderWidth, height - borderWidth, width - 2 * borderWidth, borderWidth); // 下 ctx.drawImage(path, 0, slice, slice, imgH - 2 * slice, 0, borderWidth, borderWidth, height - 2 * borderWidth); // 左 ctx.drawImage(path, imgW - slice, slice, slice, imgH - 2 * slice, width - borderWidth, borderWidth, borderWidth, height - 2 * borderWidth); // 右 &#125; &#125;);&#125; 动态属性绘制对于卡片的属性部分，实现了动态绘制功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 绘制动态属性drawStats(ctx, startX, startY, width) &#123; const stats = this.data.itemStats.filter(stat =&gt; stat.name &amp;&amp; stat.value); if (stats.length === 0) return startY; let currentY = startY; let completedCount = 0; let hasAsyncIcons = false; // 设置属性文字颜色 ctx.setFillStyle(&#x27;#352f36&#x27;); stats.forEach((stat, index) =&gt; &#123; const statY = startY + (index * 36); if (stat.iconPath) &#123; hasAsyncIcons = true; // 异步加载图标 wx.getImageInfo(&#123; src: stat.iconPath, success: (iconRes) =&gt; &#123; // 绘制图标阴影 ctx.setGlobalAlpha(0.5); ctx.drawImage(iconRes.path, startX - 3, statY - 30 + 3, 35, 35); // 绘制图标主体 ctx.setGlobalAlpha(1.0); ctx.drawImage(iconRes.path, startX, statY - 30, 35, 35); // 绘制属性文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX + 40, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125;, fail: () =&gt; &#123; // 图标加载失败，使用默认文本 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125; &#125;); &#125; else &#123; // 没有图标，直接绘制文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); &#125; &#125;); return startY + (stats.length * 24);&#125; 性能优化策略字体加载优化123456789101112131415161718192021222324252627// 预加载策略async onLoad() &#123; // 初始化字体缓存对象 this.fontCache = &#123;&#125;; // 预加载所有字体到内存缓存 await this.preloadAllFonts(); // 加载当前选中的字体 await this.loadSelectedFont();&#125;// 并行预加载async preloadAllFonts() &#123; const preloadPromises = []; for (const font of this.data.availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125;&#125; 内存管理优化123456789101112131415161718192021222324// 字体缓存管理class FontCacheManager &#123; constructor() &#123; this.fontCache = &#123;&#125;; this.maxCacheSize = 10; // 最大缓存数量 &#125; // 添加字体到缓存 addFont(fontId, fontData) &#123; // 检查缓存大小 if (Object.keys(this.fontCache).length &gt;= this.maxCacheSize) &#123; // 移除最旧的缓存 const oldestKey = Object.keys(this.fontCache)[0]; delete this.fontCache[oldestKey]; &#125; this.fontCache[fontId] = fontData; &#125; // 清理缓存 clearCache() &#123; this.fontCache = &#123;&#125;; &#125;&#125; 错误处理与降级1234567891011121314151617181920212223242526272829// 完善的错误处理机制async loadSelectedFont() &#123; try &#123; // 尝试加载字体 await this.loadFontWithOpenType(); &#125; catch (error) &#123; console.error(&#x27;字体加载失败:&#x27;, error); // 降级处理 try &#123; await this.loadFontWithLoadFontFace(); &#125; catch (fallbackError) &#123; console.error(&#x27;降级加载也失败:&#x27;, fallbackError); // 使用系统默认字体 this.useSystemFont(); &#125; &#125;&#125;// 降级到系统字体useSystemFont() &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); wx.showToast(&#123; title: &#x27;使用系统默认字体&#x27;, icon: &#x27;none&#x27;, duration: 2000 &#125;);&#125; 第一次碰前端相关，写WXML和WXSS用Cursor真的省去了很多重复劳动！我只需要聚焦于底层逻辑还有优化就可以了，把组织容器布局交给AI来做就好。","tags":["小程序","前端"]},{"title":"C++左右值与引用","path":"/2025/08/29/C-左右值与引用/","content":"本笔记为【彻底搞懂C++移动语义/左值/右值/引用！！！】 https://www.bilibili.com/video/BV17ce7zLEzu/?p=2&amp;share_source=copy_web&amp;vd_source=92a7dafd94e8cc1bfc97784a3732ea8d的总结整理 左值和右值左值指的是一个指向特定内存的具有名称的值即具名对象。 如果一个值有名字，那么它就是左值。 右值为临时短暂的表达式或值，生命周期较短，没有一个稳定的、可识别的内存地址。 右值通常代表一个计算的中间结果，一个字面量或者一个即将被销毁的临时对象。 临时的，即用即弃的值，就是右值。 举例： 123int a = 1;int b = 2;int c = a+b; 其中，a,b,c都是左值，1和2都是没有名字的字面值，为右值。a+b的结果也是右值，为临时的中间变量值。 12x++;++x; 其中，x++是右值，编译器先生成一份x值的临时复制，然后才对x递增，返回的是没有自加之前的临时版本。 ++x是对x递增后，马上返回其自身，x和++x具有相同的地址，++x是一个左值。 ++x可以进行赋值操作。x++作为一个右值，赋值会报错。 1234int get_val(int val)&#123; return x;&#125; 其中，x也是一个右值，因为返回的不是x本身，而是x的一个临时复制。 12345678910int set_val(int val)&#123; int *p = &amp;val; x=val;&#125;int main()&#123; set_val(2);//此处的实参2是右值&#125; 进入函数后，形参val变成了左值，可以取地址。函数形参一定是左值，因为有名字。要注意：字符串字面量是一个左值，因为字符串字面量在C++中是一个常量字符数组，编译器会将其存储到程序的只读数据段中。程序运行开始到结束会一直存在。 左值引用我们使用指针可以对左值取地址，但是，指针指向的位置可被任意修改。 左值引用最常见的使用场景就是：希望函数能够修改传入的参数，虽然指针可以做到，但是引用会更清晰安全。 举例：值交换 1234567891011121314151617181920void swap_ptr(int *x, int *y)&#123; int temp = *x; *x= *y; *y= temp;&#125;void swap_ref(int&amp; x, int &amp;y)&#123; int temp=x; x=y; y=temp;&#125;int main()&#123; int a=1, b=2, c=3, d=4; swap_ptr(&amp;a,&amp;b); swap_ref(c,d);&#125; 可以发现引用更加简洁。 非常量左值的引用对象必须是左值。 但是常量左值引用，不仅可以引用左值，还能引用右值： 1const int &amp;x = 11; 但引用右值的作用没多大。 常量左值引用在于复制构造函数、复制赋值运算符的形参。 举例：类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &quot;Person.h&quot;Person::Person(const std::string&amp; nameVal, int ageVal): name(nameVal), age(ageVal)&#123; std::cout &lt;&lt; &quot;普通构造函数被调用 for: &quot; &lt;&lt; nameVal &lt;&lt; std::endl; &#125;Person::~Person()&#123; //std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;Person::Person(const Person&amp; other) : name(other.name), age(other.age) &#123; // 初始化 age std::cout &lt;&lt; &quot;拷贝构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl;&#125;Person&amp; Person::operator=(const Person&amp; other) &#123; std::cout &lt;&lt; &quot;拷贝赋值运算符被调用 from: &quot; &lt;&lt; other.name &lt;&lt; &quot; to: &quot; &lt;&lt; name &lt;&lt; std::endl; // 1. 检查自我赋值 (非常重要！) if (this == &amp;other) &#123; return *this; // 如果是自己给自己赋值，直接返回 &#125; name = other.name; age = other.age; return *this;&#125;void Person::printInfo() const &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;&#125;#include &quot;Person.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//hh// 一个接受常量引用的函数，演示其用法void printPersonInfo(const Person&amp; person) &#123; std::cout &lt;&lt; &quot;在 printPersonInfo 函数中: &quot;; person.printInfo(); // 因为 printInfo() 是 const 成员函数，所以可以在 const 对象上调用&#125;// 一个返回新对象的函数，用于演示Person createPerson(const char* name, int age) &#123; Person p(name, age); // 调用普通构造函数 return p; // 返回值可能会触发拷贝构造（或受RVO/NRVO优化影响）&#125;int main() &#123; std::cout &lt;&lt; &quot;当前控制台代码页: &quot; &lt;&lt; GetConsoleOutputCP() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;----- 创建对象 p1 -----&quot; &lt;&lt; std::endl; Person p1(&quot;Alice&quot;, 25); // 调用普通构造函数 std::cout &lt;&lt; &quot; ----- 通过拷贝构造创建 p2 -----&quot; &lt;&lt; std::endl; Person p2 = p1; // 调用拷贝构造函数 // p1 是一个左值，完美匹配 const Person&amp; 形参 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 通过拷贝赋值给 p2 -----&quot; &lt;&lt; std::endl; Person p3(&quot;Bob&quot;, 30); // 调用普通构造函数 p2 = p3; // 调用拷贝赋值运算符 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 传递常量对象 -----&quot; &lt;&lt; std::endl; const Person constP(&quot;Charlie&quot;, 40); // 一个常量对象 Person p4 = constP; // 成功调用拷贝构造函数，因为形参是 const Person&amp; p4.printInfo(); std::cout &lt;&lt; &quot; ----- 使用临时对象（右值） -----&quot; &lt;&lt; std::endl; p4 = Person(&quot;David&quot;, 50); // 先调用普通构造函数创建临时对象，再调用拷贝赋值运算符 p4.printInfo(); std::cout &lt;&lt; &quot; ----- 函数按常量引用传参 -----&quot; &lt;&lt; std::endl; printPersonInfo(p4); // p4 被以引用的方式传入，避免了一次拷贝 std::cout &lt;&lt; &quot; ----- 函数返回值（可能涉及拷贝） -----&quot; &lt;&lt; std::endl; Person p5 = createPerson(&quot;Eve&quot;, 60); p5.printInfo(); std::cout &lt;&lt; &quot; ----- Main 函数结束，开始析构 -----&quot; &lt;&lt; std::endl; return 0; // 所有对象离开作用域，析构函数按顺序被调用&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435----- 创建对象 p1 -----普通构造函数被调用 for: Alice----- 通过拷贝构造创建 p2 -----拷贝构造函数被调用 from: AliceName: Alice, Age: 25----- 通过拷贝赋值给 p2 -----普通构造函数被调用 for: Bob拷贝赋值运算符被调用 from: Bob to: AliceName: Bob, Age: 30----- 传递常量对象 -----普通构造函数被调用 for: Charlie拷贝构造函数被调用 from: Charlie----- 使用临时对象（右值） -----普通构造函数被调用 for: David拷贝赋值运算符被调用 from: David to: Charlie析构函数被调用 for: David at 000000BDF61BF888----- 函数按常量引用传参 -----在 printPersonInfo 函数中: Name: David, Age: 50----- 函数返回值（可能涉及拷贝） -----普通构造函数被调用 for: EveName: Eve, Age: 60----- Main 函数结束，开始析构 -----析构函数被调用 for: Eve at 000000BDF61BF5F8析构函数被调用 for: David at 000000BDF61BF5A8析构函数被调用 for: Charlie at 000000BDF61BF558析构函数被调用 for: Bob at 000000BDF61BF508析构函数被调用 for: Bob at 000000BDF61BF4B8析构函数被调用 for: Alice at 000000BDF61BF468Process finished with exit code 0. 复制构造函数的参数为什么必须是引用类型呢？ 12Person a;Person b = a; // 希望调用拷贝构造函数 如果没有引用，other是按值传参，为了把a的参数传到other，编译器需要先把a拷贝到other， 那拷贝 a 的时候，需要调用 拷贝构造函数 —— 可问题是这个拷贝构造函数就是我们正在定义的函数！ 于是就形成了一个无限递归调用，编译器根本无法完成参数传递。 因此，C++ 标准规定：拷贝构造函数必须以引用的形式接收参数，否则无法定义。 左值引用和右值引用都是新名字而已，所以都是左值。 右值引用和移动语义复习一下拷贝构造： 123456+----------------+ +----------------+| Person p1 | | Person p2 || this=0x1234 | | this=0x5678 || name -&gt; 0xAAAA | =====&gt; | name -&gt; 0xBBBB || &quot;Alice&quot; | | &quot;Alice&quot; |+----------------+ +----------------+ 说明： p1 的 name 指针指向堆内存 0xAAAA。 调用拷贝构造时，p2 重新分配了一块堆内存 0xBBBB，把 &quot;Alice&quot; 复制过去。 两个对象互不影响，拥有各自的资源。 移动构造： 1234567891011121314151617181920212223242526272829303132333435363738394041// 移动构造Person::Person(Person&amp;&amp; other) noexcept : name(other.name), age(other.age) &#123; other.name = nullptr; // 转移后置空 std::cout &lt;&lt; &quot;移动构造函数 from (对象地址=&quot; &lt;&lt; &amp;other &lt;&lt; &quot;, 旧name指针=&quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) → 新对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;;&#125;// 移动赋值Person&amp; Person::operator=(Person&amp;&amp; other) noexcept &#123; if (this == &amp;other) return *this; delete[] name; // 清理旧资源 name = other.name; // 接管资源 age = other.age; other.name = nullptr; std::cout &lt;&lt; &quot;移动赋值运算符 (接管指针 &quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) 到对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;; return *this;&#125;int main()&#123; ...... p2 = Person(&quot;Charlie&quot;, 40); // 移动赋值 ......&#125;构造前：+----------------+ | 临时Person tmp || this=0x9999 || name -&gt; 0xCCCC || &quot;Bob&quot; |+----------------+移动构造后：+----------------+ +----------------+| 临时Person tmp | | Person p3 || this=0x9999 | | this=0x8888 || name -&gt; null | =====&gt; | name -&gt; 0xCCCC || | | &quot;Bob&quot; |+----------------+ +----------------+ 说明： tmp 是一个临时对象，原本持有堆内存 0xCCCC。 移动构造时，p3 直接接管 tmp 的指针 0xCCCC。 tmp.name 被置为 nullptr，所以它析构时不会释放这块内存。 避免了深拷贝的开销。 总结： 1234567拷贝构造: 移动构造:p1(name-&gt;0xAAAA) tmp(name-&gt;0xCCCC) | | |----&gt; new 0xBBBB |----&gt; p3 接管指针 | copy &quot;Alice&quot; | tmp.name=null | |p2(name-&gt;0xBBBB) p3(name-&gt;0xCCCC) 拷贝 = 重新分配一块新内存，复制内容。 移动 = 直接偷走旧对象的指针，旧对象清空指针。 *为什么移动构造函数后面要写noexpect?(GPT生成总结)* 背景：STL 容器的元素移动 比如 std::vector 扩容时，它会把旧元素转移到新分配的内存里： 123std::vector&lt;Person&gt; v;v.push_back(Person(&quot;Alice&quot;, 20));v.push_back(Person(&quot;Bob&quot;, 30)); 当 vector 空间不够，需要重新分配时，它要把旧的元素（Alice）搬到新的内存。 此时有两个选择： 调用 移动构造函数（更快） 调用 拷贝构造函数（更安全） 如果移动构造函数可能抛异常 vector 在扩容时，搬到一半，结果某个元素的移动构造抛出了异常。 这时新内存里的部分对象构造完成，部分对象失败，旧内存里的对象可能已经被破坏（移动后被置空）。 整个容器就可能进入 不一致状态（既不能保证强异常安全，也不能 rollback）。 为了避免这种情况，标准库****要求：只有在移动构造函数被声明为 noexcept 时，容器才会使用它。否则容器会退而求其次，调用 拷贝构造函数（因为拷贝一般不会抛异常）。 因此在自定义类里实现移动构造函数时，加上 noexcept： 12345Person(Person&amp;&amp; other) noexcept : name(std::move(other.name)), age(other.age) &#123; std::cout &lt;&lt; &quot;移动构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl; other.age = 0;&#125; 总结 没有 noexcept STL 容器在需要移动元素时，可能会选择 拷贝构造，牺牲性能保证安全。 有 noexcept STL 容器可以放心大胆地使用移动构造，获得最大性能提升。 所以 noexcept 是一个 性能保证的承诺： 告诉编译器“移动构造不会抛异常”，容器才敢优化。","tags":["C++"]},{"title":"饼图练习","path":"/2025/08/24/饼图练习/","content":"① 表示比例 (Proportion / Share) — 8句 食品支出占家庭总支出的 30%。Food accounts for 30% in family consumption. 石油占比最大，为 40%。Oil makes up the biggest share, standing at 40%. 医疗费用仅占 5%。Only 5% is spent on medical services. 私家车占出行方式的 60%。Private car accounts for 60% of total transportation. 农业就业人口占比 25%。The agricultural workforce makes up 25% of total employment. 谷物占食品消费的 40%。Grain represent a 40% share of total food consumption. 公共汽车占比 20%。Public buses represent a 20% share of overall transportation. 住房花费占比最高，为 40%。Housing expenditure makes up the largest share, standing at 40%. ② 比较关系 (Comparison) — 8句 教育的比例是医疗的两倍。The propotion of education is twice as high as that of healthcare. 公共汽车的比例是火车的两倍。The share of buses is twice the proportion of trains. 娱乐和通讯的支出几乎持平。The expenditure on entertainment and communication are almost identical./ Spending on entertainment is nearly equal to that on communication. 煤炭的比例略高于天然气. The proportion of coal is slightly higher than that of natural gas. 自行车的比例最低，仅为 3%。Bicycle represents the lowest share, standing at 3%. 医疗费用比教育少 10 个百分点。Spending on healthcare is 10% points lower than that on education. 肉类消费比乳制品高出三倍。Consumption on meat is three times as much as that on dairy products. 蔬菜和水果的比例几乎相同。The share of vegetables is nearly equal to that of fruits. 表达“几乎持平”可以用： almost the same nearly equal almost identical roughly the same level ③ 趋势变化 (Trend / Change) — 8句 公交车的比例逐年下降。The proportion of bus usage decreased steadily each year. 可再生能源翻倍，从 5% 增加到 10%。The share of renewable energy doubled, rising from 5% to 10%. 农业的比例在十年间下降。The share of agricultural declined over the period of 10 years. 火车的比例保持稳定。The share of trains remained stable. 服务业逐年上升，超过了工业。The proportion of service rose each year, exceeding that of industrial sector. 医疗的比例下降了两个百分点。The share of healthcare declined by 2% points. 学习旅游增加了 5 个百分点。Studying tourism accounted for 5% points more than before. 娱乐支出翻了一倍。Entertainment expenditure doubled. ④ 总体特征 (Overall features) — 6句 整体来看，住房和食品主导了家庭预算。Overall, Spending on housing and food dominates the expenditure. 总体而言，化石燃料仍然占主导。Generally, fossil fuel still dominate energy consumption. 总体来看，私家车主导了交通方式。In general, private cars continue to dominate the transportation modes. 总体来看，服务业主导了就业结构。Generally, service sector dominated the employment structure. 观光旅游是最主要的旅游目的。Tourism for sightseeing accounts for the largest share. 总体而言，消费结构变化不大。Overall, the consumption of structure remained stable. “变化不大” → remained stable / showed little change / remained largely unchanged","tags":["英语"]},{"title":"反射机制与序列化","path":"/2025/08/17/反射机制与序列化/","content":"之前用Unity在定义变量时经常会在变量前面标记[SerializeField]，用于将private和protected属性的变量显示在inspector上（public变量会直接显示）。学习时没有细想这些都是什么。关于序列化也是只知道大概的作用。学习UE时碰到了反射系统，而序列化则是反射系统的一大应用场景。此篇笔记将学习记录序列化的概念，反射的概念以及UE的C++反射实现，以及在UE中，序列化又是如何通过反射实现的。 1. 什么是序列化计算机程序的基本运行周期可分为三个阶段：启动、运行和终止。当程序运行时，编译后的代码会被加载到内存中，程序运行过程中产生的变量和对象则存储在内存的栈区和堆区。然而，一旦程序终止运行，这些存储在内存中的临时数据都将丢失。为了持久化这些数据，我们需要在程序运行期间或终止前将其保存下来。这种需求常见于以下场景： 网络传输（如多人游戏中不同客户端间的状态同步） 游戏存档（保存玩家进度） 编辑器中对游戏对象的修改保存 简单来说，序列化 是将程序中的 对象（Object） 或 数据结构 转换为一种 可存储或可传输的格式（如二进制、JSON、XML等），以便在需要时能够重新恢复（反序列化）为原始对象的过程。 2. 什么是反射（Reflection）在UE中，每次修改完C++代码后都需要重新编译才能继续在编辑器中进行操作。这是因为编辑器需要获取代码中的变量和对象信息，以便在面板中提供可视化编辑功能。然而，C++编译过程会丢失许多对编辑器至关重要的元数据信息。C++的源码中的各种类型名变量名函数名文本人类可读，而编译器会直接将人类可读的代码源码编译为机器指令。编译器会丢弃什么呢？对于一个对象MyClass，运行时内存只需要知道某一块内存是哪种类型，并不需要知道名字字符串。对象成员health，只需要知道其在某一块内存的固定偏移量是多少。各种继承关系也会被处理为虚函数表（vtable），运行时通过vtable指针调用虚函数，而vtable本身不包含任何类名或父类名信息。简单来说，一切都被编译器转化为了各种地址信息，程序运行时只需要知道从哪块地址取出什么数据及指令即可。 程序在运行的时候如果想知道： 我自己有哪些类？ 这个类叫什么名字？继承自谁？ 类里面有哪些成员变量，叫什么？是什么类型？ 类里面有哪些成员函数？参数和返回值是什么？ 那么反射机制就是程序在运行时获取自身结构信息（类，属性，函数等）并能够操作他们的能力。 Unreal引擎的许多强大功能和高效工作流都严重依赖反射。没有它，以下事情要么极其困难，要么根本不可能： 序列化： 将对象的状态（属性值）保存到磁盘（如存盘文件.uasset）或通过网络发送。 引擎需要知道对象有哪些属性、它们的类型以及如何读取/写入它们的值。反射提供了这份“属性清单”和操作方法。 垃圾回收： Unreal使用自动内存管理（GC）来回收不再使用的UObject。 GC需要知道一个对象引用了哪些其他UObject（避免误删仍在使用的对象）。反射提供了属性之间的引用关系图（通过UPROPERTY()标记）。 蓝图与C++的互操作性： 这是Unreal最强大的特性之一。让设计师在蓝图中使用C++类、访问C++变量、调用C++函数。 蓝图系统需要在运行时知道C++类有哪些属性(UPROPERTY)暴露给蓝图编辑、有哪些函数(UFUNCTION)可以被蓝图调用、它们的参数是什么。反射提供了这份蓝图与C++交互的“接口说明书”。 编辑器细节面板： 在Unreal编辑器中选中一个Actor或Component时，右侧的“Details”面板会显示其可编辑的属性。 编辑器需要知道这个对象有哪些属性可以显示和编辑、它们的分类（Category）、显示名称、工具提示、取值范围等（通过UPROPERTY的元说明符如EditAnywhere, BlueprintReadWrite, Category=&quot;Movement&quot;等实现）。反射提供了构建这个UI所需的所有信息。 网络复制： 在多人游戏中，服务器需要将状态同步到客户端。 引擎需要知道哪些属性(UPROPERTY(Replicated))需要被复制、在什么条件下复制。反射提供了需要复制的属性列表和复制规则。 命令行动态调用： 通过控制台命令或蓝图调用特定对象的特定函数。 系统需要根据字符串形式的函数名和参数，在运行时找到匹配的函数并执行它。反射提供了函数名到实际函数指针的映射。 动态创建对象： 根据类名（字符串）在运行时创建对象实例（例如NewObject()或SpawnActor()内部查找）。 引擎需要根据提供的类名字符串，找到对应的UClass*，然后才能创建实例。反射维护了所有反射类的注册表。 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 3. UE C++中的反射机制随便打开一个在UE中创建的C++文件，比如MoveActor.h: 12345678910111213141516171819202122232425262728// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MoveActor.generated.h&quot;UCLASS()class RIDERTEST_API AMoveActor : public AActor&#123;\tGENERATED_BODY()\tpublic: // Sets default values for this actor&#x27;s properties\tAMoveActor();protected:\t// Called when the game starts or when spawned\tvirtual void BeginPlay() override;public: // Called every frame\tvirtual void Tick(float DeltaTime) override;\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\tfloat Speed;&#125;; 注意这三个地方：UCLASS()，GENERATED_BODY()，UPROPERTY(EditAnywhere,BlueprintReadWrite)","tags":["UE","C++","序列化","反射"]},{"title":"plantuml和gpt结合快速画图技巧","path":"/2024/10/01/plantuml和gpt结合快速画图/","content":"节省画图的时间——plantuml和gpt结合最近不是在写各种文档嘛。需求，总体以及详细设计里总是缺少不了各种图表。作为一个特别爱偷懒的东西，怎么能不好好利用一下Chatgpt呢？之前手动地去画图表，拖来拖去，自己又排版得不尽如人意，修改一个地方可能要连着一大片都要重新去画。当然，我们不能让gpt直接去给我们画一张图出来，我们需要一个介质语言——plantuml——这是一个非常灵活好用的工具，可以通过简单的语法描述去创建各种各样的图表。这里是这个工具的语言使用指南：plantuml语法手册，我们可以参照这些，尝试去画一些简单的图。 使用工具好的，接下来让我们列出需要用到的工具： Chatgpt（或者其他AI小助手都可以，Kimi也还不错，通义千问也还行，不过都是我Chatgpt崩掉时的备用品） 直接打开plantuml的在线服务器就好——快速开始plantuml在线服务器 别忘了你的脑子——别想着什么事都交给gpt去做哦~ 我们打开在线服务器快速开始plantuml在线服务器，可以看到我们的界面： 没错，这就是我们的第一个例子！非常简单的界面，上面输入内容，下面就会自动生成我们需要的图表！（箭头我写错了不好意思） 具体的语法文档查看plantuml语法手册就可以了！我认为里面已经讲得非常非常详细了。接下来我们用它和chatgpt来帮我们画图。 提示词写法提示词很简单，以下是我经常用的格式： 我现在正在写软件其中一个模块的总体设计文档（说明自己的使用场景），我的这个模块包含以下几个子模块;blablabla……这些子模块是这样交互的，这个模块和这个模块这样。。。那个模块和那个模块那样。。。。，我现在需要你帮我用plantuml，画出这些子模块之间的时序图/模块图。 当然你也不用这么麻烦，如果你之前已经跟gpt把整体的流程打磨核对得差不多了，它已经有相关记忆了，你也可以直接问它要： 我现在需要这个模块的流程图，请你用plantuml的语法格式给我画一份流程图。 由于项目的特殊性，问的时候尽量规避掉敏感词，可以用视频中的音频去替换，总之处理流程大体差不多，谁知道隐私泄露会不会有问题呢 下面演示一下： 这个时候chatgpt会详细得返回一段代码： 给这段代码复制粘贴到我们的plantuml在线服务器上，便可以直接画出图来！ 如果你觉得不满意，可以再让gpt生成一份，但要明确指出你哪不满意。 如果你觉得这样的图不错，你也可以继续在上面这个界面修改文字，细化一些细节，或者更改图标的主题。 最后你可以将画好的图导出成PNG或者SVG，非常方便！一分钱不花！还没有水印！ 如果你之前和gpt已经聊过你要写的那个模块的内容并且帮助gpt理清了逻辑，那么你可能会得到更好的，更细节的图，比如下面这样： 画完了之后可以再参照plantuml的文档，可以加一些自己想加的东西进去，比如note便利贴之类的让图表功能更清楚。 总之，别只让gpt给你写！自己要先理清楚逻辑，你才能知道gpt画的图哪里出了问题！自己一定也要动脑子！","tags":["小技巧"]},{"title":"Daily","path":"/Daily/index.html","content":"2024.11.18今天还没干啥"},{"path":"/about/index.html","content":"鲍波波这是个人简介 Baobobo qq: 1091992414 滕王阁序王勃时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。重九日节选"}]