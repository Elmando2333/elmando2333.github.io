[{"title":"星露谷卡片生成器技术要点记录及解决方案","path":"/2025/09/04/星露谷卡片生成器技术要点记录及解决方案/","content":"我开发了一个星露谷风格的卡片生成器小程序，遇到最麻烦的问题就是字体的处理。微信小程序的字体处理存在诸多限制，尤其是真机环境兼容性问题，有时候在开发工具上一切都好，一上手机啥效果也没了。为了解决这些问题，主要参考了https://juejin.cn/post/7252175375105916965#heading-7这篇文章的解决办法。 微信小程序字体加载限制问题：wx.loadFontFace没有缓存机制，用户每次打开小程序，都要重新下载字体文件。我买的阿里云oss的下行流量包，如果每次都要重新下载字体文件，有点小贵。。。 解决方案： 使用wx.loadFontFace API加载字体 将字体文件转换为base64格式存储 实现字体缓存机制，避免重复下载 12345678910111213141516// 使用loadFontFace加载字体async loadFontFaceFromBase64(fontName, base64) &#123; return new Promise((resolve) =&gt; &#123; wx.loadFontFace(&#123; family: fontName, global: true, source: `data:font/ttf;base64,$&#123;base64&#125;`, scopes: [&#x27;webview&#x27;, &#x27;native&#x27;], success: () =&gt; resolve(true), fail: (err) =&gt; &#123; console.error(`字体加载失败: $&#123;fontName&#125;`, err); resolve(false); &#125; &#125;); &#125;);&#125; OpenType.js 集成如果直接用canvas画下载好的字体，在开发工具上显示是正常的，但在真机测试的时候，渲染出的canvas的字体退回到了系统自带。微信团队好像还是没有解决这个问题。遂参考他人用OpenType.js库解决。 字体解析与缓存OpenType.js是一个强大的字体处理库，可以将字体文件解析为可操作的JavaScript对象。 1234567891011121314151617181920212223// 字体解析核心代码async preloadSingleFont(font) &#123; try &#123; // 从缓存读取base64数据 const base64 = await this.fetchFontBase64(font.id, font.url); // 将base64转换为ArrayBuffer const arrayBuffer = wx.base64ToArrayBuffer(base64); // 使用opentype.js解析字体 const fontType = await opentype.parse(arrayBuffer); // 缓存字体对象 this.fontCache[font.id] = &#123; fontType: fontType, base64: base64 &#125;; console.log(`字体预加载成功: $&#123;font.name&#125;`); &#125; catch (error) &#123; console.error(`字体预加载失败: $&#123;font.name&#125;`, error); &#125;&#125; 字体绘制实现OpenType.js的核心优势在于可以将文字转换为路径对象，然后通过Canvas API进行绘制。 1. 带阴影的字体绘制1234567891011121314151617181920212223242526272829303132333435drawTextWithOpenType(ctx, text, x, y, fontSize, color = &#x27;#1a1a1a&#x27;, fontWeight = &#x27;normal&#x27;) &#123; // 检查是否需要显示阴影 const shouldShowShadow = this.data.selectedFontId !== &#x27;stardew&#x27;; if (!this.fontType) &#123; // 降级到默认绘制方式 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); return; &#125; try &#123; // 字体阴影效果 if (shouldShowShadow) &#123; const shadowPath = this.fontType.getPath(text, x + 0, y + 2, fontSize); const shadowColor = this.colorToRgba(color, 0.4); shadowPath.fill = shadowColor; shadowPath.draw(ctx); &#125; // 使用opentype.js生成路径 const path = this.fontType.getPath(text, x, y, fontSize); path.fill = color; // 粗体效果实现 if (fontWeight === &#x27;bold&#x27;) &#123; this.drawBoldText(path, ctx, text, x, y, fontSize, color); &#125; else &#123; path.draw(ctx); &#125; &#125; catch (error) &#123; console.error(&#x27;opentype.js绘制失败:&#x27;, error); // 降级处理 this.drawDefaultText(ctx, text, x, y, fontSize, color, fontWeight); &#125;&#125; 2. 粗体效果实现由于微信小程序环境的限制，在真机测试时还是无法直接使用字体的粗体变体（也没搞懂为什么）。通过多次绘制模拟粗体效果： 123456789101112131415161718// 真机兼容的粗体实现drawBoldText(path, ctx, text, x, y, fontSize, color) &#123; // 绘制原始路径 path.draw(ctx); // 创建偏移路径，模拟粗体效果 const path1 = this.fontType.getPath(text, x + 0.5, y, fontSize); path1.fill = color; path1.draw(ctx); const path2 = this.fontType.getPath(text, x, y + 0.5, fontSize); path2.fill = color; path2.draw(ctx); const path3 = this.fontType.getPath(text, x + 0.5, y + 0.5, fontSize); path3.fill = color; path3.draw(ctx);&#125; 3. 文本换行处理对于长文本，实现了自动换行功能： 123456789101112131415161718192021222324252627282930313233wrapTextWithOpenType(ctx, text, x, y, maxWidth, lineHeight, color = &#x27;#2F1B14&#x27;) &#123; if (!this.fontType) &#123; return this.wrapText(ctx, text, x, y, maxWidth, lineHeight, color); &#125; let line = &#x27;&#x27;; let currentY = y; for (let i = 0; i &lt; text.length; i++) &#123; const testLine = line + text[i]; // 使用默认字体测量宽度（因为opentype.js测量比较复杂） ctx.setFontSize(20); const testWidth = ctx.measureText(testLine).width; if (testWidth &gt; maxWidth &amp;&amp; i &gt; 0) &#123; // 绘制当前行 this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); line = text[i]; currentY += lineHeight; &#125; else &#123; line = testLine; &#125; &#125; // 绘制最后一行 if (line) &#123; this.drawTextWithOpenTypeNoShadow(ctx, line, x, currentY, 20, color); currentY += lineHeight; &#125; return currentY;&#125; 双层缓存系统设计文件缓存层为了减少网络请求和提高加载速度，实现了文件缓存： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 字体缓存系统class FontCache &#123; // 读取字体缓存 readFontCache(fontId) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.readFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, encoding: &#x27;utf8&#x27;, success: (res) =&gt; &#123; console.log(`从缓存读取字体: $&#123;fontId&#125;`); resolve(res.data); &#125;, fail: () =&gt; &#123; console.log(`缓存中未找到字体: $&#123;fontId&#125;`); resolve(null); &#125; &#125;); &#125;); &#125; // 写入字体缓存 writeFontCache(fontId, base64Data) &#123; const fs = wx.getFileSystemManager(); return new Promise((resolve) =&gt; &#123; fs.writeFile(&#123; filePath: `$&#123;wx.env.USER_DATA_PATH&#125;/font-$&#123;fontId&#125;-base64.txt`, data: base64Data, encoding: &#x27;utf8&#x27;, success: () =&gt; &#123; console.log(`字体缓存写入成功: $&#123;fontId&#125;`); resolve(true); &#125;, fail: (err) =&gt; &#123; console.error(`体缓存写入失败: $&#123;fontId&#125;`, err); resolve(false); &#125; &#125;); &#125;); &#125; // 获取字体base64数据（带缓存） async fetchFontBase64(fontId, fontUrl) &#123; // 先尝试从缓存读取 const cache = await this.readFontCache(fontId); if (cache) &#123; return cache; &#125; // 缓存中没有，从网络下载 console.log(`从网络下载字体: $&#123;fontId&#125;`); return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: fontUrl, method: &#x27;GET&#x27;, responseType: &#x27;arraybuffer&#x27;, success: async (res) =&gt; &#123; try &#123; // 将arraybuffer转换为base64 const base64 = wx.arrayBufferToBase64(res.data); // 写入缓存 await this.writeFontCache(fontId, base64); console.log(`字体下载并缓存成功: $&#123;fontId&#125;, 大小: $&#123;res.data.byteLength&#125; bytes`); resolve(base64); &#125; catch (error) &#123; console.error(`字体转换base64失败: $&#123;fontId&#125;`, error); reject(error); &#125; &#125;, fail: (err) =&gt; &#123; console.error(`字体下载失败: $&#123;fontId&#125;`, err); reject(err); &#125; &#125;); &#125;); &#125;&#125; 内存缓存层最开始用上面的方法，切换还是太慢了，换一个字体要十秒钟。。。还是先加载到内存缓存快一些： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 内存缓存系统class MemoryCache &#123; constructor() &#123; this.fontCache = &#123;&#125;; &#125; // 预加载所有字体到内存缓存 async preloadAllFonts(availableFonts) &#123; console.log(&#x27;开始预加载所有字体...&#x27;); const preloadPromises = []; for (const font of availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125; &#125; // 快速切换字体 async fastSwitchFont(fontId, fontName) &#123; try &#123; console.log(`快速切换字体: $&#123;fontName&#125;...`); // 确保字体缓存对象存在 if (!this.fontCache) &#123; this.fontCache = &#123;&#125;; &#125; // 如果是系统默认字体 if (fontId === &#x27;system&#x27;) &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); console.log(`快速切换到系统默认字体`); return; &#125; // 检查内存缓存 if (this.fontCache[fontId]) &#123; console.log(`从内存缓存快速切换字体: $&#123;fontName&#125;`); this.fontType = this.fontCache[fontId].fontType; this.setData(&#123; fontLoaded: true &#125;); // 异步加载到系统字体（不阻塞切换） this.loadFontFaceFromBase64(fontName, this.fontCache[fontId].base64); return; &#125; // 如果内存缓存中没有，回退到正常加载 console.log(`内存缓存中未找到字体，回退到正常加载: $&#123;fontName&#125;`); await this.loadSelectedFont(); &#125; catch (error) &#123; console.error(`快速切换字体失败: $&#123;fontName&#125;`, error); // 回退到正常加载 await this.loadSelectedFont(); &#125; &#125;&#125; 九宫格边框实现为了实现星露谷风格的边框效果，使用了九宫格技术： 12345678910111213141516171819202122232425262728293031323334// 九宫格边框绘制drawBorder(ctx, width, height, borderWidth = 12) &#123; const slice = 75; // border-image slice const imgPath = &#x27;/imgs/aaa.png&#x27;; wx.getImageInfo(&#123; src: imgPath, success: (res) =&gt; &#123; const imgW = res.width; const imgH = res.height; const path = res.path; // 绘制九个部分 // 四个角 ctx.drawImage(path, 0, 0, slice, slice, 0, 0, borderWidth, borderWidth); // 左上 ctx.drawImage(path, imgW - slice, 0, slice, slice, width - borderWidth, 0, borderWidth, borderWidth); // 右上 ctx.drawImage(path, 0, imgH - slice, slice, slice, 0, height - borderWidth, borderWidth, borderWidth); // 左下 ctx.drawImage(path, imgW - slice, imgH - slice, slice, slice, width - borderWidth, height - borderWidth, borderWidth, borderWidth); // 右下 // 四个边 ctx.drawImage(path, slice, 0, imgW - 2 * slice, slice, borderWidth, 0, width - 2 * borderWidth, borderWidth); // 上 ctx.drawImage(path, slice, imgH - slice, imgW - 2 * slice, slice, borderWidth, height - borderWidth, width - 2 * borderWidth, borderWidth); // 下 ctx.drawImage(path, 0, slice, slice, imgH - 2 * slice, 0, borderWidth, borderWidth, height - 2 * borderWidth); // 左 ctx.drawImage(path, imgW - slice, slice, slice, imgH - 2 * slice, width - borderWidth, borderWidth, borderWidth, height - 2 * borderWidth); // 右 &#125; &#125;);&#125; 动态属性绘制对于卡片的属性部分，实现了动态绘制功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 绘制动态属性drawStats(ctx, startX, startY, width) &#123; const stats = this.data.itemStats.filter(stat =&gt; stat.name &amp;&amp; stat.value); if (stats.length === 0) return startY; let currentY = startY; let completedCount = 0; let hasAsyncIcons = false; // 设置属性文字颜色 ctx.setFillStyle(&#x27;#352f36&#x27;); stats.forEach((stat, index) =&gt; &#123; const statY = startY + (index * 36); if (stat.iconPath) &#123; hasAsyncIcons = true; // 异步加载图标 wx.getImageInfo(&#123; src: stat.iconPath, success: (iconRes) =&gt; &#123; // 绘制图标阴影 ctx.setGlobalAlpha(0.5); ctx.drawImage(iconRes.path, startX - 3, statY - 30 + 3, 35, 35); // 绘制图标主体 ctx.setGlobalAlpha(1.0); ctx.drawImage(iconRes.path, startX, statY - 30, 35, 35); // 绘制属性文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX + 40, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125;, fail: () =&gt; &#123; // 图标加载失败，使用默认文本 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); completedCount++; &#125; &#125;); &#125; else &#123; // 没有图标，直接绘制文字 this.drawTextWithOpenType(ctx, `$&#123;stat.value&#125; $&#123;stat.name&#125;`, startX, statY, 20, &#x27;#352f36&#x27;); &#125; &#125;); return startY + (stats.length * 24);&#125; 性能优化策略字体加载优化123456789101112131415161718192021222324252627// 预加载策略async onLoad() &#123; // 初始化字体缓存对象 this.fontCache = &#123;&#125;; // 预加载所有字体到内存缓存 await this.preloadAllFonts(); // 加载当前选中的字体 await this.loadSelectedFont();&#125;// 并行预加载async preloadAllFonts() &#123; const preloadPromises = []; for (const font of this.data.availableFonts) &#123; if (font.url &amp;&amp; !this.fontCache[font.id]) &#123; preloadPromises.push(this.preloadSingleFont(font)); &#125; &#125; try &#123; await Promise.allSettled(preloadPromises); console.log(&#x27;字体预加载完成&#x27;); &#125; catch (error) &#123; console.error(&#x27;字体预加载部分失败:&#x27;, error); &#125;&#125; 内存管理优化123456789101112131415161718192021222324// 字体缓存管理class FontCacheManager &#123; constructor() &#123; this.fontCache = &#123;&#125;; this.maxCacheSize = 10; // 最大缓存数量 &#125; // 添加字体到缓存 addFont(fontId, fontData) &#123; // 检查缓存大小 if (Object.keys(this.fontCache).length &gt;= this.maxCacheSize) &#123; // 移除最旧的缓存 const oldestKey = Object.keys(this.fontCache)[0]; delete this.fontCache[oldestKey]; &#125; this.fontCache[fontId] = fontData; &#125; // 清理缓存 clearCache() &#123; this.fontCache = &#123;&#125;; &#125;&#125; 错误处理与降级1234567891011121314151617181920212223242526272829// 完善的错误处理机制async loadSelectedFont() &#123; try &#123; // 尝试加载字体 await this.loadFontWithOpenType(); &#125; catch (error) &#123; console.error(&#x27;字体加载失败:&#x27;, error); // 降级处理 try &#123; await this.loadFontWithLoadFontFace(); &#125; catch (fallbackError) &#123; console.error(&#x27;降级加载也失败:&#x27;, fallbackError); // 使用系统默认字体 this.useSystemFont(); &#125; &#125;&#125;// 降级到系统字体useSystemFont() &#123; this.fontType = null; this.setData(&#123; fontLoaded: true &#125;); wx.showToast(&#123; title: &#x27;使用系统默认字体&#x27;, icon: &#x27;none&#x27;, duration: 2000 &#125;);&#125; 第一次碰前端相关，写WXML和WXSS用Cursor真的省去了很多重复劳动！我只需要聚焦于底层逻辑还有优化就可以了，把组织容器布局交给AI来做就好。","tags":["小程序","前端"]},{"title":"C++左右值与引用","path":"/2025/08/29/C-左右值与引用/","content":"本笔记为【彻底搞懂C++移动语义/左值/右值/引用！！！】 https://www.bilibili.com/video/BV17ce7zLEzu/?p=2&amp;share_source=copy_web&amp;vd_source=92a7dafd94e8cc1bfc97784a3732ea8d的总结整理 左值和右值左值指的是一个指向特定内存的具有名称的值即具名对象。 如果一个值有名字，那么它就是左值。 右值为临时短暂的表达式或值，生命周期较短，没有一个稳定的、可识别的内存地址。 右值通常代表一个计算的中间结果，一个字面量或者一个即将被销毁的临时对象。 临时的，即用即弃的值，就是右值。 举例： 123int a = 1;int b = 2;int c = a+b; 其中，a,b,c都是左值，1和2都是没有名字的字面值，为右值。a+b的结果也是右值，为临时的中间变量值。 12x++;++x; 其中，x++是右值，编译器先生成一份x值的临时复制，然后才对x递增，返回的是没有自加之前的临时版本。 ++x是对x递增后，马上返回其自身，x和++x具有相同的地址，++x是一个左值。 ++x可以进行赋值操作。x++作为一个右值，赋值会报错。 1234int get_val(int val)&#123; return x;&#125; 其中，x也是一个右值，因为返回的不是x本身，而是x的一个临时复制。 12345678910int set_val(int val)&#123; int *p = &amp;val; x=val;&#125;int main()&#123; set_val(2);//此处的实参2是右值&#125; 进入函数后，形参val变成了左值，可以取地址。函数形参一定是左值，因为有名字。要注意：字符串字面量是一个左值，因为字符串字面量在C++中是一个常量字符数组，编译器会将其存储到程序的只读数据段中。程序运行开始到结束会一直存在。 左值引用我们使用指针可以对左值取地址，但是，指针指向的位置可被任意修改。 左值引用最常见的使用场景就是：希望函数能够修改传入的参数，虽然指针可以做到，但是引用会更清晰安全。 举例：值交换 1234567891011121314151617181920void swap_ptr(int *x, int *y)&#123; int temp = *x; *x= *y; *y= temp;&#125;void swap_ref(int&amp; x, int &amp;y)&#123; int temp=x; x=y; y=temp;&#125;int main()&#123; int a=1, b=2, c=3, d=4; swap_ptr(&amp;a,&amp;b); swap_ref(c,d);&#125; 可以发现引用更加简洁。 非常量左值的引用对象必须是左值。 但是常量左值引用，不仅可以引用左值，还能引用右值： 1const int &amp;x = 11; 但引用右值的作用没多大。 常量左值引用在于复制构造函数、复制赋值运算符的形参。 举例：类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &quot;Person.h&quot;Person::Person(const std::string&amp; nameVal, int ageVal): name(nameVal), age(ageVal)&#123; std::cout &lt;&lt; &quot;普通构造函数被调用 for: &quot; &lt;&lt; nameVal &lt;&lt; std::endl; &#125;Person::~Person()&#123; //std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;析构函数被调用 for: &quot; &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;Person::Person(const Person&amp; other) : name(other.name), age(other.age) &#123; // 初始化 age std::cout &lt;&lt; &quot;拷贝构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl;&#125;Person&amp; Person::operator=(const Person&amp; other) &#123; std::cout &lt;&lt; &quot;拷贝赋值运算符被调用 from: &quot; &lt;&lt; other.name &lt;&lt; &quot; to: &quot; &lt;&lt; name &lt;&lt; std::endl; // 1. 检查自我赋值 (非常重要！) if (this == &amp;other) &#123; return *this; // 如果是自己给自己赋值，直接返回 &#125; name = other.name; age = other.age; return *this;&#125;void Person::printInfo() const &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;&#125;#include &quot;Person.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//hh// 一个接受常量引用的函数，演示其用法void printPersonInfo(const Person&amp; person) &#123; std::cout &lt;&lt; &quot;在 printPersonInfo 函数中: &quot;; person.printInfo(); // 因为 printInfo() 是 const 成员函数，所以可以在 const 对象上调用&#125;// 一个返回新对象的函数，用于演示Person createPerson(const char* name, int age) &#123; Person p(name, age); // 调用普通构造函数 return p; // 返回值可能会触发拷贝构造（或受RVO/NRVO优化影响）&#125;int main() &#123; std::cout &lt;&lt; &quot;当前控制台代码页: &quot; &lt;&lt; GetConsoleOutputCP() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;----- 创建对象 p1 -----&quot; &lt;&lt; std::endl; Person p1(&quot;Alice&quot;, 25); // 调用普通构造函数 std::cout &lt;&lt; &quot; ----- 通过拷贝构造创建 p2 -----&quot; &lt;&lt; std::endl; Person p2 = p1; // 调用拷贝构造函数 // p1 是一个左值，完美匹配 const Person&amp; 形参 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 通过拷贝赋值给 p2 -----&quot; &lt;&lt; std::endl; Person p3(&quot;Bob&quot;, 30); // 调用普通构造函数 p2 = p3; // 调用拷贝赋值运算符 p2.printInfo(); std::cout &lt;&lt; &quot; ----- 传递常量对象 -----&quot; &lt;&lt; std::endl; const Person constP(&quot;Charlie&quot;, 40); // 一个常量对象 Person p4 = constP; // 成功调用拷贝构造函数，因为形参是 const Person&amp; p4.printInfo(); std::cout &lt;&lt; &quot; ----- 使用临时对象（右值） -----&quot; &lt;&lt; std::endl; p4 = Person(&quot;David&quot;, 50); // 先调用普通构造函数创建临时对象，再调用拷贝赋值运算符 p4.printInfo(); std::cout &lt;&lt; &quot; ----- 函数按常量引用传参 -----&quot; &lt;&lt; std::endl; printPersonInfo(p4); // p4 被以引用的方式传入，避免了一次拷贝 std::cout &lt;&lt; &quot; ----- 函数返回值（可能涉及拷贝） -----&quot; &lt;&lt; std::endl; Person p5 = createPerson(&quot;Eve&quot;, 60); p5.printInfo(); std::cout &lt;&lt; &quot; ----- Main 函数结束，开始析构 -----&quot; &lt;&lt; std::endl; return 0; // 所有对象离开作用域，析构函数按顺序被调用&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435----- 创建对象 p1 -----普通构造函数被调用 for: Alice----- 通过拷贝构造创建 p2 -----拷贝构造函数被调用 from: AliceName: Alice, Age: 25----- 通过拷贝赋值给 p2 -----普通构造函数被调用 for: Bob拷贝赋值运算符被调用 from: Bob to: AliceName: Bob, Age: 30----- 传递常量对象 -----普通构造函数被调用 for: Charlie拷贝构造函数被调用 from: Charlie----- 使用临时对象（右值） -----普通构造函数被调用 for: David拷贝赋值运算符被调用 from: David to: Charlie析构函数被调用 for: David at 000000BDF61BF888----- 函数按常量引用传参 -----在 printPersonInfo 函数中: Name: David, Age: 50----- 函数返回值（可能涉及拷贝） -----普通构造函数被调用 for: EveName: Eve, Age: 60----- Main 函数结束，开始析构 -----析构函数被调用 for: Eve at 000000BDF61BF5F8析构函数被调用 for: David at 000000BDF61BF5A8析构函数被调用 for: Charlie at 000000BDF61BF558析构函数被调用 for: Bob at 000000BDF61BF508析构函数被调用 for: Bob at 000000BDF61BF4B8析构函数被调用 for: Alice at 000000BDF61BF468Process finished with exit code 0. 复制构造函数的参数为什么必须是引用类型呢？ 12Person a;Person b = a; // 希望调用拷贝构造函数 如果没有引用，other是按值传参，为了把a的参数传到other，编译器需要先把a拷贝到other， 那拷贝 a 的时候，需要调用 拷贝构造函数 —— 可问题是这个拷贝构造函数就是我们正在定义的函数！ 于是就形成了一个无限递归调用，编译器根本无法完成参数传递。 因此，C++ 标准规定：拷贝构造函数必须以引用的形式接收参数，否则无法定义。 左值引用和右值引用都是新名字而已，所以都是左值。 右值引用和移动语义复习一下拷贝构造： 123456+----------------+ +----------------+| Person p1 | | Person p2 || this=0x1234 | | this=0x5678 || name -&gt; 0xAAAA | =====&gt; | name -&gt; 0xBBBB || &quot;Alice&quot; | | &quot;Alice&quot; |+----------------+ +----------------+ 说明： p1 的 name 指针指向堆内存 0xAAAA。 调用拷贝构造时，p2 重新分配了一块堆内存 0xBBBB，把 &quot;Alice&quot; 复制过去。 两个对象互不影响，拥有各自的资源。 移动构造： 1234567891011121314151617181920212223242526272829303132333435363738394041// 移动构造Person::Person(Person&amp;&amp; other) noexcept : name(other.name), age(other.age) &#123; other.name = nullptr; // 转移后置空 std::cout &lt;&lt; &quot;移动构造函数 from (对象地址=&quot; &lt;&lt; &amp;other &lt;&lt; &quot;, 旧name指针=&quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) → 新对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;;&#125;// 移动赋值Person&amp; Person::operator=(Person&amp;&amp; other) noexcept &#123; if (this == &amp;other) return *this; delete[] name; // 清理旧资源 name = other.name; // 接管资源 age = other.age; other.name = nullptr; std::cout &lt;&lt; &quot;移动赋值运算符 (接管指针 &quot; &lt;&lt; static_cast&lt;void*&gt;(name) &lt;&lt; &quot;) 到对象地址=&quot; &lt;&lt; this &lt;&lt; &quot; &quot;; return *this;&#125;int main()&#123; ...... p2 = Person(&quot;Charlie&quot;, 40); // 移动赋值 ......&#125;构造前：+----------------+ | 临时Person tmp || this=0x9999 || name -&gt; 0xCCCC || &quot;Bob&quot; |+----------------+移动构造后：+----------------+ +----------------+| 临时Person tmp | | Person p3 || this=0x9999 | | this=0x8888 || name -&gt; null | =====&gt; | name -&gt; 0xCCCC || | | &quot;Bob&quot; |+----------------+ +----------------+ 说明： tmp 是一个临时对象，原本持有堆内存 0xCCCC。 移动构造时，p3 直接接管 tmp 的指针 0xCCCC。 tmp.name 被置为 nullptr，所以它析构时不会释放这块内存。 避免了深拷贝的开销。 总结： 1234567拷贝构造: 移动构造:p1(name-&gt;0xAAAA) tmp(name-&gt;0xCCCC) | | |----&gt; new 0xBBBB |----&gt; p3 接管指针 | copy &quot;Alice&quot; | tmp.name=null | |p2(name-&gt;0xBBBB) p3(name-&gt;0xCCCC) 拷贝 = 重新分配一块新内存，复制内容。 移动 = 直接偷走旧对象的指针，旧对象清空指针。 *为什么移动构造函数后面要写noexpect?(GPT生成总结)* 背景：STL 容器的元素移动 比如 std::vector 扩容时，它会把旧元素转移到新分配的内存里： 123std::vector&lt;Person&gt; v;v.push_back(Person(&quot;Alice&quot;, 20));v.push_back(Person(&quot;Bob&quot;, 30)); 当 vector 空间不够，需要重新分配时，它要把旧的元素（Alice）搬到新的内存。 此时有两个选择： 调用 移动构造函数（更快） 调用 拷贝构造函数（更安全） 如果移动构造函数可能抛异常 vector 在扩容时，搬到一半，结果某个元素的移动构造抛出了异常。 这时新内存里的部分对象构造完成，部分对象失败，旧内存里的对象可能已经被破坏（移动后被置空）。 整个容器就可能进入 不一致状态（既不能保证强异常安全，也不能 rollback）。 为了避免这种情况，标准库****要求：只有在移动构造函数被声明为 noexcept 时，容器才会使用它。否则容器会退而求其次，调用 拷贝构造函数（因为拷贝一般不会抛异常）。 因此在自定义类里实现移动构造函数时，加上 noexcept： 12345Person(Person&amp;&amp; other) noexcept : name(std::move(other.name)), age(other.age) &#123; std::cout &lt;&lt; &quot;移动构造函数被调用 from: &quot; &lt;&lt; other.name &lt;&lt; std::endl; other.age = 0;&#125; 总结 没有 noexcept STL 容器在需要移动元素时，可能会选择 拷贝构造，牺牲性能保证安全。 有 noexcept STL 容器可以放心大胆地使用移动构造，获得最大性能提升。 所以 noexcept 是一个 性能保证的承诺： 告诉编译器“移动构造不会抛异常”，容器才敢优化。","tags":["C++"]},{"title":"饼图练习","path":"/2025/08/24/饼图练习/","content":"① 表示比例 (Proportion / Share) — 8句 食品支出占家庭总支出的 30%。Food accounts for 30% in family consumption. 石油占比最大，为 40%。Oil makes up the biggest share, standing at 40%. 医疗费用仅占 5%。Only 5% is spent on medical services. 私家车占出行方式的 60%。Private car accounts for 60% of total transportation. 农业就业人口占比 25%。The agricultural workforce makes up 25% of total employment. 谷物占食品消费的 40%。Grain represent a 40% share of total food consumption. 公共汽车占比 20%。Public buses represent a 20% share of overall transportation. 住房花费占比最高，为 40%。Housing expenditure makes up the largest share, standing at 40%. ② 比较关系 (Comparison) — 8句 教育的比例是医疗的两倍。The propotion of education is twice as high as that of healthcare. 公共汽车的比例是火车的两倍。The share of buses is twice the proportion of trains. 娱乐和通讯的支出几乎持平。The expenditure on entertainment and communication are almost identical./ Spending on entertainment is nearly equal to that on communication. 煤炭的比例略高于天然气. The proportion of coal is slightly higher than that of natural gas. 自行车的比例最低，仅为 3%。Bicycle represents the lowest share, standing at 3%. 医疗费用比教育少 10 个百分点。Spending on healthcare is 10% points lower than that on education. 肉类消费比乳制品高出三倍。Consumption on meat is three times as much as that on dairy products. 蔬菜和水果的比例几乎相同。The share of vegetables is nearly equal to that of fruits. 表达“几乎持平”可以用： almost the same nearly equal almost identical roughly the same level ③ 趋势变化 (Trend / Change) — 8句 公交车的比例逐年下降。The proportion of bus usage decreased steadily each year. 可再生能源翻倍，从 5% 增加到 10%。The share of renewable energy doubled, rising from 5% to 10%. 农业的比例在十年间下降。The share of agricultural declined over the period of 10 years. 火车的比例保持稳定。The share of trains remained stable. 服务业逐年上升，超过了工业。The proportion of service rose each year, exceeding that of industrial sector. 医疗的比例下降了两个百分点。The share of healthcare declined by 2% points. 学习旅游增加了 5 个百分点。Studying tourism accounted for 5% points more than before. 娱乐支出翻了一倍。Entertainment expenditure doubled. ④ 总体特征 (Overall features) — 6句 整体来看，住房和食品主导了家庭预算。Overall, Spending on housing and food dominates the expenditure. 总体而言，化石燃料仍然占主导。Generally, fossil fuel still dominate energy consumption. 总体来看，私家车主导了交通方式。In general, private cars continue to dominate the transportation modes. 总体来看，服务业主导了就业结构。Generally, service sector dominated the employment structure. 观光旅游是最主要的旅游目的。Tourism for sightseeing accounts for the largest share. 总体而言，消费结构变化不大。Overall, the consumption of structure remained stable. “变化不大” → remained stable / showed little change / remained largely unchanged","tags":["英语"]},{"title":"反射机制与序列化","path":"/2025/08/17/反射机制与序列化/","content":"之前用Unity在定义变量时经常会在变量前面标记[SerializeField]，用于将private和protected属性的变量显示在inspector上（public变量会直接显示）。学习时没有细想这些都是什么。关于序列化也是只知道大概的作用。学习UE时碰到了反射系统，而序列化则是反射系统的一大应用场景。此篇笔记将学习记录序列化的概念，反射的概念以及UE的C++反射实现，以及在UE中，序列化又是如何通过反射实现的。 1. 什么是序列化计算机程序的基本运行周期可分为三个阶段：启动、运行和终止。当程序运行时，编译后的代码会被加载到内存中，程序运行过程中产生的变量和对象则存储在内存的栈区和堆区。然而，一旦程序终止运行，这些存储在内存中的临时数据都将丢失。为了持久化这些数据，我们需要在程序运行期间或终止前将其保存下来。这种需求常见于以下场景： 网络传输（如多人游戏中不同客户端间的状态同步） 游戏存档（保存玩家进度） 编辑器中对游戏对象的修改保存 简单来说，序列化 是将程序中的 对象（Object） 或 数据结构 转换为一种 可存储或可传输的格式（如二进制、JSON、XML等），以便在需要时能够重新恢复（反序列化）为原始对象的过程。 2. 什么是反射（Reflection）在UE中，每次修改完C++代码后都需要重新编译才能继续在编辑器中进行操作。这是因为编辑器需要获取代码中的变量和对象信息，以便在面板中提供可视化编辑功能。然而，C++编译过程会丢失许多对编辑器至关重要的元数据信息。C++的源码中的各种类型名变量名函数名文本人类可读，而编译器会直接将人类可读的代码源码编译为机器指令。编译器会丢弃什么呢？对于一个对象MyClass，运行时内存只需要知道某一块内存是哪种类型，并不需要知道名字字符串。对象成员health，只需要知道其在某一块内存的固定偏移量是多少。各种继承关系也会被处理为虚函数表（vtable），运行时通过vtable指针调用虚函数，而vtable本身不包含任何类名或父类名信息。简单来说，一切都被编译器转化为了各种地址信息，程序运行时只需要知道从哪块地址取出什么数据及指令即可。 程序在运行的时候如果想知道： 我自己有哪些类？ 这个类叫什么名字？继承自谁？ 类里面有哪些成员变量，叫什么？是什么类型？ 类里面有哪些成员函数？参数和返回值是什么？ 那么反射机制就是程序在运行时获取自身结构信息（类，属性，函数等）并能够操作他们的能力。 Unreal引擎的许多强大功能和高效工作流都严重依赖反射。没有它，以下事情要么极其困难，要么根本不可能： 序列化： 将对象的状态（属性值）保存到磁盘（如存盘文件.uasset）或通过网络发送。 引擎需要知道对象有哪些属性、它们的类型以及如何读取/写入它们的值。反射提供了这份“属性清单”和操作方法。 垃圾回收： Unreal使用自动内存管理（GC）来回收不再使用的UObject。 GC需要知道一个对象引用了哪些其他UObject（避免误删仍在使用的对象）。反射提供了属性之间的引用关系图（通过UPROPERTY()标记）。 蓝图与C++的互操作性： 这是Unreal最强大的特性之一。让设计师在蓝图中使用C++类、访问C++变量、调用C++函数。 蓝图系统需要在运行时知道C++类有哪些属性(UPROPERTY)暴露给蓝图编辑、有哪些函数(UFUNCTION)可以被蓝图调用、它们的参数是什么。反射提供了这份蓝图与C++交互的“接口说明书”。 编辑器细节面板： 在Unreal编辑器中选中一个Actor或Component时，右侧的“Details”面板会显示其可编辑的属性。 编辑器需要知道这个对象有哪些属性可以显示和编辑、它们的分类（Category）、显示名称、工具提示、取值范围等（通过UPROPERTY的元说明符如EditAnywhere, BlueprintReadWrite, Category=&quot;Movement&quot;等实现）。反射提供了构建这个UI所需的所有信息。 网络复制： 在多人游戏中，服务器需要将状态同步到客户端。 引擎需要知道哪些属性(UPROPERTY(Replicated))需要被复制、在什么条件下复制。反射提供了需要复制的属性列表和复制规则。 命令行动态调用： 通过控制台命令或蓝图调用特定对象的特定函数。 系统需要根据字符串形式的函数名和参数，在运行时找到匹配的函数并执行它。反射提供了函数名到实际函数指针的映射。 动态创建对象： 根据类名（字符串）在运行时创建对象实例（例如NewObject()或SpawnActor()内部查找）。 引擎需要根据提供的类名字符串，找到对应的UClass*，然后才能创建实例。反射维护了所有反射类的注册表。 C++ 语言本身不支持反射特性，UE 在 C++ 的语法基础上通过 UHT 实现了反射信息的生成，从而实现了运行时的反射的目的。 3. UE C++中的反射机制随便打开一个在UE中创建的C++文件，比如MoveActor.h: 12345678910111213141516171819202122232425262728// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;MoveActor.generated.h&quot;UCLASS()class RIDERTEST_API AMoveActor : public AActor&#123;\tGENERATED_BODY()\tpublic: // Sets default values for this actor&#x27;s properties\tAMoveActor();protected:\t// Called when the game starts or when spawned\tvirtual void BeginPlay() override;public: // Called every frame\tvirtual void Tick(float DeltaTime) override;\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\tfloat Speed;&#125;; 注意这三个地方：UCLASS()，GENERATED_BODY()，UPROPERTY(EditAnywhere,BlueprintReadWrite)","tags":["UE","C++","序列化","反射"]},{"title":"plantuml和gpt结合快速画图技巧","path":"/2024/10/01/plantuml和gpt结合快速画图/","content":"节省画图的时间——plantuml和gpt结合最近不是在写各种文档嘛。需求，总体以及详细设计里总是缺少不了各种图表。作为一个特别爱偷懒的东西，怎么能不好好利用一下Chatgpt呢？之前手动地去画图表，拖来拖去，自己又排版得不尽如人意，修改一个地方可能要连着一大片都要重新去画。当然，我们不能让gpt直接去给我们画一张图出来，我们需要一个介质语言——plantuml——这是一个非常灵活好用的工具，可以通过简单的语法描述去创建各种各样的图表。这里是这个工具的语言使用指南：plantuml语法手册，我们可以参照这些，尝试去画一些简单的图。 使用工具好的，接下来让我们列出需要用到的工具： Chatgpt（或者其他AI小助手都可以，Kimi也还不错，通义千问也还行，不过都是我Chatgpt崩掉时的备用品） 直接打开plantuml的在线服务器就好——快速开始plantuml在线服务器 别忘了你的脑子——别想着什么事都交给gpt去做哦~ 我们打开在线服务器快速开始plantuml在线服务器，可以看到我们的界面： 没错，这就是我们的第一个例子！非常简单的界面，上面输入内容，下面就会自动生成我们需要的图表！（箭头我写错了不好意思） 具体的语法文档查看plantuml语法手册就可以了！我认为里面已经讲得非常非常详细了。接下来我们用它和chatgpt来帮我们画图。 提示词写法提示词很简单，以下是我经常用的格式： 我现在正在写软件其中一个模块的总体设计文档（说明自己的使用场景），我的这个模块包含以下几个子模块;blablabla……这些子模块是这样交互的，这个模块和这个模块这样。。。那个模块和那个模块那样。。。。，我现在需要你帮我用plantuml，画出这些子模块之间的时序图/模块图。 当然你也不用这么麻烦，如果你之前已经跟gpt把整体的流程打磨核对得差不多了，它已经有相关记忆了，你也可以直接问它要： 我现在需要这个模块的流程图，请你用plantuml的语法格式给我画一份流程图。 由于项目的特殊性，问的时候尽量规避掉敏感词，可以用视频中的音频去替换，总之处理流程大体差不多，谁知道隐私泄露会不会有问题呢 下面演示一下： 这个时候chatgpt会详细得返回一段代码： 给这段代码复制粘贴到我们的plantuml在线服务器上，便可以直接画出图来！ 如果你觉得不满意，可以再让gpt生成一份，但要明确指出你哪不满意。 如果你觉得这样的图不错，你也可以继续在上面这个界面修改文字，细化一些细节，或者更改图标的主题。 最后你可以将画好的图导出成PNG或者SVG，非常方便！一分钱不花！还没有水印！ 如果你之前和gpt已经聊过你要写的那个模块的内容并且帮助gpt理清了逻辑，那么你可能会得到更好的，更细节的图，比如下面这样： 画完了之后可以再参照plantuml的文档，可以加一些自己想加的东西进去，比如note便利贴之类的让图表功能更清楚。 总之，别只让gpt给你写！自己要先理清楚逻辑，你才能知道gpt画的图哪里出了问题！自己一定也要动脑子！","tags":["小技巧"]},{"path":"/about/index.html","content":"鲍波波这是个人简介 Baobobo qq: 1091992414 滕王阁序王勃时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。重九日节选"},{"title":"Daily","path":"/Daily/index.html","content":"2024.11.18今天还没干啥"}]